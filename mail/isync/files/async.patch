diff --git AUTHORS AUTHORS
index 76a77ee..1b973ce 100644
--- AUTHORS
+++ AUTHORS
@@ -1,6 +1,3 @@
-Michael Elkins <me@mutt.org>
-	* Author
-
 Oswald Buddenhagen <ossi@users.sf.net>
 	* Contributor, current maintainer
 
@@ -10,6 +7,9 @@ Theodore Ts'o <tytso@mit.edu>
 Nicolas Boullis <nboullis@debian.org>
 	* Debian package maintainer and minor upstream contributions
 
+Michael Elkins <me@mutt.org>
+	* Original author
+
 Send questions and bug reports to the isync-devel@lists.sourceforge.net
 mailing list.
 
diff --git Makefile.am Makefile.am
index 90f9f83..87e9fa9 100644
--- Makefile.am
+++ Makefile.am
@@ -54,19 +54,18 @@ log:
 	   git log --date=iso --log-size --name-only | \
 	     perl -e '$(LOG_PL)' > ChangeLog )
 
-if in_source_build
 deb:
 	CFLAGS="-O2 -mcpu=i686" fakeroot debian/rules binary
 
 deb-clean:
-	dh_clean -Xsrc/
-	fakeroot debian/rules unpatch
+	cd $(srcdir) && \
+	 dh_clean -Xsrc/ && \
+	 fakeroot debian/rules unpatch
 
 distdir distclean: deb-clean
 
 dist-hook:
 	find $(distdir)/debian \( -name .git -o -name .gitignore -o -name .#\*# -o -type l \) -print0 | xargs -0r rm -rf
-endif
 
 dist-sign: dist
 	gpg -b -a $(PACKAGE)-$(VERSION).tar.gz
@@ -76,5 +75,4 @@ rpm:
 	cp $(PACKAGE)-$(VERSION).tar.gz /usr/src/rpm/SOURCES
 	CFLAGS="-O2 -mcpu=i686" rpm -ba --clean isync.spec
 
-docdir = $(datadir)/doc/isync
 doc_DATA = README TODO NEWS ChangeLog AUTHORS
diff --git NEWS NEWS
index 6ba06b7..aa478c9 100644
--- NEWS
+++ NEWS
@@ -1,3 +1,15 @@
+[1.1.0]
+
+Support for hierarchical mailboxes in Patterns.
+
+Full support for IMAP pipelining (streaming, parallelization) added.
+This is considerably faster especially with high-latency networks.
+
+Faster and hopefully more reliable support for IMAP servers without the
+UIDPLUS extension (e.g., M$ Exchange).
+
+More automatic handling of SSL certificates.
+
 [1.0.0]
 
 Essentially a rewrite. Synchronization state storage concept, configuration
diff --git README README
index f73b0f4..2ef9df4 100644
--- README
+++ README
@@ -34,7 +34,7 @@ isync executable still exists; it is a compatibility wrapper around mbsync.
 	* Supports TLS/SSL via imaps: (port 993) and STARTTLS (RFC2595)
 	* Supports CRAM-MD5 (RFC2195) for authentication
 	* Supports NAMESPACE (RFC2342) for simplified configuration
-	* Pipelining for maximum speed (currently only partially implemented)
+	* Pipelining for maximum speed
 
 * Compatibility
 
@@ -56,10 +56,14 @@ isync executable still exists; it is a compatibility wrapper around mbsync.
 * Platforms
 
     At some point, ``isync'' has successfully run on:
-    Linux, Solaris 2.7, OpenBSD 2.8, FreeBSD 4.3, Cygwin
+    Linux, Solaris 2.7, OpenBSD 2.8, FreeBSD 4.3.
+
+    Note that Cygwin cannot be reasonably supported due to restrictions
+    of the Windows file system.
 
 * Requirements
 
+    Berkley DB 4.2+
     OpenSSL for TLS/SSL support (optional)
 
 * Installation
diff --git TODO TODO
index 62f2ae4..f8669f2 100644
--- TODO
+++ TODO
@@ -1,30 +1,49 @@
-make SSL certificate validation more automatic.
+have a look at libpathfinder.
 
-add deamon mode. primary goal: keep imap password in memory.
+find out why mutt's message size calc is confused.
 
-add asynchronous operation to remote mailbox drivers. this is actually
-what prevents us from simply using c-client and thus becoming mailsync.
+add some marker about message being already [remotely] trashed.
+real transactions would be certainly not particularly useful ...
 
-handle custom flags (keywords).
+!srec->msg[t] || (srec->msg[t]->status & M_DEAD)
 
-fix maildir_{open_store,list} to handle partial names (last char not slash).
+use UID EXPUNGE! (rfc4315 (obsoletes rfc2359))
+
+quotas are weird, they make close() fail.
+
+clarify error cases of transactions.
+
+create dbg_srec(srec, fmt, ...).
+
+allow excluding particular boxes from a wildcard spec.
 
-add a way to automatically create and sync subfolders.
+add daemon mode. primary goal: keep imap password in memory.
+also: idling mode.
 
-could store TUID even when UIDPLUS is supported. would avoid duplicated
-messages after abort before new UID arrives.
+parallel fetching of multiple mailboxes.
 
-decouple TUID search from append. that's a prerequisite for usable
-MULTIAPPEND, and is generally good for async. should be way faster, too,
-as it saves repeated mailbox rescans with single-file formats.
+set_flags:
+- imap: grouping commands for efficiency
+- callback should get the flags actually affected. but then, why could flag
+  changes fail at all?
+
+add streaming from fetching to storing.
+
+handle custom flags (keywords).
+
+fix maildir_{open_store,list} to handle partial names (last char not slash).
+use case?
 
 use MULTIAPPEND and FETCH with multiple messages.
 
 create dummies describing MIME structure of messages bigger than MaxSize.
 flagging the dummy would fetch the real message. possibly remove --renew.
+note that all interaction needs to happen on the slave side probably.
 
 don't SELECT boxes unless really needed; in particular not for appending,
 and in write-only mode not before changes are made.
+problem: UIDVALIDITY change detection is delayed, significantly complicating
+matters.
 
 possibly request message attributes on a per-message basis from the drivers.
 considerations:
diff --git acinclude.m4 acinclude.m4
index 5c6d30a..6896985 100644
--- acinclude.m4
+++ acinclude.m4
@@ -16,9 +16,8 @@
 # GNU General Public License for more details.
 
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 
 AC_DEFUN([AM_MAINTAINER_MODE],
 [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
diff --git configure.in configure.in
index 7ff9efc..c3268e4 100644
--- configure.in
+++ configure.in
@@ -1,15 +1,16 @@
 AC_INIT(src/isync.h)
 AM_CONFIG_HEADER(config.h)
-AM_INIT_AUTOMAKE(isync, 1.0.5)
+AM_INIT_AUTOMAKE(isync, 1.1.0)
 
 AM_MAINTAINER_MODE
 
 AM_PROG_CC_STDC
 if test "$GCC" = yes; then
-    CFLAGS="$CFLAGS -pipe -W -Wall -Wshadow -Wstrict-prototypes"
+    CFLAGS="$CFLAGS -pipe -W -Wall -Wshadow -Wstrict-prototypes -ansi -pedantic -Wno-overlength-strings"
+    CPPFLAGS="$CPPFLAGS -D_BSD_SOURCE"
 fi
 
-AC_CHECK_HEADERS([sys/filio.h])
+AC_CHECK_HEADERS(sys/poll.h sys/select.h)
 AC_CHECK_FUNCS(vasprintf)
 
 AC_CHECK_LIB(socket, socket, [SOCK_LIBS="-lsocket"])
@@ -94,8 +95,6 @@ if test "x$ob_cv_enable_compat" != xno; then
 fi
 AM_CONDITIONAL(with_compat, test "x$ob_cv_enable_compat" != xno)
 
-AM_CONDITIONAL(in_source_build, test "x$srcdir" = x.)
-
 AC_OUTPUT(Makefile src/Makefile src/compat/Makefile isync.spec)
 
 if test -n "$have_ssl_paths"; then
diff --git debian/copyright debian/copyright
index df5b04e..ffc9010 100644
--- debian/copyright
+++ debian/copyright
@@ -10,7 +10,7 @@ Copyright:
 
  * isync - IMAP4 to maildir mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2003 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -23,8 +23,8 @@ Copyright:
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
  *
  * As a special exception, isync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
diff --git get-cert get-cert
index fad9f78..a7d10fb 100755
--- get-cert
+++ get-cert
@@ -17,8 +17,8 @@
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 #
 
 if [ $# != 1 ]; then
diff --git isync.spec.in isync.spec.in
index 08ce8cd..80cf299 100644
--- isync.spec.in
+++ isync.spec.in
@@ -22,17 +22,14 @@ non-permanent internet collection (dIMAP).
 ./configure --prefix=/usr
 
 %install
+rm -rf $RPM_BUILD_ROOT
 make DESTDIR=$RPM_BUILD_ROOT install
+rm -rf $RPM_BUILD_ROOT%{_docdir}/%{name}
 
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
 %doc AUTHORS COPYING NEWS README TODO ChangeLog src/mbsyncrc.sample src/compat/isyncrc.sample
-/usr/bin/isync
-/usr/bin/mbsync
-/usr/bin/mdconvert
-/usr/bin/get-cert
-/usr/man/man1/isync.1.gz
-/usr/man/man1/mbsync.1.gz
-/usr/man/man1/mdconvert.1.gz
+%{_bindir}/*
+%{_mandir}/man1/*
diff --git src/Makefile.am src/Makefile.am
index 02d52bb..b9cfffa 100644
--- src/Makefile.am
+++ src/Makefile.am
@@ -5,7 +5,7 @@ SUBDIRS = $(compat_dir)
 
 bin_PROGRAMS = mbsync mdconvert
 
-mbsync_SOURCES = main.c sync.c config.c util.c drv_imap.c drv_maildir.c
+mbsync_SOURCES = main.c sync.c config.c util.c socket.c drv_imap.c drv_maildir.c
 mbsync_LDADD = -ldb $(SSL_LIBS) $(SOCK_LIBS)
 noinst_HEADERS = isync.h
 
@@ -13,4 +13,4 @@ mdconvert_SOURCES = mdconvert.c
 mdconvert_LDADD = -ldb
 
 man_MANS = mbsync.1 mdconvert.1
-EXTRA_DIST = mbsyncrc.sample $(man_MANS)
+EXTRA_DIST = run-tests.pl mbsyncrc.sample $(man_MANS)
diff --git src/compat/config.c src/compat/config.c
index f87ca6f..d68f2c1 100644
--- src/compat/config.c
+++ src/compat/config.c
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "isync.h"
@@ -97,7 +96,7 @@ load_config( const char *path, config_t ***stor )
 
 	if (!(fp = fopen( path, "r" ))) {
 		if (errno != ENOENT)
-			perror( "fopen" );
+			sys_error( "Cannot read config file '%s'", path );
 		return;
 	}
 	if (!Quiet && !Debug && !Verbose)
@@ -241,18 +240,16 @@ write_imap_server( FILE *fp, config_t *cfg )
 	config_t *pbox;
 	char *p, *p2;
 	int hl, a1, a2, a3, a4;
-	char buf[128];
+	char buf[128], ubuf[64];
 	static int tunnels;
 
-	if (cfg->tunnel) {
-		nfasprintf( (char **)&cfg->server_name, "tunnel%d", ++tunnels );
-		fprintf( fp, "IMAPAccount %s\nTunnel \"%s\"\n",
-		         cfg->server_name, cfg->tunnel );
-	} else {
+	if (cfg->tunnel)
+		nfasprintf( (char **)&cfg->old_server_name, "tunnel%d", ++tunnels );
+	else if (cfg->host) {
 		if (sscanf( cfg->host, "%d.%d.%d.%d", &a1, &a2, &a3, &a4 ) == 4)
+			hl = nfsnprintf( buf, sizeof(buf), "%s", cfg->host );
+		else {
 			/* XXX this does not avoid clashes. add port? */
-			cfg->server_name = nfstrdup( cfg->host );
-	else if (cfg->host) {
 			p = strrchr( cfg->host, '.' );
 			if (!p)
 				hl = nfsnprintf( buf, sizeof(buf), "%s", cfg->host );
@@ -262,20 +259,47 @@ write_imap_server( FILE *fp, config_t *cfg )
 				if (p2)
 					hl = sprintf( buf, "%s", p2 + 1 );
 			}
-			if (boxes) /* !o2o */
-				for (pbox = boxes; pbox != cfg; pbox = pbox->next)
-					if (!memcmp( pbox->server_name, buf, hl + 1 )) {
-						nfasprintf( (char **)&cfg->server_name, "%s-%d", buf, ++pbox->servers );
-						goto gotsrv;
-					}
-			cfg->server_name = nfstrdup( buf );
-			cfg->servers = 1;
-		  gotsrv: ;
+		}
+		if (boxes) /* !o2o */
+			for (pbox = boxes; pbox != cfg; pbox = pbox->next)
+				if (!memcmp( pbox->server_name, buf, hl + 1 )) {
+					nfasprintf( (char **)&cfg->old_server_name, "%s-%d", buf, ++pbox->old_servers );
+					goto gotsrv;
+				}
+		cfg->old_server_name = nfstrdup( buf );
+		cfg->old_servers = 1;
+	  gotsrv: ;
 	} else {
 		fprintf( stderr, "ERROR: Neither host nor tunnel specified for mailbox %s.\n", cfg->path );
 		exit( 1 );
-		}
-		fprintf( fp, "IMAPAccount %s\n", cfg->server_name );
+	}
+
+	if (cfg->user)
+		nfsnprintf( ubuf, sizeof(ubuf), "%s@", cfg->user );
+	else
+		ubuf[0] = 0;
+	if (!cfg->host)
+		hl = nfsnprintf( buf, sizeof(buf), "%stunnel", ubuf );
+	else {
+		if (cfg->port != (cfg->use_imaps ? 993 : 143))
+			hl = nfsnprintf( buf, sizeof(buf), "%s%s_%d", ubuf, cfg->host, cfg->port );
+		else
+			hl = nfsnprintf( buf, sizeof(buf), "%s%s", ubuf, cfg->host );
+	}
+	if (boxes) /* !o2o */
+		for (pbox = boxes; pbox != cfg; pbox = pbox->next)
+			if (!memcmp( pbox->server_name, buf, hl + 1 )) {
+				nfasprintf( (char **)&cfg->server_name, "%s-%d", buf, ++pbox->servers );
+				goto ngotsrv;
+			}
+	cfg->server_name = nfstrdup( buf );
+	cfg->servers = 1;
+  ngotsrv: ;
+
+	fprintf( fp, "IMAPAccount %s\n", cfg->server_name );
+	if (cfg->tunnel)
+		fprintf( fp, "Tunnel \"%s\"\n", cfg->tunnel );
+	else {
 		if (cfg->use_imaps)
 			fprintf( fp, "Host imaps:%s\n", cfg->host );
 		else
@@ -289,7 +313,7 @@ write_imap_server( FILE *fp, config_t *cfg )
 	fprintf( fp, "RequireCRAM %s\nRequireSSL %s\n"
 	             "UseSSLv2 %s\nUseSSLv3 %s\nUseTLSv1 %s\n",
 	             tb(cfg->require_cram), tb(cfg->require_ssl),
-		     tb(cfg->use_sslv2), tb(cfg->use_sslv3), tb(cfg->use_tlsv1) );
+	             tb(cfg->use_sslv2), tb(cfg->use_sslv3), tb(cfg->use_tlsv1) );
 	if ((cfg->use_imaps || cfg->use_sslv2 || cfg->use_sslv3 || cfg->use_tlsv1) &&
 	    cfg->cert_file)
 		fprintf( fp, "CertificateFile %s\n", cfg->cert_file );
@@ -300,9 +324,9 @@ static void
 write_imap_store( FILE *fp, config_t *cfg )
 {
 	if (cfg->stores > 1)
-		nfasprintf( (char **)&cfg->store_name, "%s-%d", cfg->server_name, cfg->stores );
+		nfasprintf( (char **)&cfg->store_name, "%s-%d", cfg->old_server_name, cfg->stores );
 	else
-		cfg->store_name = cfg->server_name;
+		cfg->store_name = cfg->old_server_name;
 	fprintf( fp, "IMAPStore %s\nAccount %s\n",
 	         cfg->store_name, cfg->server_name );
 	if (*folder)
diff --git src/compat/convert.c src/compat/convert.c
index 0ed1ba2..19209aa 100644
--- src/compat/convert.c
+++ src/compat/convert.c
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "isync.h"
@@ -28,7 +27,6 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <sys/stat.h>
-#include <errno.h>
 #include <time.h>
 
 #include <db.h>
@@ -73,7 +71,7 @@ convert( config_t *box )
 	FILE *fp;
 	msg_t *msgs;
 	DB *db;
-	int i, ret, fd, uidval, maxuid, bl, uid, rmsgs, nmsgs, uv[2];
+	int i, ret, fd, uidval, maxuid, uid, rmsgs, nmsgs, uv[2];
 	unsigned u;
 	struct stat sb;
 	char buf[_POSIX_PATH_MAX], diumname[_POSIX_PATH_MAX],
@@ -97,10 +95,9 @@ convert( config_t *box )
 	for (i = 0; i < 3; i++) {
 		nfsnprintf( buf, sizeof(buf), "%s/%s", mboxdir, subdirs[i] );
 		if (stat( buf, &sb )) {
-			fprintf( stderr, "ERROR: stat %s: %s (errno %d)\n", buf,
-			         strerror(errno), errno );
+			sys_error( "ERROR: cannot access %s", buf );
 			fprintf( stderr,
-			         "ERROR: %s does not appear to be a valid maildir style mailbox\n",
+			         "ERROR: '%s' does not appear to be a valid maildir style mailbox\n",
 			         mboxdir );
 			goto err1;
 		}
@@ -111,7 +108,7 @@ convert( config_t *box )
 	nfsnprintf( sname, sizeof(sname), "%s/.mbsyncstate", mboxdir );
 
 	if ((fd = open( ilname, O_WRONLY|O_CREAT, 0600 )) < 0) {
-		perror( ilname );
+		sys_error( "Cannot create %s", ilname );
 		goto err1;
 	}
 #if SEEK_SET != 0
@@ -121,20 +118,20 @@ convert( config_t *box )
 	lck.l_type = F_WRLCK;
 #endif
 	if (fcntl( fd, F_SETLKW, &lck )) {
-		perror( ilname );
+		sys_error( "Cannot lock %s", ilname );
 	  err2:
 		close( fd );
 		goto err1;
 	}
 
 	if (!(fp = fopen( iuvname, "r" ))) {
-		perror( iuvname );
+		sys_error( "Cannot open %s", iuvname );
 		goto err2;
 	}
 	fscanf( fp, "%d", &uidval );
 	fclose( fp );
 	if (!(fp = fopen( imuname, "r" ))) {
-		perror( imuname );
+		sys_error( "Cannot open %s", imuname );
 		goto err2;
 	}
 	fscanf( fp, "%d", &maxuid );
@@ -160,12 +157,11 @@ convert( config_t *box )
 	rmsgs = 0;
 	nmsgs = 0;
 	for (i = 0; i < 2; i++) {
-		bl = nfsnprintf( buf, sizeof(buf), "%s/%s/", mboxdir, subdirs[i] );
+		nfsnprintf( buf, sizeof(buf), "%s/%s/", mboxdir, subdirs[i] );
 		if (!(d = opendir( buf ))) {
-			perror( "opendir" );
+			sys_error( "Cannot list %s", buf );
 		  err4:
-			if (msgs)
-				free( msgs );
+			free( msgs );
 			if (db)
 				db->close( db, 0 );
 			goto err2;
@@ -200,7 +196,7 @@ convert( config_t *box )
 	qsort( msgs, nmsgs, sizeof(msg_t), compare_uids );
 
 	if (!(fp = fopen( sname, "w" ))) {
-		perror( sname );
+		sys_error( "Cannot create %s", sname );
 		goto err4;
 	}
 	if (box->max_messages) {
@@ -239,7 +235,7 @@ convert( config_t *box )
 		rename( iumname, diumname );
 	} else {
 		if (!(fp = fopen( uvname, "w" ))) {
-			perror( uvname );
+			sys_error( "Cannot create %s", uvname );
 			goto err4;
 		}
 		fprintf( fp, "%d\n%d\n", uidval, maxuid );
@@ -252,8 +248,7 @@ convert( config_t *box )
 	close( fd );
 	unlink( ilname );
 
-	if (msgs)
-		free( msgs );
+	free( msgs );
 	free( mboxdir );
 	return;
 }
diff --git src/compat/isync.1 src/compat/isync.1
index 21a7268..1463f8a 100644
--- src/compat/isync.1
+++ src/compat/isync.1
@@ -14,11 +14,10 @@
 \"  GNU General Public License for more details.
 \"
 \"  You should have received a copy of the GNU General Public License
-\"  along with this program; if not, write to the Free Software
-\"  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\"  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 \"
 ..
-.TH isync 1 "2004 Mar 29"
+.TH isync 1 "2010 Feb 7"
 ..
 .SH NAME
 isync - synchronize IMAP4 and Maildir mailboxes
@@ -105,6 +104,9 @@ Specifies the hostname of the IMAP server
 \fB-u\fR, \fB--user\fR \fIuser\fR
 Specifies the login name to access the IMAP server (default: $USER)
 .TP
+\fB-P\fR, \fB--pass\fR \fIpassword\fR
+Specifies the password to access the IMAP server (prompted for by default)
+.TP
 \fB-M\fR, \fB--maildir\fR \fIdir\fR
 Specifies the location for your local mailboxes.
 .TP
@@ -313,7 +315,6 @@ mbsync(1), mdconvert(1), mutt(1), maildir(5)
 .P
 Up to date information on \fBisync\fR can be found at http://isync.sf.net/
 ..
-.SH AUTHOR
-Written by Michael R. Elkins <me@mutt.org>,
-.br
-maintained by Oswald Buddenhagen <ossi@users.sf.net>.
+.SH AUTHORS
+Originally written by Michael R. Elkins,
+currently maintained by Oswald Buddenhagen.
diff --git src/compat/isync.h src/compat/isync.h
index ad6954d..60bde4a 100644
--- src/compat/isync.h
+++ src/compat/isync.h
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define _GNU_SOURCE
@@ -41,7 +40,9 @@ typedef struct config {
 	struct config *next;
 
 	const char *server_name;
+	const char *old_server_name;
 	int servers;
+	int old_servers;
 	char *host;
 	int port;
 	char *user;
@@ -98,4 +99,5 @@ char *nfstrdup( const char *str );
 int nfvasprintf( char **str, const char *fmt, va_list va );
 int nfasprintf( char **str, const char *fmt, ... );
 int nfsnprintf( char *buf, int blen, const char *fmt, ... );
+void sys_error( const char *, ... );
 void ATTR_NORETURN oob( void );
diff --git src/compat/main.c src/compat/main.c
index 6183a91..e008864 100644
--- src/compat/main.c
+++ src/compat/main.c
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "isync.h"
@@ -29,12 +28,11 @@
 #include <limits.h>
 #include <pwd.h>
 #include <stdio.h>
-#include <errno.h>
 #include <string.h>
 #include <ctype.h>
 #include <dirent.h>
 
-#if HAVE_GETOPT_LONG
+#ifdef HAVE_GETOPT_LONG
 # define _GNU_SOURCE
 # include <getopt.h>
 struct option Opts[] = {
@@ -60,6 +58,7 @@ struct option Opts[] = {
 	{"debug", 0, NULL, 'D'},
 	{"quiet", 0, NULL, 'q'},
 	{"user", 1, NULL, 'u'},
+	{"pass", 1, NULL, 'P'},
 	{"version", 0, NULL, 'v'},
 	{"verbose", 0, NULL, 'V'},
 	{0, 0, 0, 0}
@@ -79,7 +78,8 @@ usage( int code )
 	fputs(
 PACKAGE " " VERSION " - mbsync wrapper: IMAP4 to maildir synchronizer\n"
 "Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>\n"
-"Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>\n"
+"Copyright (C) 2002-2006,2008,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>\n"
+"Copyright (C) 2004 Theodore Ts'o <tytso@mit.edu>\n"
 "usage:\n"
 " " PACKAGE " [ flags ] mailbox [mailbox ...]\n"
 " " PACKAGE " [ flags ] -a\n"
@@ -100,6 +100,7 @@ PACKAGE " " VERSION " - mbsync wrapper: IMAP4 to maildir synchronizer\n"
 "  -s, --host HOST	IMAP server address\n"
 "  -p, --port PORT	server IMAP port\n"
 "  -u, --user USER	IMAP user name\n"
+"  -P, --pass PASSWORD	IMAP password\n"
 "  -c, --config CONFIG	read an alternate config file (default: ~/.isyncrc)\n"
 "  -D, --debug		print debugging messages\n"
 "  -V, --verbose		verbose mode (display network traffic)\n"
@@ -182,10 +183,10 @@ main( int argc, char **argv )
 	maildir = "~";
 	xmaildir = Home;
 
-#define FLAGS "wW:alCLRc:defhp:qu:r:F:M:1I:s:vVD"
+#define FLAGS "wW:alCLRc:defhp:qu:P:r:F:M:1I:s:vVD"
 
 	mod = all = list = ops = writeout = Quiet = Verbose = Debug = 0;
-#if HAVE_GETOPT_LONG
+#ifdef HAVE_GETOPT_LONG
 	while ((i = getopt_long( argc, argv, FLAGS, Opts, NULL )) != -1)
 #else
 	while ((i = getopt( argc, argv, FLAGS )) != -1)
@@ -250,7 +251,7 @@ main( int argc, char **argv )
 			mod = 1;
 			break;
 		case 's':
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 			if (!strncasecmp( "imaps:", optarg, 6 )) {
 				global.use_imaps = 1;
 				global.port = 993;
@@ -266,11 +267,15 @@ main( int argc, char **argv )
 			global.user = optarg;
 			mod = 1;
 			break;
+		case 'P':
+			global.pass = optarg;
+			mod = 1;
+			break;
 		case 'D':
 			Debug = 1;
 			break;
 		case 'V':
-			Verbose = 1;
+			Verbose++;
 			break;
 		case 'q':
 			Quiet++;
@@ -331,7 +336,7 @@ main( int argc, char **argv )
 			struct dirent *de;
 
 			if (!(dir = opendir( xmaildir ))) {
-				fprintf( stderr, "%s: %s\n", xmaildir, strerror(errno) );
+				sys_error( "Cannot list '%s'", xmaildir );
 				return 1;
 			}
 			while ((de = readdir( dir ))) {
@@ -374,13 +379,13 @@ main( int argc, char **argv )
 			outconfig = path2;
 		}
 		if ((fd = creat( outconfig, 0666 )) < 0) {
-			fprintf( stderr, "Error: cannot write new config %s: %s\n", outconfig, strerror(errno) );
+			sys_error( "Error: cannot create config file '%s'", outconfig );
 			return 1;
 		}
 	} else {
 		strcpy( path2, "/tmp/mbsyncrcXXXXXX" );
 		if ((fd = mkstemp( path2 )) < 0) {
-			fprintf( stderr, "Can't create temp file\n" );
+			sys_error( "Error: cannot create temporary config file" );
 			return 1;
 		}
 	}
@@ -390,7 +395,7 @@ main( int argc, char **argv )
 		return 0;
 	args = 0;
 	add_arg( &args, "mbsync" );
-	if (Verbose)
+	while (--Verbose >= 0)
 		add_arg( &args, "-V" );
 	if (Debug)
 		add_arg( &args, "-D" );
@@ -427,6 +432,6 @@ main( int argc, char **argv )
 				add_arg( &args, find_box( argv[optind] )->channel_name );
 	}
 	execvp( args[0], args );
-	perror( args[0] );
+	sys_error( "Cannot execute %s", args[0] );
 	return 1;
 }
diff --git src/compat/util.c src/compat/util.c
index 358b0d3..cca2072 100644
--- src/compat/util.c
+++ src/compat/util.c
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "isync.h"
@@ -27,6 +26,19 @@
 #include <pwd.h>
 #include <ctype.h>
 
+void
+sys_error( const char *msg, ... )
+{
+	va_list va;
+	char buf[1024];
+
+	va_start( va, msg );
+	if ((unsigned)vsnprintf( buf, sizeof(buf), msg, va ) >= sizeof(buf))
+		oob();
+	va_end( va );
+	perror( buf );
+}
+
 char *
 next_arg( char **s )
 {
diff --git src/config.c src/config.c
index d8f9b52..ab6fa56 100644
--- src/config.c
+++ src/config.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2011 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -25,17 +24,18 @@
 
 #include <unistd.h>
 #include <limits.h>
-#include <errno.h>
 #include <pwd.h>
 #include <sys/types.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
 
+driver_t *drivers[N_DRIVERS] = { &maildir_driver, &imap_driver };
+
 store_conf_t *stores;
 channel_conf_t *channels;
 group_conf_t *groups;
-int global_mops, global_sops;
+int global_ops[2];
 char *global_sync_state;
 
 int
@@ -50,8 +50,8 @@ parse_bool( conffile_t *cfile )
 	    strcasecmp( cfile->val, "false" ) &&
 	    strcasecmp( cfile->val, "off" ) &&
 	    strcmp( cfile->val, "0" ))
-		fprintf( stderr, "%s:%d: invalid boolean value '%s'\n",
-		         cfile->file, cfile->line, cfile->val );
+		error( "%s:%d: invalid boolean value '%s'\n",
+		       cfile->file, cfile->line, cfile->val );
 	return 0;
 }
 
@@ -63,8 +63,8 @@ parse_int( conffile_t *cfile )
 
 	ret = strtol( cfile->val, &p, 10 );
 	if (*p) {
-		fprintf( stderr, "%s:%d: invalid integer value '%s'\n",
-		         cfile->file, cfile->line, cfile->val );
+		error( "%s:%d: invalid integer value '%s'\n",
+		       cfile->file, cfile->line, cfile->val );
 		return 0;
 	}
 	return ret;
@@ -92,7 +92,7 @@ parse_size( conffile_t *cfile )
 }
 
 static int
-getopt_helper( conffile_t *cfile, int *cops, int *mops, int *sops, char **sync_state )
+getopt_helper( conffile_t *cfile, int *cops, int ops[], char **sync_state )
 {
 	char *arg;
 
@@ -112,56 +112,56 @@ getopt_helper( conffile_t *cfile, int *cops, int *mops, int *sops, char **sync_s
 			else if (!strcasecmp( "Flags", arg ))
 				*cops |= OP_FLAGS;
 			else if (!strcasecmp( "PullReNew", arg ))
-				*sops |= OP_RENEW;
+				ops[S] |= OP_RENEW;
 			else if (!strcasecmp( "PullNew", arg ))
-				*sops |= OP_NEW;
+				ops[S] |= OP_NEW;
 			else if (!strcasecmp( "PullDelete", arg ))
-				*sops |= OP_DELETE;
+				ops[S] |= OP_DELETE;
 			else if (!strcasecmp( "PullFlags", arg ))
-				*sops |= OP_FLAGS;
+				ops[S] |= OP_FLAGS;
 			else if (!strcasecmp( "PushReNew", arg ))
-				*mops |= OP_RENEW;
+				ops[M] |= OP_RENEW;
 			else if (!strcasecmp( "PushNew", arg ))
-				*mops |= OP_NEW;
+				ops[M] |= OP_NEW;
 			else if (!strcasecmp( "PushDelete", arg ))
-				*mops |= OP_DELETE;
+				ops[M] |= OP_DELETE;
 			else if (!strcasecmp( "PushFlags", arg ))
-				*mops |= OP_FLAGS;
+				ops[M] |= OP_FLAGS;
 			else if (!strcasecmp( "All", arg ) || !strcasecmp( "Full", arg ))
 				*cops |= XOP_PULL|XOP_PUSH;
 			else if (strcasecmp( "None", arg ) && strcasecmp( "Noop", arg ))
-				fprintf( stderr, "%s:%d: invalid Sync arg '%s'\n",
-				         cfile->file, cfile->line, arg );
+				error( "%s:%d: invalid Sync arg '%s'\n",
+				       cfile->file, cfile->line, arg );
 		while ((arg = next_arg( &cfile->rest )));
-		*mops |= XOP_HAVE_TYPE;
+		ops[M] |= XOP_HAVE_TYPE;
 	} else if (!strcasecmp( "Expunge", cfile->cmd )) {
 		arg = cfile->val;
 		do
 			if (!strcasecmp( "Both", arg ))
 				*cops |= OP_EXPUNGE;
 			else if (!strcasecmp( "Master", arg ))
-				*mops |= OP_EXPUNGE;
+				ops[M] |= OP_EXPUNGE;
 			else if (!strcasecmp( "Slave", arg ))
-				*sops |= OP_EXPUNGE;
+				ops[S] |= OP_EXPUNGE;
 			else if (strcasecmp( "None", arg ))
-				fprintf( stderr, "%s:%d: invalid Expunge arg '%s'\n",
-				         cfile->file, cfile->line, arg );
+				error( "%s:%d: invalid Expunge arg '%s'\n",
+				       cfile->file, cfile->line, arg );
 		while ((arg = next_arg( &cfile->rest )));
-		*mops |= XOP_HAVE_EXPUNGE;
+		ops[M] |= XOP_HAVE_EXPUNGE;
 	} else if (!strcasecmp( "Create", cfile->cmd )) {
 		arg = cfile->val;
 		do
 			if (!strcasecmp( "Both", arg ))
 				*cops |= OP_CREATE;
 			else if (!strcasecmp( "Master", arg ))
-				*mops |= OP_CREATE;
+				ops[M] |= OP_CREATE;
 			else if (!strcasecmp( "Slave", arg ))
-				*sops |= OP_CREATE;
+				ops[S] |= OP_CREATE;
 			else if (strcasecmp( "None", arg ))
-				fprintf( stderr, "%s:%d: invalid Create arg '%s'\n",
-				         cfile->file, cfile->line, arg );
+				error( "%s:%d: invalid Create arg '%s'\n",
+				       cfile->file, cfile->line, arg );
 		while ((arg = next_arg( &cfile->rest )));
-		*mops |= XOP_HAVE_CREATE;
+		ops[M] |= XOP_HAVE_CREATE;
 	} else if (!strcasecmp( "SyncState", cfile->cmd ))
 		*sync_state = expand_strdup( cfile->val );
 	else
@@ -182,8 +182,7 @@ getcline( conffile_t *cfile )
 		if (*cfile->cmd == '#')
 			continue;
 		if (!(cfile->val = next_arg( &p ))) {
-			fprintf( stderr, "%s:%d: parameter missing\n",
-			         cfile->file, cfile->line );
+			error( "%s:%d: parameter missing\n", cfile->file, cfile->line );
 			continue;
 		}
 		cfile->rest = p;
@@ -194,29 +193,29 @@ getcline( conffile_t *cfile )
 
 /* XXX - this does not detect None conflicts ... */
 int
-merge_ops( int cops, int *mops, int *sops )
+merge_ops( int cops, int ops[] )
 {
 	int aops;
 
-	aops = *mops | *sops;
-	if (*mops & XOP_HAVE_TYPE) {
+	aops = ops[M] | ops[S];
+	if (ops[M] & XOP_HAVE_TYPE) {
 		if (aops & OP_MASK_TYPE) {
 			if (aops & cops & OP_MASK_TYPE) {
 			  cfl:
-				fprintf( stderr, "Conflicting Sync args specified.\n" );
+				error( "Conflicting Sync args specified.\n" );
 				return 1;
 			}
-			*mops |= cops & OP_MASK_TYPE;
-			*sops |= cops & OP_MASK_TYPE;
+			ops[M] |= cops & OP_MASK_TYPE;
+			ops[S] |= cops & OP_MASK_TYPE;
 			if (cops & XOP_PULL) {
-				if (*sops & OP_MASK_TYPE)
+				if (ops[S] & OP_MASK_TYPE)
 					goto cfl;
-				*sops |= OP_MASK_TYPE;
+				ops[S] |= OP_MASK_TYPE;
 			}
 			if (cops & XOP_PUSH) {
-				if (*mops & OP_MASK_TYPE)
+				if (ops[M] & OP_MASK_TYPE)
 					goto cfl;
-				*mops |= OP_MASK_TYPE;
+				ops[M] |= OP_MASK_TYPE;
 			}
 		} else if (cops & (OP_MASK_TYPE|XOP_MASK_DIR)) {
 			if (!(cops & OP_MASK_TYPE))
@@ -224,26 +223,26 @@ merge_ops( int cops, int *mops, int *sops )
 			else if (!(cops & XOP_MASK_DIR))
 				cops |= XOP_PULL|XOP_PUSH;
 			if (cops & XOP_PULL)
-				*sops |= cops & OP_MASK_TYPE;
+				ops[S] |= cops & OP_MASK_TYPE;
 			if (cops & XOP_PUSH)
-				*mops |= cops & OP_MASK_TYPE;
+				ops[M] |= cops & OP_MASK_TYPE;
 		}
 	}
-	if (*mops & XOP_HAVE_EXPUNGE) {
+	if (ops[M] & XOP_HAVE_EXPUNGE) {
 		if (aops & cops & OP_EXPUNGE) {
-			fprintf( stderr, "Conflicting Expunge args specified.\n" );
+			error( "Conflicting Expunge args specified.\n" );
 			return 1;
 		}
-		*mops |= cops & OP_EXPUNGE;
-		*sops |= cops & OP_EXPUNGE;
+		ops[M] |= cops & OP_EXPUNGE;
+		ops[S] |= cops & OP_EXPUNGE;
 	}
-	if (*mops & XOP_HAVE_CREATE) {
+	if (ops[M] & XOP_HAVE_CREATE) {
 		if (aops & cops & OP_CREATE) {
-			fprintf( stderr, "Conflicting Create args specified.\n" );
+			error( "Conflicting Create args specified.\n" );
 			return 1;
 		}
-		*mops |= cops & OP_CREATE;
-		*sops |= cops & OP_CREATE;
+		ops[M] |= cops & OP_CREATE;
+		ops[S] |= cops & OP_CREATE;
 	}
 	return 0;
 }
@@ -252,12 +251,12 @@ int
 load_config( const char *where, int pseudo )
 {
 	conffile_t cfile;
-	store_conf_t *store, **storeapp = &stores, **sptarg;
+	store_conf_t *store, **storeapp = &stores;
 	channel_conf_t *channel, **channelapp = &channels;
 	group_conf_t *group, **groupapp = &groups;
 	string_list_t *chanlist, **chanlistapp;
-	char *arg, *p, **ntarg;
-	int err, len, cops, gcops, max_size;
+	char *arg, *p;
+	int err, len, cops, gcops, max_size, ms, i;
 	char path[_POSIX_PATH_MAX];
 	char buf[1024];
 
@@ -271,7 +270,7 @@ load_config( const char *where, int pseudo )
 		info( "Reading configuration file %s\n", cfile.file );
 
 	if (!(cfile.fp = fopen( cfile.file, "r" ))) {
-		perror( "Cannot open config file" );
+		sys_error( "Cannot open config file '%s'", cfile.file );
 		return 1;
 	}
 	buf[sizeof(buf) - 1] = 0;
@@ -284,18 +283,18 @@ load_config( const char *where, int pseudo )
 	while (getcline( &cfile )) {
 		if (!cfile.cmd)
 			continue;
-		if (imap_driver.parse_store( &cfile, &store, &err ) ||
-		    maildir_driver.parse_store( &cfile, &store, &err ))
-		{
-			if (store) {
-				if (!store->path)
-					store->path = "";
-				*storeapp = store;
-				storeapp = &store->next;
-				*storeapp = 0;
+		for (i = 0; i < N_DRIVERS; i++)
+			if (drivers[i]->parse_store( &cfile, &store, &err )) {
+				if (store) {
+					if (!store->path)
+						store->path = "";
+					*storeapp = store;
+					storeapp = &store->next;
+					*storeapp = 0;
+				}
+				goto reloop;
 			}
-		}
-		else if (!strcasecmp( "Channel", cfile.cmd ))
+		if (!strcasecmp( "Channel", cfile.cmd ))
 		{
 			channel = nfcalloc( sizeof(*channel) );
 			channel->name = nfstrdup( cfile.val );
@@ -315,49 +314,46 @@ load_config( const char *where, int pseudo )
 					while ((arg = next_arg( &cfile.rest )));
 				}
 				else if (!strcasecmp( "Master", cfile.cmd )) {
-					sptarg = &channel->master;
-					ntarg = &channel->master_name;
+					ms = M;
 					goto linkst;
 				} else if (!strcasecmp( "Slave", cfile.cmd )) {
-					sptarg = &channel->slave;
-					ntarg = &channel->slave_name;
+					ms = S;
 				  linkst:
 					if (*cfile.val != ':' || !(p = strchr( cfile.val + 1, ':' ))) {
-						fprintf( stderr, "%s:%d: malformed mailbox spec\n",
-						         cfile.file, cfile.line );
+						error( "%s:%d: malformed mailbox spec\n",
+						       cfile.file, cfile.line );
 						err = 1;
 						continue;
 					}
 					*p = 0;
 					for (store = stores; store; store = store->next)
 						if (!strcmp( store->name, cfile.val + 1 )) {
-							*sptarg = store;
+							channel->stores[ms] = store;
 							goto stpcom;
 						}
-					fprintf( stderr, "%s:%d: unknown store '%s'\n",
-					         cfile.file, cfile.line, cfile.val + 1 );
+					error( "%s:%d: unknown store '%s'\n",
+					       cfile.file, cfile.line, cfile.val + 1 );
 					err = 1;
 					continue;
 				  stpcom:
 					if (*++p)
-						*ntarg = nfstrdup( p );
-				} else if (!getopt_helper( &cfile, &cops, &channel->mops, &channel->sops, &channel->sync_state )) {
-					fprintf( stderr, "%s:%d: unknown keyword '%s'\n",
-					         cfile.file, cfile.line, cfile.cmd );
+						channel->boxes[ms] = nfstrdup( p );
+				} else if (!getopt_helper( &cfile, &cops, channel->ops, &channel->sync_state )) {
+					error( "%s:%d: unknown keyword '%s'\n", cfile.file, cfile.line, cfile.cmd );
 					err = 1;
 				}
 			}
-			if (!channel->master) {
-				fprintf( stderr, "channel '%s' refers to no master store\n", channel->name );
+			if (!channel->stores[M]) {
+				error( "channel '%s' refers to no master store\n", channel->name );
 				err = 1;
-			} else if (!channel->slave) {
-				fprintf( stderr, "channel '%s' refers to no slave store\n", channel->name );
+			} else if (!channel->stores[S]) {
+				error( "channel '%s' refers to no slave store\n", channel->name );
 				err = 1;
-			} else if (merge_ops( cops, &channel->mops, &channel->sops ))
+			} else if (merge_ops( cops, channel->ops ))
 				err = 1;
 			else {
 				if (max_size >= 0)
-					channel->master->max_size = channel->slave->max_size = max_size;
+					channel->stores[M]->max_size = channel->stores[S]->max_size = max_size;
 				*channelapp = channel;
 				channelapp = &channel->next;
 			}
@@ -393,17 +389,17 @@ load_config( const char *where, int pseudo )
 				}
 				else
 				{
-					fprintf( stderr, "%s:%d: unknown keyword '%s'\n",
-					         cfile.file, cfile.line, cfile.cmd );
+					error( "%s:%d: unknown keyword '%s'\n",
+					       cfile.file, cfile.line, cfile.cmd );
 					err = 1;
 				}
 			}
 			break;
 		}
-		else if (!getopt_helper( &cfile, &gcops, &global_mops, &global_sops, &global_sync_state ))
+		else if (!getopt_helper( &cfile, &gcops, global_ops, &global_sync_state ))
 		{
-			fprintf( stderr, "%s:%d: unknown section keyword '%s'\n",
-			         cfile.file, cfile.line, cfile.cmd );
+			error( "%s:%d: unknown section keyword '%s'\n",
+			       cfile.file, cfile.line, cfile.cmd );
 			err = 1;
 			while (getcline( &cfile ))
 				if (!cfile.cmd)
@@ -412,7 +408,7 @@ load_config( const char *where, int pseudo )
 		}
 	}
 	fclose (cfile.fp);
-	err |= merge_ops( gcops, &global_mops, &global_sops );
+	err |= merge_ops( gcops, global_ops );
 	if (!global_sync_state)
 		global_sync_state = expand_strdup( "~/." EXE "/" );
 	if (!err && pseudo)
@@ -434,8 +430,7 @@ parse_generic_store( store_conf_t *store, conffile_t *cfg, int *err )
 	else if (!strcasecmp( "MapInbox", cfg->cmd ))
 		store->map_inbox = nfstrdup( cfg->val );
 	else {
-		fprintf( stderr, "%s:%d: unknown keyword '%s'\n",
-		         cfg->file, cfg->line, cfg->cmd );
+		error( "%s:%d: unknown keyword '%s'\n", cfg->file, cfg->line, cfg->cmd );
 		*err = 1;
 	}
 }
diff --git src/drv_imap.c src/drv_imap.c
index 2a84f3d..fa58dfe 100644
--- src/drv_imap.c
+++ src/drv_imap.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2008,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
  * Copyright (C) 2004 Theodore Y. Ts'o <tytso@mit.edu>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -15,8 +15,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -26,45 +25,22 @@
 
 #include <assert.h>
 #include <unistd.h>
-#include <sys/mman.h>
-#include <sys/time.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <stddef.h>
 #include <limits.h>
-#include <errno.h>
 #include <string.h>
 #include <ctype.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#ifdef HAVE_SYS_FILIO_H
-# include <sys/filio.h>
-#endif
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#if HAVE_LIBSSL
-# include <openssl/ssl.h>
-# include <openssl/err.h>
-# include <openssl/hmac.h>
-#endif
 
 typedef struct imap_server_conf {
 	struct imap_server_conf *next;
 	char *name;
-	char *tunnel;
-	char *host;
-	int port;
+	server_conf_t sconf;
 	char *user;
 	char *pass;
-#if HAVE_LIBSSL
-	char *cert_file;
-	unsigned use_imaps:1;
+	int max_in_progress;
+#ifdef HAVE_LIBSSL
 	unsigned require_ssl:1;
-	unsigned use_sslv2:1;
-	unsigned use_sslv3:1;
-	unsigned use_tlsv1:1;
 	unsigned require_cram:1;
 #endif
 } imap_server_conf_t;
@@ -73,6 +49,7 @@ typedef struct imap_store_conf {
 	store_conf_t gen;
 	imap_server_conf_t *server;
 	unsigned use_namespace:1;
+	char delimiter;
 } imap_store_conf_t;
 
 typedef struct imap_message {
@@ -89,93 +66,121 @@ typedef struct _list {
 	int len;
 } list_t;
 
-typedef struct {
-	int fd;
-#if HAVE_LIBSSL
-	SSL *ssl;
-	unsigned int use_ssl:1;
-#endif
-} Socket_t;
+#define MAX_LIST_DEPTH 5
 
-typedef struct {
-	Socket_t sock;
-	int bytes;
-	int offset;
-	char buf[1024];
-} buffer_t;
+typedef struct parse_list_state {
+	list_t *head, **stack[MAX_LIST_DEPTH];
+	int level, need_bytes;
+} parse_list_state_t;
 
 struct imap_cmd;
-#define max_in_progress 50 /* make this configurable? */
 
-typedef struct imap {
-	int uidnext; /* from SELECT responses */
+typedef struct imap_store {
+	store_t gen;
+	const char *prefix;
+	/* trash folder's existence is not confirmed yet */
+	enum { TrashUnknown, TrashChecking, TrashKnown } trashnc;
+	unsigned got_namespace:1;
+	char delimiter; /* hierarchy delimiter */
 	list_t *ns_personal, *ns_other, *ns_shared; /* NAMESPACE info */
-	string_list_t *boxes; /* LIST results */
 	message_t **msgapp; /* FETCH results */
-	unsigned caps, rcaps; /* CAPABILITY results */
+	unsigned caps; /* CAPABILITY results */
+	parse_list_state_t parse_list_sts;
 	/* command queue */
-	int nexttag, num_in_progress, literal_pending;
+	int nexttag, num_in_progress;
+	struct imap_cmd *pending, **pending_append;
 	struct imap_cmd *in_progress, **in_progress_append;
-#if HAVE_LIBSSL
-	SSL_CTX *SSLContext;
-#endif
-	buffer_t buf; /* this is BIG, so put it last */
-} imap_t;
 
-typedef struct imap_store {
-	store_t gen;
-	imap_t *imap;
-	const char *prefix;
-	unsigned /*currentnc:1,*/ trashnc:1;
-} imap_store_t;
+	/* Used during sequential operations like connect */
+	enum { GreetingPending = 0, GreetingBad, GreetingOk, GreetingPreauth } greeting;
+	int canceling; /* imap_cancel() is in progress */
+	union {
+		int (*imap_open)( store_t *srv, void *aux );
+		void (*imap_cancel)( void *aux );
+	} callbacks;
+	void *callback_aux;
 
-struct imap_cmd_cb {
-	int (*cont)( imap_store_t *ctx, struct imap_cmd *cmd, const char *prompt );
-	void (*done)( imap_store_t *ctx, struct imap_cmd *cmd, int response);
-	void *ctx;
-	char *data;
-	int dlen;
-	int uid;
-	unsigned create:1, trycreate:1;
-};
+	conn_t conn; /* this is BIG, so put it last */
+} imap_store_t;
 
 struct imap_cmd {
 	struct imap_cmd *next;
-	struct imap_cmd_cb cb;
 	char *cmd;
 	int tag;
+
+	struct {
+		/* Will be called on each continuation request until it resets this pointer.
+		 * Needs to invoke bad_callback and return < 0 on error. */
+		int (*cont)( imap_store_t *ctx, struct imap_cmd *cmd, const char *prompt );
+		int (*done)( imap_store_t *ctx, struct imap_cmd *cmd, int response );
+		char *data;
+		int data_len;
+		int uid; /* to identify fetch responses */
+		unsigned
+			high_prio:1, /* if command is queued, put it at the front of the queue. */
+			to_trash:1, /* we are storing to trash, not current. */
+			create:1, /* create the mailbox if we get an error ... */
+			trycreate:1; /* ... but only if this is true or the server says so. */
+	} param;
+};
+
+struct imap_cmd_simple {
+	struct imap_cmd gen;
+	int (*callback)( int sts, void *aux );
+	void *callback_aux;
+};
+
+struct imap_cmd_fetch_msg {
+	struct imap_cmd_simple gen;
+	msg_data_t *msg_data;
+};
+
+struct imap_cmd_out_uid {
+	struct imap_cmd gen;
+	int (*callback)( int sts, int uid, void *aux );
+	void *callback_aux;
+	int out_uid;
+};
+
+struct imap_cmd_refcounted_state {
+	int (*callback)( int sts, void *aux );
+	void *callback_aux;
+	int ref_count;
+	int ret_val;
+};
+
+struct imap_cmd_refcounted {
+	struct imap_cmd gen;
+	struct imap_cmd_refcounted_state *state;
 };
 
-#define CAP(cap) (imap->caps & (1 << (cap)))
+#define CAP(cap) (ctx->caps & (1 << (cap)))
 
 enum CAPABILITY {
 	NOLOGIN = 0,
-	UIDPLUS,
-	LITERALPLUS,
-	NAMESPACE,
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 	CRAM,
 	STARTTLS,
 #endif
+	UIDPLUS,
+	LITERALPLUS,
+	NAMESPACE
 };
 
 static const char *cap_list[] = {
 	"LOGINDISABLED",
-	"UIDPLUS",
-	"LITERAL+",
-	"NAMESPACE",
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 	"AUTH=CRAM-MD5",
 	"STARTTLS",
 #endif
+	"UIDPLUS",
+	"LITERAL+",
+	"NAMESPACE"
 };
 
-#define RESP_OK    0
-#define RESP_NO    1
-#define RESP_BAD   2
-
-static int get_cmd_result( imap_store_t *ctx, struct imap_cmd *tcmd );
-
+#define RESP_OK       0
+#define RESP_NO       1
+#define RESP_CANCEL   2
 
 static const char *Flags[] = {
 	"Draft",
@@ -185,379 +190,262 @@ static const char *Flags[] = {
 	"Deleted",
 };
 
-#if HAVE_LIBSSL
-
-/* this gets called when a certificate is to be verified */
-static int
-verify_cert( SSL *ssl )
+static struct imap_cmd *
+new_imap_cmd( int size )
 {
-	X509 *cert;
-	int err;
-	char buf[256];
-	int ret = -1;
-	BIO *bio;
+	struct imap_cmd *cmd = nfmalloc( size );
+	memset( &cmd->param, 0, sizeof(cmd->param) );
+	return cmd;
+}
 
-	cert = SSL_get_peer_certificate( ssl );
-	if (!cert) {
-		fprintf( stderr, "Error, no server certificate\n" );
-		return -1;
-	}
+#define INIT_IMAP_CMD(type, cmdp, cb, aux) \
+	cmdp = (struct type *)new_imap_cmd( sizeof(*cmdp) ); \
+	cmdp->callback = cb; \
+	cmdp->callback_aux = aux;
 
-	err = SSL_get_verify_result( ssl );
-	if (err == X509_V_OK)
-		return 0;
+#define INIT_IMAP_CMD_X(type, cmdp, cb, aux) \
+	cmdp = (struct type *)new_imap_cmd( sizeof(*cmdp) ); \
+	cmdp->gen.callback = cb; \
+	cmdp->gen.callback_aux = aux;
 
-	fprintf( stderr, "Error, can't verify certificate: %s (%d)\n",
-	         X509_verify_cert_error_string(err), err );
-
-	X509_NAME_oneline( X509_get_subject_name( cert ), buf, sizeof(buf) );
-	info( "\nSubject: %s\n", buf );
-	X509_NAME_oneline( X509_get_issuer_name( cert ), buf, sizeof(buf) );
-	info( "Issuer:  %s\n", buf );
-	bio = BIO_new( BIO_s_mem() );
-	ASN1_TIME_print( bio, X509_get_notBefore( cert ) );
-	memset( buf, 0, sizeof(buf) );
-	BIO_read( bio, buf, sizeof(buf) - 1 );
-	info( "Valid from: %s\n", buf );
-	ASN1_TIME_print( bio, X509_get_notAfter( cert ) );
-	memset( buf, 0, sizeof(buf) );
-	BIO_read( bio, buf, sizeof(buf) - 1 );
-	BIO_free( bio );
-	info( "      to:   %s\n", buf );
-
-	fputs( "\n*** WARNING ***  There is no way to verify this certificate.  It is\n"
-	       "                 possible that a hostile attacker has replaced the\n"
-	       "                 server certificate.  Continue at your own risk!\n"
-	       "\nAccept this certificate anyway? [no]: ",  stderr );
-	if (fgets( buf, sizeof(buf), stdin ) && (buf[0] == 'y' || buf[0] == 'Y')) {
-		ret = 0;
-		fprintf( stderr, "\n*** Fine, but don't say I didn't warn you!\n\n" );
-	}
+static int
+done_imap_cmd( imap_store_t *ctx, struct imap_cmd *cmd, int response )
+{
+	int ret = cmd->param.done( ctx, cmd, response );
+	free( cmd->param.data );
+	free( cmd->cmd );
+	free( cmd );
 	return ret;
 }
 
 static int
-init_ssl_ctx( imap_store_t *ctx )
+send_imap_cmd( imap_store_t *ctx, struct imap_cmd *cmd )
 {
-	imap_t *imap = ctx->imap;
-	imap_store_conf_t *conf = (imap_store_conf_t *)ctx->gen.conf;
-	imap_server_conf_t *srvc = conf->server;
-	SSL_METHOD *method;
-	int options = 0;
-
-	if (srvc->use_tlsv1 && !srvc->use_sslv2 && !srvc->use_sslv3)
-		method = TLSv1_client_method();
-	else
-		method = SSLv23_client_method();
-	imap->SSLContext = SSL_CTX_new( method );
+	int bufl, litplus;
+	const char *buffmt;
+	char buf[1024];
 
-	if (!srvc->cert_file) {
-		fprintf( stderr, "Error, CertificateFile not defined\n" );
-		return -1;
-	} else if (!SSL_CTX_load_verify_locations( imap->SSLContext, srvc->cert_file, NULL )) {
-		fprintf( stderr, "Error while loading certificate file '%s': %s\n",
-		         srvc->cert_file, ERR_error_string( ERR_get_error(), 0 ) );
-		return -1;
+	cmd->tag = ++ctx->nexttag;
+	if (!cmd->param.data) {
+		buffmt = "%d %s\r\n";
+		litplus = 0;
+	} else if ((cmd->param.to_trash && ctx->trashnc == TrashUnknown) || !CAP(LITERALPLUS)) {
+		buffmt = "%d %s{%d}\r\n";
+		litplus = 0;
+	} else {
+		buffmt = "%d %s{%d+}\r\n";
+		litplus = 1;
 	}
-
-	if (!srvc->use_sslv2)
-		options |= SSL_OP_NO_SSLv2;
-	if (!srvc->use_sslv3)
-		options |= SSL_OP_NO_SSLv3;
-	if (!srvc->use_tlsv1)
-		options |= SSL_OP_NO_TLSv1;
-
-	SSL_CTX_set_options( imap->SSLContext, options );
-
-	/* we check the result of the verification after SSL_connect() */
-	SSL_CTX_set_verify( imap->SSLContext, SSL_VERIFY_NONE, 0 );
+	bufl = nfsnprintf( buf, sizeof(buf), buffmt,
+	                   cmd->tag, cmd->cmd, cmd->param.data_len );
+	if (DFlags & VERBOSE) {
+		if (ctx->num_in_progress)
+			printf( "(%d in progress) ", ctx->num_in_progress );
+		if (memcmp( cmd->cmd, "LOGIN", 5 ))
+			printf( ">>> %s", buf );
+		else
+			printf( ">>> %d LOGIN <user> <pass>\n", cmd->tag );
+	}
+	if (socket_write( &ctx->conn, buf, bufl, KeepOwn ) < 0)
+		goto bail;
+	if (litplus) {
+		char *p = cmd->param.data;
+		cmd->param.data = 0;
+		if (socket_write( &ctx->conn, p, cmd->param.data_len, GiveOwn ) < 0 ||
+		    socket_write( &ctx->conn, "\r\n", 2, KeepOwn ) < 0)
+			goto bail;
+	}
+	if (cmd->param.to_trash && ctx->trashnc == TrashUnknown)
+		ctx->trashnc = TrashChecking;
+	cmd->next = 0;
+	*ctx->in_progress_append = cmd;
+	ctx->in_progress_append = &cmd->next;
+	ctx->num_in_progress++;
 	return 0;
-}
-#endif /* HAVE_LIBSSL */
 
-static void
-socket_perror( const char *func, Socket_t *sock, int ret )
-{
-#if HAVE_LIBSSL
-	int err;
-
-	if (sock->use_ssl) {
-		switch ((err = SSL_get_error( sock->ssl, ret ))) {
-		case SSL_ERROR_SYSCALL:
-		case SSL_ERROR_SSL:
-			if ((err = ERR_get_error()) == 0) {
-				if (ret == 0)
-					fprintf( stderr, "SSL_%s:got EOF\n", func );
-				else
-					fprintf( stderr, "SSL_%s:%d:%s\n", func, errno, strerror(errno) );
-			} else
-				fprintf( stderr, "SSL_%s:%d:%s\n", func, err, ERR_error_string( err, 0 ) );
-			return;
-		default:
-			fprintf( stderr, "SSL_%s:%d:unhandled SSL error\n", func, err );
-			break;
-		}
-		return;
-	}
-#else
-	(void)sock;
-#endif
-	if (ret < 0)
-		perror( func );
-	else
-		fprintf( stderr, "%s: unexpected EOF\n", func );
+  bail:
+	done_imap_cmd( ctx, cmd, RESP_CANCEL );
+	return -1;
 }
 
 static int
-socket_read( Socket_t *sock, char *buf, int len )
+cmd_submittable( imap_store_t *ctx, struct imap_cmd *cmd )
 {
-	int n =
-#if HAVE_LIBSSL
-		sock->use_ssl ? SSL_read( sock->ssl, buf, len ) :
-#endif
-		read( sock->fd, buf, len );
-	if (n <= 0) {
-		socket_perror( "read", sock, n );
-		close( sock->fd );
-		sock->fd = -1;
-	}
-	return n;
-}
+	struct imap_cmd *cmdp;
 
-static int
-socket_write( Socket_t *sock, char *buf, int len )
-{
-	int n =
-#if HAVE_LIBSSL
-		sock->use_ssl ? SSL_write( sock->ssl, buf, len ) :
-#endif
-		write( sock->fd, buf, len );
-	if (n != len) {
-		socket_perror( "write", sock, n );
-		close( sock->fd );
-		sock->fd = -1;
-	}
-	return n;
+	return !ctx->conn.write_buf &&
+	       !(ctx->in_progress &&
+	         (cmdp = (struct imap_cmd *)((char *)ctx->in_progress_append -
+	                                     offsetof(struct imap_cmd, next)), 1) &&
+	         (cmdp->param.cont || cmdp->param.data)) &&
+	       !(cmd->param.to_trash && ctx->trashnc == TrashChecking) &&
+	       ctx->num_in_progress < ((imap_store_conf_t *)ctx->gen.conf)->server->max_in_progress;
 }
 
 static int
-socket_pending( Socket_t *sock )
+flush_imap_cmds( imap_store_t *ctx )
 {
-	int num = -1;
+	struct imap_cmd *cmd;
 
-	if (ioctl( sock->fd, FIONREAD, &num ) < 0)
-		return -1;
-	if (num > 0)
-		return num;
-#if HAVE_LIBSSL
-	if (sock->use_ssl)
-		return SSL_pending( sock->ssl );
-#endif
+	while ((cmd = ctx->pending) && cmd_submittable( ctx, cmd )) {
+		if (!(ctx->pending = cmd->next))
+			ctx->pending_append = &ctx->pending;
+		if (send_imap_cmd( ctx, cmd ) < 0)
+			return -1;
+	}
 	return 0;
 }
 
-/* simple line buffering */
-static int
-buffer_gets( buffer_t * b, char **s )
+static void
+cancel_pending_imap_cmds( imap_store_t *ctx )
 {
-	int n;
-	int start = b->offset;
-
-	*s = b->buf + start;
-
-	for (;;) {
-		/* make sure we have enough data to read the \r\n sequence */
-		if (b->offset + 1 >= b->bytes) {
-			if (start) {
-				/* shift down used bytes */
-				*s = b->buf;
-
-				assert( start <= b->bytes );
-				n = b->bytes - start;
-
-				if (n)
-					memmove( b->buf, b->buf + start, n );
-				b->offset -= start;
-				b->bytes = n;
-				start = 0;
-			}
-
-			n = socket_read( &b->sock, b->buf + b->bytes,
-			                 sizeof(b->buf) - b->bytes );
-
-			if (n <= 0)
-				return -1;
-
-			b->bytes += n;
-		}
-
-		if (b->buf[b->offset] == '\r') {
-			assert( b->offset + 1 < b->bytes );
-			if (b->buf[b->offset + 1] == '\n') {
-				b->buf[b->offset] = 0;  /* terminate the string */
-				b->offset += 2; /* next line */
-				if (Verbose)
-					puts( *s );
-				return 0;
-			}
-		}
+	struct imap_cmd *cmd;
 
-		b->offset++;
+	while ((cmd = ctx->pending)) {
+		if (!(ctx->pending = cmd->next))
+			ctx->pending_append = &ctx->pending;
+		done_imap_cmd( ctx, cmd, RESP_CANCEL );
 	}
-	/* not reached */
 }
 
-static struct imap_cmd *
-v_issue_imap_cmd( imap_store_t *ctx, struct imap_cmd_cb *cb,
-                  const char *fmt, va_list ap )
+static void
+cancel_submitted_imap_cmds( imap_store_t *ctx )
 {
-	imap_t *imap = ctx->imap;
 	struct imap_cmd *cmd;
-	int n, bufl;
-	char buf[1024];
 
-	cmd = nfmalloc( sizeof(struct imap_cmd) );
-	nfvasprintf( &cmd->cmd, fmt, ap );
-	cmd->tag = ++imap->nexttag;
-
-	if (cb)
-		cmd->cb = *cb;
-	else
-		memset( &cmd->cb, 0, sizeof(cmd->cb) );
-
-	while (imap->literal_pending)
-		get_cmd_result( ctx, 0 );
-
-	bufl = nfsnprintf( buf, sizeof(buf), cmd->cb.data ? CAP(LITERALPLUS) ?
-	                   "%d %s{%d+}\r\n" : "%d %s{%d}\r\n" : "%d %s\r\n",
-	                   cmd->tag, cmd->cmd, cmd->cb.dlen );
-	if (Verbose) {
-		if (imap->num_in_progress)
-			printf( "(%d in progress) ", imap->num_in_progress );
-		if (memcmp( cmd->cmd, "LOGIN", 5 ))
-			printf( ">>> %s", buf );
-		else
-			printf( ">>> %d LOGIN <user> <pass>\n", cmd->tag );
+	while ((cmd = ctx->in_progress)) {
+		ctx->in_progress = cmd->next;
+		/* don't update num_in_progress and in_progress_append - store is dead */
+		done_imap_cmd( ctx, cmd, RESP_CANCEL );
 	}
-	if (socket_write( &imap->buf.sock, buf, bufl ) != bufl) {
-		free( cmd->cmd );
-		free( cmd );
-		if (cb && cb->data)
-			free( cb->data );
-		return NULL;
-	}
-	if (cmd->cb.data) {
-		if (CAP(LITERALPLUS)) {
-			n = socket_write( &imap->buf.sock, cmd->cb.data, cmd->cb.dlen );
-			free( cmd->cb.data );
-			if (n != cmd->cb.dlen ||
-			    (n = socket_write( &imap->buf.sock, "\r\n", 2 )) != 2)
-			{
-				free( cmd->cmd );
-				free( cmd );
-				return NULL;
-			}
-			cmd->cb.data = 0;
-		} else
-			imap->literal_pending = 1;
-	} else if (cmd->cb.cont)
-		imap->literal_pending = 1;
-	cmd->next = 0;
-	*imap->in_progress_append = cmd;
-	imap->in_progress_append = &cmd->next;
-	imap->num_in_progress++;
-	return cmd;
 }
 
-static struct imap_cmd *
-issue_imap_cmd( imap_store_t *ctx, struct imap_cmd_cb *cb, const char *fmt, ... )
+static int
+submit_imap_cmd( imap_store_t *ctx, struct imap_cmd *cmd )
 {
-	struct imap_cmd *ret;
-	va_list ap;
+	assert( ctx );
+	assert( ctx->gen.bad_callback );
+	assert( cmd );
+	assert( cmd->param.done );
+
+	if ((ctx->pending && !cmd->param.high_prio) || !cmd_submittable( ctx, cmd )) {
+		if (ctx->pending && cmd->param.high_prio) {
+			cmd->next = ctx->pending;
+			ctx->pending = cmd;
+		} else {
+			cmd->next = 0;
+			*ctx->pending_append = cmd;
+			ctx->pending_append = &cmd->next;
+		}
+		return 0;
+	}
 
-	va_start( ap, fmt );
-	ret = v_issue_imap_cmd( ctx, cb, fmt, ap );
-	va_end( ap );
-	return ret;
+	return send_imap_cmd( ctx, cmd );
 }
 
-static struct imap_cmd *
-issue_imap_cmd_w( imap_store_t *ctx, struct imap_cmd_cb *cb, const char *fmt, ... )
+static int
+imap_exec( imap_store_t *ctx, struct imap_cmd *cmdp,
+           int (*done)( imap_store_t *ctx, struct imap_cmd *cmd, int response ),
+           const char *fmt, ... )
 {
-	imap_t *imap = ctx->imap;
-	struct imap_cmd *ret;
 	va_list ap;
 
+	if (!cmdp)
+		cmdp = new_imap_cmd( sizeof(*cmdp) );
+	cmdp->param.done = done;
 	va_start( ap, fmt );
-	ret = v_issue_imap_cmd( ctx, cb, fmt, ap );
+	nfvasprintf( &cmdp->cmd, fmt, ap );
 	va_end( ap );
-	while (imap->num_in_progress > max_in_progress ||
-	       socket_pending( &imap->buf.sock ))
-		get_cmd_result( ctx, 0 );
-	return ret;
+	return submit_imap_cmd( ctx, cmdp );
 }
 
-static int
-imap_exec( imap_store_t *ctx, struct imap_cmd_cb *cb, const char *fmt, ... )
+static void
+transform_box_response( int *response )
 {
-	va_list ap;
-	struct imap_cmd *cmdp;
-
-	va_start( ap, fmt );
-	cmdp = v_issue_imap_cmd( ctx, cb, fmt, ap );
-	va_end( ap );
-	if (!cmdp)
-		return RESP_BAD;
-
-	return get_cmd_result( ctx, cmdp );
+	switch (*response) {
+	case RESP_CANCEL: *response = DRV_CANCELED; break;
+	case RESP_NO: *response = DRV_BOX_BAD; break;
+	default: *response = DRV_OK; break;
+	}
 }
 
 static int
-imap_exec_b( imap_store_t *ctx, struct imap_cmd_cb *cb, const char *fmt, ... )
+imap_done_simple_box( imap_store_t *ctx ATTR_UNUSED,
+                      struct imap_cmd *cmd, int response )
 {
-	va_list ap;
-	struct imap_cmd *cmdp;
+	struct imap_cmd_simple *cmdp = (struct imap_cmd_simple *)cmd;
 
-	va_start( ap, fmt );
-	cmdp = v_issue_imap_cmd( ctx, cb, fmt, ap );
-	va_end( ap );
-	if (!cmdp)
-		return DRV_STORE_BAD;
+	transform_box_response( &response );
+	return cmdp->callback( response, cmdp->callback_aux );
+}
 
-	switch (get_cmd_result( ctx, cmdp )) {
-	case RESP_BAD: return DRV_STORE_BAD;
-	case RESP_NO: return DRV_BOX_BAD;
-	default: return DRV_OK;
+static void
+transform_msg_response( int *response )
+{
+	switch (*response) {
+	case RESP_CANCEL: *response = DRV_CANCELED; break;
+	case RESP_NO: *response = DRV_MSG_BAD; break;
+	default: *response = DRV_OK; break;
 	}
 }
 
 static int
-imap_exec_m( imap_store_t *ctx, struct imap_cmd_cb *cb, const char *fmt, ... )
+imap_done_simple_msg( imap_store_t *ctx ATTR_UNUSED,
+                      struct imap_cmd *cmd, int response )
 {
-	va_list ap;
-	struct imap_cmd *cmdp;
+	struct imap_cmd_simple *cmdp = (struct imap_cmd_simple *)cmd;
 
-	va_start( ap, fmt );
-	cmdp = v_issue_imap_cmd( ctx, cb, fmt, ap );
-	va_end( ap );
-	if (!cmdp)
-		return DRV_STORE_BAD;
+	transform_msg_response( &response );
+	return cmdp->callback( response, cmdp->callback_aux );
+}
+
+static struct imap_cmd_refcounted_state *
+imap_refcounted_new_state( int (*cb)( int, void * ), void *aux )
+{
+	struct imap_cmd_refcounted_state *sts = nfmalloc( sizeof(*sts) );
+	sts->callback = cb;
+	sts->callback_aux = aux;
+	sts->ref_count = 0;
+	sts->ret_val = DRV_OK;
+	return sts;
+}
+
+static struct imap_cmd *
+imap_refcounted_new_cmd( struct imap_cmd_refcounted_state *sts )
+{
+	struct imap_cmd_refcounted *cmd = (struct imap_cmd_refcounted *)new_imap_cmd( sizeof(*cmd) );
+	cmd->state = sts;
+	sts->ref_count++;
+	return &cmd->gen;
+}
 
-	switch (get_cmd_result( ctx, cmdp )) {
-	case RESP_BAD: return DRV_STORE_BAD;
-	case RESP_NO: return DRV_MSG_BAD;
-	default: return DRV_OK;
+static int
+imap_refcounted_done( struct imap_cmd_refcounted_state *sts )
+{
+	if (!--sts->ref_count) {
+		int ret = sts->callback( sts->ret_val, sts->callback_aux );
+		free( sts );
+		return ret;
 	}
+	return 0;
 }
 
-/*
-static void
-drain_imap_replies( imap_t *imap )
+static int
+imap_refcounted_done_box( imap_store_t *ctx ATTR_UNUSED, struct imap_cmd *cmd, int response )
 {
-	while (imap->num_in_progress)
-		get_cmd_result( imap, 0 );
+	struct imap_cmd_refcounted_state *sts = ((struct imap_cmd_refcounted *)cmd)->state;
+
+	switch (response) {
+	case RESP_CANCEL:
+		sts->ret_val = DRV_CANCELED;
+		break;
+	case RESP_NO:
+		if (sts->ret_val == DRV_OK) /* Don't override cancelation. */
+			sts->ret_val = DRV_BOX_BAD;
+		break;
+	}
+	return imap_refcounted_done( sts );
 }
-*/
 
 static int
 is_atom( list_t *list )
@@ -586,61 +474,76 @@ free_list( list_t *list )
 	}
 }
 
+enum {
+	LIST_OK,
+	LIST_PARTIAL,
+	LIST_BAD
+};
+
 static int
-parse_imap_list_l( imap_t *imap, char **sp, list_t **curp, int level )
+parse_imap_list( imap_store_t *ctx, char **sp, parse_list_state_t *sts )
 {
-	list_t *cur;
+	list_t *cur, **curp;
 	char *s = *sp, *p;
-	int n, bytes;
+	int bytes;
+
+	assert( sts );
+	assert( sts->level > 0 );
+	curp = sts->stack[--sts->level];
+	bytes = sts->need_bytes;
+	if (bytes >= 0) {
+		sts->need_bytes = -1;
+		if (!bytes)
+			goto getline;
+		cur = (list_t *)((char *)curp - offsetof(list_t, next));
+		s = cur->val + cur->len - bytes;
+		goto getbytes;
+	}
 
 	for (;;) {
 		while (isspace( (unsigned char)*s ))
 			s++;
-		if (level && *s == ')') {
+		if (sts->level && *s == ')') {
 			s++;
-			break;
+			curp = sts->stack[--sts->level];
+			goto next;
 		}
 		*curp = cur = nfmalloc( sizeof(*cur) );
-		curp = &cur->next;
 		cur->val = 0; /* for clean bail */
+		curp = &cur->next;
+		*curp = 0; /* ditto */
 		if (*s == '(') {
 			/* sublist */
+			if (sts->level == MAX_LIST_DEPTH)
+				goto bail;
 			s++;
 			cur->val = LIST;
-			if (parse_imap_list_l( imap, &s, &cur->child, level + 1 ))
-				goto bail;
-		} else if (imap && *s == '{') {
+			sts->stack[sts->level++] = curp;
+			curp = &cur->child;
+			*curp = 0; /* for clean bail */
+			goto next2;
+		} else if (ctx && *s == '{') {
 			/* literal */
 			bytes = cur->len = strtol( s + 1, &s, 10 );
-			if (*s != '}')
+			if (*s != '}' || *++s)
 				goto bail;
 
 			s = cur->val = nfmalloc( cur->len );
 
-			/* dump whats left over in the input buffer */
-			n = imap->buf.bytes - imap->buf.offset;
+		  getbytes:
+			bytes -= socket_read( &ctx->conn, s, bytes );
+			if (bytes > 0)
+				goto postpone;
 
-			if (n > bytes)
-				/* the entire message fit in the buffer */
-				n = bytes;
-
-			memcpy( s, imap->buf.buf + imap->buf.offset, n );
-			s += n;
-			bytes -= n;
-
-			/* mark that we used part of the buffer */
-			imap->buf.offset += n;
-
-			/* now read the rest of the message */
-			while (bytes > 0) {
-				if ((n = socket_read (&imap->buf.sock, s, bytes)) <= 0)
-					goto bail;
-				s += n;
-				bytes -= n;
+			if (DFlags & XVERBOSE) {
+				puts( "=========" );
+				fwrite( cur->val, cur->len, 1, stdout );
+				puts( "=========" );
 			}
 
-			if (buffer_gets( &imap->buf, &s ))
-				goto bail;
+		  getline:
+			if (!(s = socket_read_line( &ctx->conn )))
+				goto postpone;
 		} else if (*s == '"') {
 			/* quoted string */
 			s++;
@@ -657,7 +560,7 @@ parse_imap_list_l( imap_t *imap, char **sp, list_t **curp, int level )
 			/* atom */
 			p = s;
 			for (; *s && !isspace( (unsigned char)*s ); s++)
-				if (level && *s == ')')
+				if (sts->level && *s == ')')
 					break;
 			cur->len = s - p;
 			if (cur->len == 3 && !memcmp ("NIL", p, 3))
@@ -669,52 +572,59 @@ parse_imap_list_l( imap_t *imap, char **sp, list_t **curp, int level )
 			}
 		}
 
-		if (!level)
+	  next:
+		if (!sts->level)
 			break;
+	  next2:
 		if (!*s)
 			goto bail;
 	}
 	*sp = s;
-	*curp = 0;
-	return 0;
+	return LIST_OK;
 
+  postpone:
+	if (sts->level < MAX_LIST_DEPTH) {
+		sts->stack[sts->level++] = curp;
+		sts->need_bytes = bytes;
+		return LIST_PARTIAL;
+	}
   bail:
-	*curp = 0;
-	return -1;
+	free_list( sts->head );
+	return LIST_BAD;
 }
 
-static list_t *
-parse_imap_list( imap_t *imap, char **sp )
+static void
+parse_list_init( parse_list_state_t *sts )
 {
-	list_t *head;
-
-	if (!parse_imap_list_l( imap, sp, &head, 0 ))
-		return head;
-	free_list( head );
-	return NULL;
+	sts->need_bytes = -1;
+	sts->level = 1;
+	sts->head = 0;
+	sts->stack[0] = &sts->head;
 }
 
 static list_t *
 parse_list( char **sp )
 {
-	return parse_imap_list( 0, sp );
+	parse_list_state_t sts;
+	parse_list_init( &sts );
+	if (parse_imap_list( 0, sp, &sts ) == LIST_OK)
+		return sts.head;
+	return NULL;
 }
 
 static int
-parse_fetch( imap_t *imap, char *cmd ) /* move this down */
+parse_fetch( imap_store_t *ctx, list_t *list )
 {
-	list_t *tmp, *list, *flags;
-	char *body = 0;
+	list_t *tmp, *flags;
+	char *body = 0, *tuid = 0;
 	imap_message_t *cur;
 	msg_data_t *msgdata;
 	struct imap_cmd *cmdp;
 	int uid = 0, mask = 0, status = 0, size = 0;
 	unsigned i;
 
-	list = parse_imap_list( imap, &cmd );
-
 	if (!is_list( list )) {
-		fprintf( stderr, "IMAP error: bogus FETCH response\n" );
+		error( "IMAP error: bogus FETCH response\n" );
 		free_list( list );
 		return -1;
 	}
@@ -726,7 +636,7 @@ parse_fetch( imap_t *imap, char *cmd ) /* move this down */
 				if (is_atom( tmp ))
 					uid = atoi( tmp->val );
 				else
-					fprintf( stderr, "IMAP error: unable to parse UID\n" );
+					error( "IMAP error: unable to parse UID\n" );
 			} else if (!strcmp( "FLAGS", tmp->val )) {
 				tmp = tmp->next;
 				if (is_list( tmp )) {
@@ -742,21 +652,23 @@ parse_fetch( imap_t *imap, char *cmd ) /* move this down */
 										mask |= 1 << i;
 										goto flagok;
 									}
-								fprintf( stderr, "IMAP warning: unknown system flag %s\n", flags->val );
+								if (flags->val[1] == 'X' && flags->val[2] == '-')
+									goto flagok; /* ignore system flag extensions */
+								error( "IMAP warning: unknown system flag %s\n", flags->val );
 							}
 						  flagok: ;
 						} else
-							fprintf( stderr, "IMAP error: unable to parse FLAGS list\n" );
+							error( "IMAP error: unable to parse FLAGS list\n" );
 					}
 					status |= M_FLAGS;
 				} else
-					fprintf( stderr, "IMAP error: unable to parse FLAGS\n" );
+					error( "IMAP error: unable to parse FLAGS\n" );
 			} else if (!strcmp( "RFC822.SIZE", tmp->val )) {
 				tmp = tmp->next;
 				if (is_atom( tmp ))
 					size = atoi( tmp->val );
 				else
-					fprintf( stderr, "IMAP error: unable to parse SIZE\n" );
+					error( "IMAP error: unable to parse RFC822.SIZE\n" );
 			} else if (!strcmp( "BODY[]", tmp->val )) {
 				tmp = tmp->next;
 				if (is_atom( tmp )) {
@@ -764,35 +676,55 @@ parse_fetch( imap_t *imap, char *cmd ) /* move this down */
 					tmp->val = 0;       /* don't free together with list */
 					size = tmp->len;
 				} else
-					fprintf( stderr, "IMAP error: unable to parse BODY[]\n" );
+					error( "IMAP error: unable to parse BODY[]\n" );
+			} else if (!strcmp( "BODY[HEADER.FIELDS", tmp->val )) {
+				tmp = tmp->next;
+				if (is_list( tmp )) {
+					tmp = tmp->next;
+					if (!is_atom( tmp ) || strcmp( tmp->val, "]" ))
+						goto bfail;
+					tmp = tmp->next;
+					if (!is_atom( tmp ) || memcmp( tmp->val, "X-TUID: ", 8 ))
+						goto bfail;
+					tuid = tmp->val + 8;
+				} else {
+				  bfail:
+					error( "IMAP error: unable to parse BODY[HEADER.FIELDS ...]\n" );
+				}
 			}
 		}
 	}
 
 	if (body) {
-		for (cmdp = imap->in_progress; cmdp; cmdp = cmdp->next)
-			if (cmdp->cb.uid == uid)
+		for (cmdp = ctx->in_progress; cmdp; cmdp = cmdp->next)
+			if (cmdp->param.uid == uid)
 				goto gotuid;
-		fprintf( stderr, "IMAP error: unexpected FETCH response (UID %d)\n", uid );
+		error( "IMAP error: unexpected FETCH response (UID %d)\n", uid );
 		free_list( list );
 		return -1;
 	  gotuid:
-		msgdata = (msg_data_t *)cmdp->cb.ctx;
+		msgdata = ((struct imap_cmd_fetch_msg *)cmdp)->msg_data;
 		msgdata->data = body;
 		msgdata->len = size;
-		msgdata->crlf = 1;
 		if (status & M_FLAGS)
 			msgdata->flags = mask;
 	} else if (uid) { /* ignore async flag updates for now */
 		/* XXX this will need sorting for out-of-order (multiple queries) */
 		cur = nfcalloc( sizeof(*cur) );
-		*imap->msgapp = &cur->gen;
-		imap->msgapp = &cur->gen.next;
+		*ctx->msgapp = &cur->gen;
+		ctx->msgapp = &cur->gen.next;
 		cur->gen.next = 0;
 		cur->gen.uid = uid;
 		cur->gen.flags = mask;
 		cur->gen.status = status;
 		cur->gen.size = size;
+		cur->gen.srec = 0;
+		if (tuid)
+			strncpy( cur->gen.tuid, tuid, TUIDL );
+		else
+			cur->gen.tuid[0] = 0;
+		if (ctx->gen.uidnext <= uid) /* in case the server sends no UIDNEXT */
+			ctx->gen.uidnext = uid + 1;
 	}
 
 	free_list( list );
@@ -800,31 +732,29 @@ parse_fetch( imap_t *imap, char *cmd ) /* move this down */
 }
 
 static void
-parse_capability( imap_t *imap, char *cmd )
+parse_capability( imap_store_t *ctx, char *cmd )
 {
 	char *arg;
 	unsigned i;
 
-	imap->caps = 0x80000000;
+	ctx->caps = 0x80000000;
 	while ((arg = next_arg( &cmd )))
 		for (i = 0; i < as(cap_list); i++)
 			if (!strcmp( cap_list[i], arg ))
-				imap->caps |= 1 << i;
-	imap->rcaps = imap->caps;
+				ctx->caps |= 1 << i;
 }
 
 static int
-parse_response_code( imap_store_t *ctx, struct imap_cmd_cb *cb, char *s )
+parse_response_code( imap_store_t *ctx, struct imap_cmd *cmd, char *s )
 {
-	imap_t *imap = ctx->imap;
 	char *arg, *earg, *p;
 
 	if (*s != '[')
 		return RESP_OK;		/* no response code */
 	s++;
 	if (!(p = strchr( s, ']' ))) {
-		fprintf( stderr, "IMAP error: malformed response code\n" );
-		return RESP_BAD;
+		error( "IMAP error: malformed response code\n" );
+		return RESP_CANCEL;
 	}
 	*p++ = 0;
 	arg = next_arg( &s );
@@ -832,65 +762,60 @@ parse_response_code( imap_store_t *ctx, struct imap_cmd_cb *cb, char *s )
 		if (!(arg = next_arg( &s )) ||
 		    (ctx->gen.uidvalidity = strtoll( arg, &earg, 10 ), *earg))
 		{
-			fprintf( stderr, "IMAP error: malformed UIDVALIDITY status\n" );
-			return RESP_BAD;
+			error( "IMAP error: malformed UIDVALIDITY status\n" );
+			return RESP_CANCEL;
 		}
 	} else if (!strcmp( "UIDNEXT", arg )) {
-		if (!(arg = next_arg( &s )) || (imap->uidnext = strtol( arg, &p, 10 ), *p)) {
-			fprintf( stderr, "IMAP error: malformed NEXTUID status\n" );
-			return RESP_BAD;
+		if (!(arg = next_arg( &s )) || !(ctx->gen.uidnext = atoi( arg ))) {
+			error( "IMAP error: malformed NEXTUID status\n" );
+			return RESP_CANCEL;
 		}
 	} else if (!strcmp( "CAPABILITY", arg )) {
-		parse_capability( imap, s );
+		parse_capability( ctx, s );
 	} else if (!strcmp( "ALERT", arg )) {
 		/* RFC2060 says that these messages MUST be displayed
 		 * to the user
 		 */
 		for (; isspace( (unsigned char)*p ); p++);
-		fprintf( stderr, "*** IMAP ALERT *** %s\n", p );
-	} else if (cb && cb->ctx && !strcmp( "APPENDUID", arg )) {
+		error( "*** IMAP ALERT *** %s\n", p );
+	} else if (cmd && !strcmp( "APPENDUID", arg )) {
 		if (!(arg = next_arg( &s )) ||
 		    (ctx->gen.uidvalidity = strtoll( arg, &earg, 10 ), *earg) ||
-		    !(arg = next_arg( &s )) || !(*(int *)cb->ctx = atoi( arg )))
+		    !(arg = next_arg( &s )) ||
+		    !(((struct imap_cmd_out_uid *)cmd)->out_uid = atoi( arg )))
 		{
-			fprintf( stderr, "IMAP error: malformed APPENDUID status\n" );
-			return RESP_BAD;
+			error( "IMAP error: malformed APPENDUID status\n" );
+			return RESP_CANCEL;
 		}
 	}
 	return RESP_OK;
 }
 
-static void
-parse_search( imap_t *imap, char *cmd )
+static int
+map_name( char *arg, char in, char out )
 {
-	char *arg;
-	struct imap_cmd *cmdp;
-	int uid;
-
-	arg = next_arg( &cmd );
-	if (!arg)
-		return;
-	if (!(uid = atoi( arg ))) {
-		fprintf( stderr, "IMAP error: malformed SEARCH response\n" );
-		return;
-	}
+	int l, k;
 
-	/* Find the first command that expects a UID - this is guaranteed
-	 * to come in-order, as there are no other means to identify which
-	 * SEARCH response belongs to which request.
-	 */
-	for (cmdp = imap->in_progress; cmdp; cmdp = cmdp->next)
-		if (cmdp->cb.uid == -1) {
-			*(int *)cmdp->cb.ctx = uid;
-			return;
+	if (!in || in == out)
+		return 0;
+	for (l = 0; arg[l]; l++)
+		if (arg[l] == in) {
+			if (!out)
+				return -2;
+			arg[l] = out;
+		} else if (arg[l] == out) {
+			/* restore original name for printing error message */
+			for (k = 0; k < l; k++)
+				if (arg[k] == out)
+					arg[k] = in;
+			return -1;
 		}
-	fprintf( stderr, "IMAP error: unexpected SEARCH response (UID %u)\n", uid );
+	return 0;
 }
 
 static void
 parse_list_rsp( imap_store_t *ctx, char *cmd )
 {
-	imap_t *imap = ctx->imap;
 	char *arg;
 	list_t *list, *lp;
 	int l;
@@ -903,550 +828,693 @@ parse_list_rsp( imap_store_t *ctx, char *cmd )
 				return;
 			}
 	free_list( list );
-	(void) next_arg( &cmd ); /* skip delimiter */
 	arg = next_arg( &cmd );
-	l = strlen( ctx->gen.conf->path );
-	if (memcmp( arg, ctx->gen.conf->path, l ))
-		return;
-	arg += l;
+	if (!ctx->delimiter)
+		ctx->delimiter = *arg;
+	arg = next_arg( &cmd );
+	if (memcmp( arg, "INBOX", 5 ) || (arg[5] && arg[5] != ctx->delimiter)) {
+		l = strlen( ctx->gen.conf->path );
+		if (memcmp( arg, ctx->gen.conf->path, l ))
+			return;
+		arg += l;
+		if (!memcmp( arg, "INBOX", 5 ) && (!arg[5] || arg[5] == ctx->delimiter)) {
+			if (!arg[5])
+				warn( "IMAP warning: ignoring INBOX in %s\n", ctx->gen.conf->path );
+			return;
+		}
+	}
 	if (!memcmp( arg + strlen( arg ) - 5, ".lock", 5 )) /* workaround broken servers */
 		return;
-	add_string_list( &imap->boxes, arg );
+	if (map_name( arg, ctx->delimiter, '/') < 0) {
+		warn( "IMAP warning: in %s: ignoring mailbox %s (reserved character '/' in name)\n",
+		      ctx->gen.conf->path, arg );
+		return;
+	}
+	add_string_list( &ctx->gen.boxes, arg );
 }
 
 static int
-get_cmd_result( imap_store_t *ctx, struct imap_cmd *tcmd )
+prepare_box( char *buf, const imap_store_t *ctx )
+{
+	const char *name = ctx->gen.name;
+	int pl;
+
+	nfsnprintf( buf, 1024, "%s%n%s",
+	            (!memcmp( name, "INBOX", 5 ) && (!name[5] || name[5] == '/')) ?
+	                "" : ctx->prefix, &pl, name );
+	switch (map_name( buf + pl, '/', ctx->delimiter )) {
+	case -1:
+		error( "IMAP error: mailbox name %s contains server's hierarchy delimiter\n", buf + pl );
+		return -1;
+	case -2:
+		error( "IMAP error: server's hierarchy delimiter not known\n" );
+		return -1;
+	default:
+		return 0;
+	}
+}
+
+struct imap_cmd_trycreate {
+	struct imap_cmd gen;
+	struct imap_cmd *orig_cmd;
+};
+
+static int imap_open_store_greeted( imap_store_t * );
+static int get_cmd_result_p2( imap_store_t *, struct imap_cmd *, int );
+
+static void
+imap_socket_read( void *aux )
 {
-	imap_t *imap = ctx->imap;
-	struct imap_cmd *cmdp, **pcmdp, *ncmdp;
+	imap_store_t *ctx = (imap_store_t *)aux;
+	struct imap_cmd *cmdp, **pcmdp;
 	char *cmd, *arg, *arg1, *p;
-	int n, resp, resp2, tag;
+	int resp, resp2, tag, greeted;
 
+	greeted = ctx->greeting;
+	if (ctx->parse_list_sts.level) {
+		cmd = 0;
+		goto do_fetch;
+	}
 	for (;;) {
-		if (buffer_gets( &imap->buf, &cmd ))
-			return RESP_BAD;
+		if (!(cmd = socket_read_line( &ctx->conn )))
+			return;
 
 		arg = next_arg( &cmd );
 		if (*arg == '*') {
 			arg = next_arg( &cmd );
 			if (!arg) {
-				fprintf( stderr, "IMAP error: unable to parse untagged response\n" );
-				return RESP_BAD;
+				error( "IMAP error: malformed untagged response\n" );
+				break;
 			}
 
 			if (!strcmp( "NAMESPACE", arg )) {
-				imap->ns_personal = parse_list( &cmd );
-				imap->ns_other = parse_list( &cmd );
-				imap->ns_shared = parse_list( &cmd );
-			} else if (!strcmp( "OK", arg ) || !strcmp( "BAD", arg ) ||
-			           !strcmp( "NO", arg ) || !strcmp( "BYE", arg )) {
-				if ((resp = parse_response_code( ctx, 0, cmd )) != RESP_OK)
-					return resp;
+				ctx->ns_personal = parse_list( &cmd );
+				ctx->ns_other = parse_list( &cmd );
+				ctx->ns_shared = parse_list( &cmd );
+			} else if (ctx->greeting == GreetingPending && !strcmp( "PREAUTH", arg )) {
+				ctx->greeting = GreetingPreauth;
+				parse_response_code( ctx, 0, cmd );
+			} else if (!strcmp( "OK", arg )) {
+				ctx->greeting = GreetingOk;
+				parse_response_code( ctx, 0, cmd );
+			} else if (!strcmp( "BAD", arg ) || !strcmp( "NO", arg ) || !strcmp( "BYE", arg )) {
+				ctx->greeting = GreetingBad;
+				parse_response_code( ctx, 0, cmd );
 			} else if (!strcmp( "CAPABILITY", arg ))
-				parse_capability( imap, cmd );
+				parse_capability( ctx, cmd );
 			else if (!strcmp( "LIST", arg ))
 				parse_list_rsp( ctx, cmd );
-			else if (!strcmp( "SEARCH", arg ))
-				parse_search( imap, cmd );
 			else if ((arg1 = next_arg( &cmd ))) {
 				if (!strcmp( "EXISTS", arg1 ))
 					ctx->gen.count = atoi( arg );
 				else if (!strcmp( "RECENT", arg1 ))
 					ctx->gen.recent = atoi( arg );
 				else if(!strcmp ( "FETCH", arg1 )) {
-					if (parse_fetch( imap, cmd ))
-						return RESP_BAD;
+					parse_list_init( &ctx->parse_list_sts );
+				  do_fetch:
+					if ((resp = parse_imap_list( ctx, &cmd, &ctx->parse_list_sts )) == LIST_BAD)
+						break; /* stream is likely to be useless now */
+					if (resp == LIST_PARTIAL)
+						return;
+					if (parse_fetch( ctx, ctx->parse_list_sts.head ) < 0)
+						break; /* this may mean anything, so prefer not to spam the log */
 				}
 			} else {
-				fprintf( stderr, "IMAP error: unable to parse untagged response\n" );
-				return RESP_BAD;
+				error( "IMAP error: unrecognized untagged response '%s'\n", arg );
+				break; /* this may mean anything, so prefer not to spam the log */
 			}
-		} else if (!imap->in_progress) {
-			fprintf( stderr, "IMAP error: unexpected reply: %s %s\n", arg, cmd ? cmd : "" );
-			return RESP_BAD;
+			if (greeted == GreetingPending)
+				if (imap_open_store_greeted( ctx ) < 0)
+					return;
+			continue;
+		} else if (!ctx->in_progress) {
+			error( "IMAP error: unexpected reply: %s %s\n", arg, cmd ? cmd : "" );
+			break; /* this may mean anything, so prefer not to spam the log */
 		} else if (*arg == '+') {
 			/* This can happen only with the last command underway, as
 			   it enforces a round-trip. */
-			cmdp = (struct imap_cmd *)((char *)imap->in_progress_append -
-			       offsetof(struct imap_cmd, next));
-			if (cmdp->cb.data) {
-				n = socket_write( &imap->buf.sock, cmdp->cb.data, cmdp->cb.dlen );
-				free( cmdp->cb.data );
-				cmdp->cb.data = 0;
-				if (n != (int)cmdp->cb.dlen)
-					return RESP_BAD;
-			} else if (cmdp->cb.cont) {
-				if (cmdp->cb.cont( ctx, cmdp, cmd ))
-					return RESP_BAD;
+			cmdp = ctx->in_progress;
+			if (cmdp->param.data) {
+				if (cmdp->param.to_trash)
+					ctx->trashnc = TrashKnown; /* Can't get NO [TRYCREATE] any more. */
+				p = cmdp->param.data;
+				cmdp->param.data = 0;
+				if (socket_write( &ctx->conn, p, cmdp->param.data_len, GiveOwn ) < 0)
+					return;
+			} else if (cmdp->param.cont) {
+				if (cmdp->param.cont( ctx, cmdp, cmd ) < 0)
+					return;
 			} else {
-				fprintf( stderr, "IMAP error: unexpected command continuation request\n" );
-				return RESP_BAD;
+				error( "IMAP error: unexpected command continuation request\n" );
+				break;
 			}
-			if (socket_write( &imap->buf.sock, "\r\n", 2 ) != 2)
-				return RESP_BAD;
-			if (!cmdp->cb.cont)
-				imap->literal_pending = 0;
-			if (!tcmd)
-				return DRV_OK;
+			if (socket_write( &ctx->conn, "\r\n", 2, KeepOwn ) < 0)
+				return;
 		} else {
 			tag = atoi( arg );
-			for (pcmdp = &imap->in_progress; (cmdp = *pcmdp); pcmdp = &cmdp->next)
+			for (pcmdp = &ctx->in_progress; (cmdp = *pcmdp); pcmdp = &cmdp->next)
 				if (cmdp->tag == tag)
 					goto gottag;
-			fprintf( stderr, "IMAP error: unexpected tag %s\n", arg );
-			return RESP_BAD;
+			error( "IMAP error: unexpected tag %s\n", arg );
+			break;
 		  gottag:
 			if (!(*pcmdp = cmdp->next))
-				imap->in_progress_append = pcmdp;
-			imap->num_in_progress--;
-			if (cmdp->cb.cont || cmdp->cb.data)
-				imap->literal_pending = 0;
+				ctx->in_progress_append = pcmdp;
+			ctx->num_in_progress--;
 			arg = next_arg( &cmd );
-			if (!strcmp( "OK", arg ))
-				resp = DRV_OK;
-			else {
+			if (!strcmp( "OK", arg )) {
+				if (cmdp->param.to_trash)
+					ctx->trashnc = TrashKnown; /* Can't get NO [TRYCREATE] any more. */
+				resp = RESP_OK;
+			} else {
 				if (!strcmp( "NO", arg )) {
-					if (cmdp->cb.create && cmd && (cmdp->cb.trycreate || !memcmp( cmd, "[TRYCREATE]", 11 ))) { /* SELECT, APPEND or UID COPY */
+					if (cmdp->param.create &&
+					    (cmdp->param.trycreate ||
+					     (cmd && !memcmp( cmd, "[TRYCREATE]", 11 ))))
+					{ /* SELECT, APPEND or UID COPY */
+						struct imap_cmd_trycreate *cmd2 =
+							(struct imap_cmd_trycreate *)new_imap_cmd( sizeof(*cmd2) );
+						cmd2->orig_cmd = cmdp;
+						cmd2->gen.param.high_prio = 1;
 						p = strchr( cmdp->cmd, '"' );
-						if (!issue_imap_cmd( ctx, 0, "CREATE %.*s", strchr( p + 1, '"' ) - p + 1, p )) {
-							resp = RESP_BAD;
-							goto normal;
-						}
-						/* not waiting here violates the spec, but a server that does not
-						   grok this nonetheless violates it too. */
-						cmdp->cb.create = 0;
-						if (!(ncmdp = issue_imap_cmd( ctx, &cmdp->cb, "%s", cmdp->cmd ))) {
-							resp = RESP_BAD;
-							goto normal;
-						}
-						free( cmdp->cmd );
-						free( cmdp );
-						if (!tcmd)
-							return 0;	/* ignored */
-						if (cmdp == tcmd)
-							tcmd = ncmdp;
+						if (imap_exec( ctx, &cmd2->gen, get_cmd_result_p2,
+						               "CREATE %.*s", strchr( p + 1, '"' ) - p + 1, p ) < 0)
+							return;
 						continue;
 					}
 					resp = RESP_NO;
 				} else /*if (!strcmp( "BAD", arg ))*/
-					resp = RESP_BAD;
-				fprintf( stderr, "IMAP command '%s' returned an error: %s %s\n",
-				         memcmp (cmdp->cmd, "LOGIN", 5) ?
-				         		cmdp->cmd : "LOGIN <user> <pass>",
-				         		arg, cmd ? cmd : "");
+					resp = RESP_CANCEL;
+				error( "IMAP command '%s' returned an error: %s %s\n",
+				       memcmp( cmdp->cmd, "LOGIN", 5 ) ? cmdp->cmd : "LOGIN <user> <pass>",
+				       arg, cmd ? cmd : "" );
 			}
-			if ((resp2 = parse_response_code( ctx, &cmdp->cb, cmd )) > resp)
+			if ((resp2 = parse_response_code( ctx, cmdp, cmd )) > resp)
 				resp = resp2;
-		  normal:
-			if (cmdp->cb.done)
-				cmdp->cb.done( ctx, cmdp, resp );
-			if (cmdp->cb.data)
-				free( cmdp->cb.data );
-			free( cmdp->cmd );
-			free( cmdp );
-			if (!tcmd || tcmd == cmdp)
-				return resp;
+			if (resp == RESP_CANCEL)
+				ctx->gen.bad_callback( ctx->gen.bad_callback_aux );
+			if (done_imap_cmd( ctx, cmdp, resp ) < 0)
+				return;
+			if (resp == RESP_CANCEL)
+				return;
+			if (ctx->canceling && !ctx->in_progress) {
+				ctx->canceling = 0;
+				ctx->callbacks.imap_cancel( ctx->callback_aux );
+				return;
+			}
 		}
+		if (flush_imap_cmds( ctx ) < 0)
+			return;
 	}
-	/* not reached */
+	ctx->gen.bad_callback( ctx->gen.bad_callback_aux );
 }
 
-static void
-imap_close_server( imap_store_t *ictx )
+static int
+get_cmd_result_p2( imap_store_t *ctx, struct imap_cmd *cmd, int response )
 {
-	imap_t *imap = ictx->imap;
+	struct imap_cmd_trycreate *cmdp = (struct imap_cmd_trycreate *)cmd;
+	struct imap_cmd *ocmd = cmdp->orig_cmd;
 
-	if (imap->buf.sock.fd != -1) {
-		imap_exec( ictx, 0, "LOGOUT" );
-		close( imap->buf.sock.fd );
+	if (response != RESP_OK) {
+		return done_imap_cmd( ctx, ocmd, response );
+	} else {
+		ctx->gen.uidnext = 1;
+		if (ocmd->param.to_trash)
+			ctx->trashnc = TrashKnown;
+		ocmd->param.create = 0;
+		ocmd->param.high_prio = 1;
+		return submit_imap_cmd( ctx, ocmd );
 	}
-#ifdef HAVE_LIBSSL
-	if (imap->SSLContext)
-		SSL_CTX_free( imap->SSLContext );
-#endif
-	free_list( imap->ns_personal );
-	free_list( imap->ns_other );
-	free_list( imap->ns_shared );
-	free( imap );
 }
 
 static void
-imap_close_store( store_t *ctx )
+imap_socket_fail( void *aux )
 {
-	imap_close_server( (imap_store_t *)ctx );
-	free_generic_messages( ctx->msgs );
-	free( ctx );
-}
-
-#ifdef HAVE_LIBSSL
-static int
-start_tls( imap_store_t *ctx )
-{
-	imap_t *imap = ctx->imap;
-	int ret;
-	static int ssl_inited;
+	imap_store_t *ctx = (imap_store_t *)aux;
 
-	if (!ssl_inited) {
-		SSL_library_init();
-		SSL_load_error_strings();
-		ssl_inited = 1;
-	}
+	socket_close( &ctx->conn );
+	ctx->gen.bad_callback( ctx->gen.bad_callback_aux );
+}
 
-        if (init_ssl_ctx( ctx ))
-		return 1;
+/******************* imap_cancel_store *******************/
 
-	imap->buf.sock.ssl = SSL_new( imap->SSLContext );
-	SSL_set_fd( imap->buf.sock.ssl, imap->buf.sock.fd );
-	if ((ret = SSL_connect( imap->buf.sock.ssl )) <= 0) {
-		socket_perror( "connect", &imap->buf.sock, ret );
-		return 1;
-	}
-
-	/* verify the server certificate */
-	if (verify_cert( imap->buf.sock.ssl ))
-		return 1;
+static void
+imap_cancel_store( store_t *gctx )
+{
+	imap_store_t *ctx = (imap_store_t *)gctx;
 
-	imap->buf.sock.use_ssl = 1;
-	info( "Connection is now encrypted\n" );
-	return 0;
+	socket_close( &ctx->conn );
+	cancel_submitted_imap_cmds( ctx );
+	cancel_pending_imap_cmds( ctx );
+	free_generic_messages( gctx->msgs );
+	free_string_list( ctx->gen.boxes );
+	free_list( ctx->ns_personal );
+	free_list( ctx->ns_other );
+	free_list( ctx->ns_shared );
+	free( ctx );
 }
 
-#define ENCODED_SIZE(n) (4*((n+2)/3))
+/******************* imap_disown_store & imap_own_store *******************/
 
-static char
-hexchar( unsigned int b )
+static store_t *unowned;
+
+static void
+imap_disown_store( store_t *gctx )
 {
-	if (b < 10)
-		return '0' + b;
-	return 'a' + (b - 10);
+	free_generic_messages( gctx->msgs );
+	gctx->msgs = 0;
+	gctx->next = unowned;
+	unowned = gctx;
 }
 
-/* XXX merge into do_cram_auth? */
-static char *
-cram( const char *challenge, const char *user, const char *pass )
+static store_t *
+imap_own_store( store_conf_t *conf )
 {
-	HMAC_CTX hmac;
-	char hash[16];
-	char hex[33];
-	int i;
-	unsigned int hashlen = sizeof(hash);
-	char buf[256];
-	int len = strlen( challenge );
-	char *response = nfcalloc( 1 + len );
-	char *final;
+	store_t *store, **storep;
 
-	/* response will always be smaller than challenge because we are
-	 * decoding.
-	 */
-	len = EVP_DecodeBlock( (unsigned char *)response, (unsigned char *)challenge, strlen( challenge ) );
+	for (storep = &unowned; (store = *storep); storep = &store->next)
+		if (store->conf == conf) {
+			*storep = store->next;
+			return store;
+		}
+	return 0;
+}
 
-	HMAC_Init( &hmac, (unsigned char *) pass, strlen( pass ), EVP_md5() );
-	HMAC_Update( &hmac, (unsigned char *)response, strlen( response ) );
-	HMAC_Final( &hmac, (unsigned char *)hash, &hashlen );
+/******************* imap_cleanup *******************/
 
-	assert( hashlen == sizeof(hash) );
+static int imap_cleanup_p2( imap_store_t *, struct imap_cmd *, int );
 
-	free( response );
+static void
+imap_cleanup( void )
+{
+	store_t *ctx, *nctx;
 
-	hex[32] = 0;
-	for (i = 0; i < 16; i++) {
-		hex[2 * i] = hexchar( (hash[i] >> 4) & 0xf );
-		hex[2 * i + 1] = hexchar( hash[i] & 0xf );
+	for (ctx = unowned; ctx; ctx = nctx) {
+		nctx = ctx->next;
+		set_bad_callback( ctx, (void (*)(void *))imap_cancel_store, ctx );
+		imap_exec( (imap_store_t *)ctx, 0, imap_cleanup_p2, "LOGOUT" );
 	}
+}
 
-	nfsnprintf( buf, sizeof(buf), "%s %s", user, hex );
-
-	len = strlen( buf );
-	len = ENCODED_SIZE( len ) + 1;
-	final = nfmalloc( len );
-	final[len - 1] = 0;
-
-	assert( EVP_EncodeBlock( (unsigned char *)final, (unsigned char *)buf, strlen( buf ) ) == len - 1 );
-
-	return final;
+static int
+imap_cleanup_p2( imap_store_t *ctx,
+                 struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_CANCEL)
+		imap_cancel_store( &ctx->gen );
+	return -1;
 }
 
+/******************* imap_open_store *******************/
+
+#ifdef HAVE_LIBSSL
 static int
-do_cram_auth (imap_store_t *ctx, struct imap_cmd *cmdp, const char *prompt)
+do_cram_auth( imap_store_t *ctx, struct imap_cmd *cmdp, const char *prompt )
 {
-	imap_t *imap = ctx->imap;
 	imap_server_conf_t *srvc = ((imap_store_conf_t *)ctx->gen.conf)->server;
 	char *resp;
-	int n, l;
+	int l;
 
-	resp = cram( prompt, srvc->user, srvc->pass );
+	cmdp->param.cont = 0;
 
-	if (Verbose)
+	cram( prompt, srvc->user, srvc->pass, &resp, &l );
+
+	if (DFlags & VERBOSE)
 		printf( ">+> %s\n", resp );
-	l = strlen( resp );
-	n = socket_write( &imap->buf.sock, resp, l );
-	free( resp );
-	if (n != l)
-		return -1;
-	cmdp->cb.cont = 0;
-	return 0;
+	return socket_write( &ctx->conn, resp, l, GiveOwn );
 }
 #endif
 
-static store_t *
-imap_open_store( store_conf_t *conf, store_t *oldctx )
+static void imap_open_store_connected( int, void * );
+#ifdef HAVE_LIBSSL
+static int imap_open_store_tlsstarted1( int, void * );
+#endif
+static int imap_open_store_p2( imap_store_t *, struct imap_cmd *, int );
+static int imap_open_store_authenticate( imap_store_t * );
+#ifdef HAVE_LIBSSL
+static int imap_open_store_authenticate_p2( imap_store_t *, struct imap_cmd *, int );
+static int imap_open_store_tlsstarted2( int, void * );
+static int imap_open_store_authenticate_p3( imap_store_t *, struct imap_cmd *, int );
+#endif
+static int imap_open_store_authenticate2( imap_store_t * );
+static int imap_open_store_authenticate2_p2( imap_store_t *, struct imap_cmd *, int );
+static int imap_open_store_namespace( imap_store_t * );
+static int imap_open_store_namespace_p2( imap_store_t *, struct imap_cmd *, int );
+static int imap_open_store_namespace2( imap_store_t * );
+static int imap_open_store_finalize( imap_store_t * );
+#ifdef HAVE_LIBSSL
+static int imap_open_store_ssl_bail( imap_store_t * );
+#endif
+static int imap_open_store_bail( imap_store_t * );
+
+static void
+imap_open_store( store_conf_t *conf,
+                 int (*cb)( store_t *srv, void *aux ), void *aux )
 {
 	imap_store_conf_t *cfg = (imap_store_conf_t *)conf;
 	imap_server_conf_t *srvc = cfg->server;
-	imap_store_t *ctx = (imap_store_t *)oldctx;
-	imap_t *imap;
-	char *arg, *rsp;
-	struct hostent *he;
-	struct sockaddr_in addr;
-	int s, a[2], preauth;
-#if HAVE_LIBSSL
-	int use_ssl;
-#endif
-
-	if (ctx) {
-		if (((imap_store_conf_t *)(ctx->gen.conf))->server == cfg->server) {
-			 ctx->gen.conf = conf;
-			 imap = ctx->imap;
-			 goto final;
+	imap_store_t *ctx;
+	store_t **ctxp;
+
+	for (ctxp = &unowned; (ctx = (imap_store_t *)*ctxp); ctxp = &ctx->gen.next)
+		if (((imap_store_conf_t *)ctx->gen.conf)->server == srvc) {
+			*ctxp = ctx->gen.next;
+			/* One could ping the server here, but given that the idle timeout
+			 * is at least 30 minutes, this sounds pretty pointless. */
+			free_string_list( ctx->gen.boxes );
+			ctx->gen.boxes = 0;
+			ctx->gen.listed = 0;
+			ctx->gen.conf = conf;
+			ctx->delimiter = 0;
+			ctx->callbacks.imap_open = cb;
+			ctx->callback_aux = aux;
+			set_bad_callback( &ctx->gen, (void (*)(void *))imap_open_store_bail, ctx );
+			imap_open_store_namespace( ctx );
+			return;
 		}
-		imap_close_server( ctx );
-	} else
-		ctx = nfcalloc( sizeof(*ctx) );
 
+	ctx = nfcalloc( sizeof(*ctx) );
 	ctx->gen.conf = conf;
-	ctx->imap = imap = nfcalloc( sizeof(*imap) );
-	imap->buf.sock.fd = -1;
-	imap->in_progress_append = &imap->in_progress;
+	ctx->callbacks.imap_open = cb;
+	ctx->callback_aux = aux;
+	set_bad_callback( &ctx->gen, (void (*)(void *))imap_open_store_bail, ctx );
+	ctx->in_progress_append = &ctx->in_progress;
+	ctx->pending_append = &ctx->pending;
+
+	socket_init( &ctx->conn, &srvc->sconf,
+	             imap_socket_fail, imap_socket_read, (int (*)(void *))flush_imap_cmds, ctx );
+	socket_connect( &ctx->conn, imap_open_store_connected );
+}
 
-	/* open connection to IMAP server */
-#if HAVE_LIBSSL
-	use_ssl = 0;
+static void
+imap_open_store_connected( int ok, void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)aux;
+#ifdef HAVE_LIBSSL
+	imap_store_conf_t *cfg = (imap_store_conf_t *)ctx->gen.conf;
+	imap_server_conf_t *srvc = cfg->server;
 #endif
 
-	if (srvc->tunnel) {
-		info( "Starting tunnel '%s'... ", srvc->tunnel );
-
-		if (socketpair( PF_UNIX, SOCK_STREAM, 0, a )) {
-			perror( "socketpair" );
-			exit( 1 );
-		}
-
-		if (fork() == 0) {
-			if (dup2( a[0], 0 ) == -1 || dup2( a[0], 1 ) == -1)
-				_exit( 127 );
-			close( a[0] );
-			close( a[1] );
-			execl( "/bin/sh", "sh", "-c", srvc->tunnel, (char *)0 );
-			_exit( 127 );
-		}
-
-		close (a[0]);
-
-		imap->buf.sock.fd = a[1];
+	if (!ok) {
+		imap_open_store_bail( ctx );
+		return;
+	}
 
-		info( "ok\n" );
-	} else {
-		memset( &addr, 0, sizeof(addr) );
-		addr.sin_port = srvc->port ? htons( srvc->port ) :
 #ifdef HAVE_LIBSSL
-		                srvc->use_imaps ? htons( 993 ) :
+	if (srvc->sconf.use_imaps)
+		socket_start_tls( &ctx->conn, imap_open_store_tlsstarted1 );
 #endif
-		                htons( 143 );
-		addr.sin_family = AF_INET;
-
-		info( "Resolving %s... ", srvc->host );
-		he = gethostbyname( srvc->host );
-		if (!he) {
-			perror( "gethostbyname" );
-			goto bail;
-		}
-		info( "ok\n" );
+}
 
-		addr.sin_addr.s_addr = *((int *) he->h_addr_list[0]);
+#ifdef HAVE_LIBSSL
+static int
+imap_open_store_tlsstarted1( int ok, void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)aux;
 
-		s = socket( PF_INET, SOCK_STREAM, 0 );
+	if (!ok)
+		return imap_open_store_ssl_bail( ctx );
 
-		info( "Connecting to %s:%hu... ", inet_ntoa( addr.sin_addr ), ntohs( addr.sin_port ) );
-		if (connect( s, (struct sockaddr *)&addr, sizeof(addr) )) {
-			close( s );
-			perror( "connect" );
-			goto bail;
-		}
-		info( "ok\n" );
+	return 0;
+}
+#endif
 
-		imap->buf.sock.fd = s;
+static int
+imap_open_store_greeted( imap_store_t *ctx )
+{
+	if (ctx->greeting == GreetingBad) {
+		error( "IMAP error: unknown greeting response\n" );
+		return imap_open_store_bail( ctx );
 	}
 
-#if HAVE_LIBSSL
-	if (srvc->use_imaps) {
-		if (start_tls( ctx ))
-			goto ssl_bail;
-		use_ssl = 1;
-	}
-#endif
+	if (!ctx->caps)
+		return imap_exec( ctx, 0, imap_open_store_p2, "CAPABILITY" );
+	else
+		return imap_open_store_authenticate( ctx );
+}
 
-	/* read the greeting string */
-	if (buffer_gets( &imap->buf, &rsp )) {
-		fprintf( stderr, "IMAP error: no greeting response\n" );
-		goto bail;
-	}
-	arg = next_arg( &rsp );
-	if (!arg || *arg != '*' || (arg = next_arg( &rsp )) == NULL) {
-		fprintf( stderr, "IMAP error: invalid greeting response\n" );
-		goto bail;
-	}
-	preauth = 0;
-	if (!strcmp( "PREAUTH", arg ))
-		preauth = 1;
-	else if (strcmp( "OK", arg ) != 0) {
-		fprintf( stderr, "IMAP error: unknown greeting response\n" );
-		goto bail;
-	}
-	parse_response_code( ctx, 0, rsp );
-	if (!imap->caps && imap_exec( ctx, 0, "CAPABILITY" ) != RESP_OK)
-		goto bail;
+static int
+imap_open_store_p2( imap_store_t *ctx, struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_OK)
+		return imap_open_store_bail( ctx );
+
+	return imap_open_store_authenticate( ctx );
+}
+
+static int
+imap_open_store_authenticate( imap_store_t *ctx )
+{
+	if (ctx->greeting != GreetingPreauth) {
+#ifdef HAVE_LIBSSL
+		imap_store_conf_t *cfg = (imap_store_conf_t *)ctx->gen.conf;
+		imap_server_conf_t *srvc = cfg->server;
 
-	if (!preauth) {
-#if HAVE_LIBSSL
-		if (!srvc->use_imaps && (srvc->use_sslv2 || srvc->use_sslv3 || srvc->use_tlsv1)) {
+		if (!srvc->sconf.use_imaps &&
+		    (srvc->sconf.use_sslv2 || srvc->sconf.use_sslv3 || srvc->sconf.use_tlsv1)) {
 			/* always try to select SSL support if available */
 			if (CAP(STARTTLS)) {
-				if (imap_exec( ctx, 0, "STARTTLS" ) != RESP_OK)
-					goto bail;
-				if (start_tls( ctx ))
-					goto ssl_bail;
-				use_ssl = 1;
-
-				if (imap_exec( ctx, 0, "CAPABILITY" ) != RESP_OK)
-					goto bail;
+				return imap_exec( ctx, 0, imap_open_store_authenticate_p2, "STARTTLS" );
 			} else {
 				if (srvc->require_ssl) {
-					fprintf( stderr, "IMAP error: SSL support not available\n" );
-					goto bail;
-				} else
+					error( "IMAP error: SSL support not available\n" );
+					return imap_open_store_bail( ctx );
+				} else {
 					warn( "IMAP warning: SSL support not available\n" );
+				}
 			}
 		}
 #endif
+		return imap_open_store_authenticate2( ctx );
+	} else {
+		return imap_open_store_namespace( ctx );
+	}
+}
 
-		info ("Logging in...\n");
-		if (!srvc->user) {
-			fprintf( stderr, "Skipping server %s, no user\n", srvc->host );
-			goto bail;
-		}
-		if (!srvc->pass) {
-			char prompt[80];
-			sprintf( prompt, "Password (%s@%s): ", srvc->user, srvc->host );
-			arg = getpass( prompt );
-			if (!arg) {
-				perror( "getpass" );
-				exit( 1 );
-			}
-			if (!*arg) {
-				fprintf( stderr, "Skipping account %s@%s, no password\n", srvc->user, srvc->host );
-				goto bail;
-			}
-			/*
-			 * getpass() returns a pointer to a static buffer.  make a copy
-			 * for long term storage.
-			 */
-			srvc->pass = nfstrdup( arg );
+#ifdef HAVE_LIBSSL
+static int
+imap_open_store_authenticate_p2( imap_store_t *ctx, struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_OK)
+		return imap_open_store_bail( ctx );
+
+	return socket_start_tls( &ctx->conn, imap_open_store_tlsstarted2 );
+}
+
+static int
+imap_open_store_tlsstarted2( int ok, void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)aux;
+
+	if (!ok)
+		return imap_open_store_ssl_bail( ctx );
+
+	return imap_exec( ctx, 0, imap_open_store_authenticate_p3, "CAPABILITY" );
+}
+
+static int
+imap_open_store_authenticate_p3( imap_store_t *ctx, struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_OK)
+		return imap_open_store_bail( ctx );
+
+	return imap_open_store_authenticate2( ctx );
+}
+#endif
+
+static int
+imap_open_store_authenticate2( imap_store_t *ctx )
+{
+	imap_store_conf_t *cfg = (imap_store_conf_t *)ctx->gen.conf;
+	imap_server_conf_t *srvc = cfg->server;
+	char *arg;
+
+	info ("Logging in...\n");
+	if (!srvc->user) {
+		error( "Skipping account %s, no user\n", srvc->name );
+		goto bail;
+	}
+	if (!srvc->pass) {
+		char prompt[80];
+		sprintf( prompt, "Password (%s): ", srvc->name );
+		arg = getpass( prompt );
+		if (!arg) {
+			perror( "getpass" );
+			exit( 1 );
 		}
-#if HAVE_LIBSSL
-		if (CAP(CRAM)) {
-			struct imap_cmd_cb cb;
-
-			info( "Authenticating with CRAM-MD5\n" );
-			memset( &cb, 0, sizeof(cb) );
-			cb.cont = do_cram_auth;
-			if (imap_exec( ctx, &cb, "AUTHENTICATE CRAM-MD5" ) != RESP_OK)
-				goto bail;
-		} else if (srvc->require_cram) {
-			fprintf( stderr, "IMAP error: CRAM-MD5 authentication is not supported by server\n" );
+		if (!*arg) {
+			error( "Skipping account %s, no password\n", srvc->name );
 			goto bail;
-		} else
+		}
+		/*
+		 * getpass() returns a pointer to a static buffer.  make a copy
+		 * for long term storage.
+		 */
+		srvc->pass = nfstrdup( arg );
+	}
+#ifdef HAVE_LIBSSL
+	if (CAP(CRAM)) {
+		struct imap_cmd *cmd = new_imap_cmd( sizeof(*cmd) );
+
+		info( "Authenticating with CRAM-MD5\n" );
+		cmd->param.cont = do_cram_auth;
+		return imap_exec( ctx, cmd, imap_open_store_authenticate2_p2, "AUTHENTICATE CRAM-MD5" );
+	}
+	if (srvc->require_cram) {
+		error( "IMAP error: CRAM-MD5 authentication is not supported by server\n" );
+		goto bail;
+	}
 #endif
-		{
-			if (CAP(NOLOGIN)) {
-				fprintf( stderr, "Skipping account %s@%s, server forbids LOGIN\n", srvc->user, srvc->host );
-				goto bail;
-			}
-#if HAVE_LIBSSL
-			if (!use_ssl)
+	if (CAP(NOLOGIN)) {
+		error( "Skipping account %s, server forbids LOGIN\n", srvc->name );
+		goto bail;
+	}
+#ifdef HAVE_LIBSSL
+	if (!ctx->conn.ssl)
 #endif
-				warn( "*** IMAP Warning *** Password is being sent in the clear\n" );
-			if (imap_exec( ctx, 0, "LOGIN \"%s\" \"%s\"", srvc->user, srvc->pass ) != RESP_OK) {
-				fprintf( stderr, "IMAP error: LOGIN failed\n" );
-				goto bail;
-			}
-		}
-	} /* !preauth */
+		warn( "*** IMAP Warning *** Password is being sent in the clear\n" );
+	return imap_exec( ctx, 0, imap_open_store_authenticate2_p2,
+	                  "LOGIN \"%s\" \"%s\"", srvc->user, srvc->pass );
+
+  bail:
+	return imap_open_store_bail( ctx );
+}
 
-  final:
-	ctx->prefix = "";
-	if (*conf->path)
-		ctx->prefix = conf->path;
-	else if (cfg->use_namespace && CAP(NAMESPACE)) {
+static int
+imap_open_store_authenticate2_p2( imap_store_t *ctx, struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_OK)
+		return imap_open_store_bail( ctx );
+
+	return imap_open_store_namespace( ctx );
+}
+
+static int
+imap_open_store_namespace( imap_store_t *ctx )
+{
+	imap_store_conf_t *cfg = (imap_store_conf_t *)ctx->gen.conf;
+
+	ctx->prefix = cfg->gen.path;
+	ctx->delimiter = cfg->delimiter;
+	if (((!*ctx->prefix && cfg->use_namespace) || !cfg->delimiter) && CAP(NAMESPACE)) {
 		/* get NAMESPACE info */
-		if (imap_exec( ctx, 0, "NAMESPACE" ) != RESP_OK)
-			goto bail;
-		/* XXX for now assume personal namespace */
-		if (is_list( imap->ns_personal ) &&
-		    is_list( imap->ns_personal->child ) &&
-		    is_atom( imap->ns_personal->child->child ))
-			ctx->prefix = imap->ns_personal->child->child->val;
+		if (!ctx->got_namespace)
+			return imap_exec( ctx, 0, imap_open_store_namespace_p2, "NAMESPACE" );
+		else
+			return imap_open_store_namespace2( ctx );
 	}
-	ctx->trashnc = 1;
-	return (store_t *)ctx;
+	return imap_open_store_finalize( ctx );
+}
+
+static int
+imap_open_store_namespace_p2( imap_store_t *ctx, struct imap_cmd *cmd ATTR_UNUSED, int response )
+{
+	if (response != RESP_OK)
+		return imap_open_store_bail( ctx );
+
+	ctx->got_namespace = 1;
+	return imap_open_store_namespace2( ctx );
+}
 
-#if HAVE_LIBSSL
-  ssl_bail:
+static int
+imap_open_store_namespace2( imap_store_t *ctx )
+{
+	imap_store_conf_t *cfg = (imap_store_conf_t *)ctx->gen.conf;
+	list_t *nsp, *nsp_1st, *nsp_1st_ns, *nsp_1st_dl;
+
+	/* XXX for now assume 1st personal namespace */
+	if (is_list( (nsp = ctx->ns_personal) ) &&
+	    is_list( (nsp_1st = nsp->child) ) &&
+	    is_atom( (nsp_1st_ns = nsp_1st->child) ) &&
+	    is_atom( (nsp_1st_dl = nsp_1st_ns->next) ))
+	{
+		if (!*ctx->prefix && cfg->use_namespace)
+			ctx->prefix = nsp_1st_ns->val;
+		if (!ctx->delimiter)
+			ctx->delimiter = *nsp_1st_dl->val;
+	}
+	return imap_open_store_finalize( ctx );
+}
+
+static int
+imap_open_store_finalize( imap_store_t *ctx )
+{
+	set_bad_callback( &ctx->gen, 0, 0 );
+	ctx->trashnc = TrashUnknown;
+	return ctx->callbacks.imap_open( &ctx->gen, ctx->callback_aux );
+}
+
+#ifdef HAVE_LIBSSL
+static int
+imap_open_store_ssl_bail( imap_store_t *ctx )
+{
 	/* This avoids that we try to send LOGOUT to an unusable socket. */
-	close( imap->buf.sock.fd );
-	imap->buf.sock.fd = -1;
+	socket_close( &ctx->conn );
+	return imap_open_store_bail( ctx );
+}
 #endif
-  bail:
-	imap_close_store( &ctx->gen );
-	return 0;
+
+static int
+imap_open_store_bail( imap_store_t *ctx )
+{
+	int (*cb)( store_t *srv, void *aux ) = ctx->callbacks.imap_open;
+	void *aux = ctx->callback_aux;
+	imap_cancel_store( &ctx->gen );
+	cb( 0, aux );
+	return -1;
 }
 
+/******************* imap_prepare_opts *******************/
+
 static void
-imap_prepare( store_t *gctx, int opts )
+imap_prepare_opts( store_t *gctx, int opts )
 {
-	free_generic_messages( gctx->msgs );
-	gctx->msgs = 0;
 	gctx->opts = opts;
 }
 
+/******************* imap_select *******************/
+
 static int
-imap_select( store_t *gctx, int minuid, int maxuid, int *excs, int nexcs )
+imap_select( store_t *gctx, int create,
+             int (*cb)( int sts, void *aux ), void *aux )
 {
 	imap_store_t *ctx = (imap_store_t *)gctx;
-	imap_t *imap = ctx->imap;
-	const char *prefix;
-	int ret, i, j, bl;
-	struct imap_cmd_cb cb;
-	char buf[1000];
+	struct imap_cmd_simple *cmd;
+	char buf[1024];
 
+	free_generic_messages( gctx->msgs );
+	gctx->msgs = 0;
 
-	if (!strcmp( gctx->name, "INBOX" )) {
-//		imap->currentnc = 0;
-		prefix = "";
-	} else {
-//		imap->currentnc = 1;	/* could use LIST results for that */
-		prefix = ctx->prefix;
-	}
+	if (prepare_box( buf, ctx ) < 0)
+		return cb( DRV_BOX_BAD, aux );
 
-	imap->uidnext = -1;
+	ctx->gen.uidnext = 0;
 
-	memset( &cb, 0, sizeof(cb) );
-	cb.create = (gctx->opts & OPEN_CREATE) != 0;
-	cb.trycreate = 1;
-	if ((ret = imap_exec_b( ctx, &cb, "SELECT \"%s%s\"", prefix, gctx->name )) != DRV_OK)
-		goto bail;
+	INIT_IMAP_CMD(imap_cmd_simple, cmd, cb, aux)
+	cmd->gen.param.create = create;
+	cmd->gen.param.trycreate = 1;
+	return imap_exec( ctx, &cmd->gen, imap_done_simple_box, "SELECT \"%s\"", buf );
+}
+
+/******************* imap_load *******************/
+
+static int imap_submit_load( imap_store_t *, const char *, int, struct imap_cmd_refcounted_state * );
+
+static int
+imap_load( store_t *gctx, int minuid, int maxuid, int newuid, int *excs, int nexcs,
+           int (*cb)( int sts, void *aux ), void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)gctx;
+	int i, j, bl;
+	char buf[1000];
 
-	if (gctx->count) {
-		imap->msgapp = &gctx->msgs;
+	if (!ctx->gen.count) {
+		free( excs );
+		return cb( DRV_OK, aux );
+	} else {
+		struct imap_cmd_refcounted_state *sts = imap_refcounted_new_state( cb, aux );
+
+		ctx->msgapp = &ctx->gen.msgs;
 		sort_ints( excs, nexcs );
 		for (i = 0; i < nexcs; ) {
 			for (bl = 0; i < nexcs && bl < 960; i++) {
@@ -1454,44 +1522,68 @@ imap_select( store_t *gctx, int minuid, int maxuid, int *excs, int nexcs )
 					buf[bl++] = ',';
 				bl += sprintf( buf + bl, "%d", excs[i] );
 				j = i;
-				for (; i + 1 < nexcs && excs[i + 1] == excs[i] + 1; i++);
+				for (; i + 1 < nexcs && excs[i + 1] == excs[i] + 1; i++) {}
 				if (i != j)
 					bl += sprintf( buf + bl, ":%d", excs[i] );
 			}
-			if ((ret = imap_exec_b( ctx, 0, "UID FETCH %s (UID%s%s)", buf,
-			                        (gctx->opts & OPEN_FLAGS) ? " FLAGS" : "",
-			                        (gctx->opts & OPEN_SIZE) ? " RFC822.SIZE" : "" )) != DRV_OK)
-				goto bail;
+			if (imap_submit_load( ctx, buf, 0, sts ) < 0) {
+				free( excs );
+				return -1;
+			}
 		}
 		if (maxuid == INT_MAX)
-			maxuid = imap->uidnext >= 0 ? imap->uidnext - 1 : 1000000000;
-		if (maxuid >= minuid &&
-		    (ret = imap_exec_b( ctx, 0, "UID FETCH %d:%d (UID%s%s)", minuid, maxuid,
-		                        (gctx->opts & OPEN_FLAGS) ? " FLAGS" : "",
-		                        (gctx->opts & OPEN_SIZE) ? " RFC822.SIZE" : "" )) != DRV_OK)
-			goto bail;
-	}
-
-	ret = DRV_OK;
-
-  bail:
-	if (excs)
+			maxuid = ctx->gen.uidnext ? ctx->gen.uidnext - 1 : 1000000000;
+		if (maxuid >= minuid) {
+			if ((ctx->gen.opts & OPEN_FIND) && minuid < newuid) {
+				sprintf( buf, "%d:%d", minuid, newuid - 1 );
+				if (imap_submit_load( ctx, buf, 0, sts ) < 0) {
+					free( excs );
+					return -1;
+				}
+				sprintf( buf, "%d:%d", newuid, maxuid );
+			} else {
+				sprintf( buf, "%d:%d", minuid, maxuid );
+			}
+			if (imap_submit_load( ctx, buf, (ctx->gen.opts & OPEN_FIND), sts ) < 0) {
+				free( excs );
+				return -1;
+			}
+		}
 		free( excs );
-	return ret;
+		return 0;
+	}
 }
 
 static int
-imap_fetch_msg( store_t *ctx, message_t *msg, msg_data_t *data )
+imap_submit_load( imap_store_t *ctx, const char *buf, int tuids, struct imap_cmd_refcounted_state *sts )
 {
-	struct imap_cmd_cb cb;
+	return imap_exec( ctx, imap_refcounted_new_cmd( sts ), imap_refcounted_done_box,
+	                  "UID FETCH %s (UID%s%s%s)", buf,
+	                  (ctx->gen.opts & OPEN_FLAGS) ? " FLAGS" : "",
+	                  (ctx->gen.opts & OPEN_SIZE) ? " RFC822.SIZE" : "",
+	                  tuids ? " BODY.PEEK[HEADER.FIELDS (X-TUID)]" : "");
+}
+
+/******************* imap_fetch_msg *******************/
 
-	memset( &cb, 0, sizeof(cb) );
-	cb.uid = msg->uid;
-	cb.ctx = data;
-	return imap_exec_m( (imap_store_t *)ctx, &cb, "UID FETCH %d (%sBODY.PEEK[])",
-	                    msg->uid, (msg->status & M_FLAGS) ? "" : "FLAGS " );
+static int
+imap_fetch_msg( store_t *ctx, message_t *msg, msg_data_t *data,
+                int (*cb)( int sts, void *aux ), void *aux )
+{
+	struct imap_cmd_fetch_msg *cmd;
+
+	INIT_IMAP_CMD_X(imap_cmd_fetch_msg, cmd, cb, aux)
+	cmd->gen.gen.param.uid = msg->uid;
+	cmd->msg_data = data;
+	return imap_exec( (imap_store_t *)ctx, &cmd->gen.gen, imap_done_simple_msg,
+	                  "UID FETCH %d (%sBODY.PEEK[])",
+	                  msg->uid, (msg->status & M_FLAGS) ? "" : "FLAGS " );
 }
 
+/******************* imap_set_flags *******************/
+
+static int imap_set_flags_p2( imap_store_t *, struct imap_cmd *, int );
+
 static int
 imap_make_flags( int flags, char *buf )
 {
@@ -1511,19 +1603,21 @@ imap_make_flags( int flags, char *buf )
 }
 
 static int
-imap_flags_helper( imap_store_t *ctx, int uid, char what, int flags)
+imap_flags_helper( imap_store_t *ctx, int uid, char what, int flags,
+                   struct imap_cmd_refcounted_state *sts )
 {
 	char buf[256];
 
 	buf[imap_make_flags( flags, buf )] = 0;
-	return issue_imap_cmd_w( ctx, 0, "UID STORE %d %cFLAGS.SILENT %s", uid, what, buf ) ? DRV_OK : DRV_STORE_BAD;
+	return imap_exec( ctx, imap_refcounted_new_cmd( sts ), imap_set_flags_p2,
+	                  "UID STORE %d %cFLAGS.SILENT %s", uid, what, buf );
 }
 
 static int
-imap_set_flags( store_t *gctx, message_t *msg, int uid, int add, int del )
+imap_set_flags( store_t *gctx, message_t *msg, int uid, int add, int del,
+                int (*cb)( int sts, void *aux ), void *aux )
 {
 	imap_store_t *ctx = (imap_store_t *)gctx;
-	int ret;
 
 	if (msg) {
 		uid = msg->uid;
@@ -1532,114 +1626,75 @@ imap_set_flags( store_t *gctx, message_t *msg, int uid, int add, int del )
 		msg->flags |= add;
 		msg->flags &= ~del;
 	}
-	if ((!add || (ret = imap_flags_helper( ctx, uid, '+', add )) == DRV_OK) &&
-	    (!del || (ret = imap_flags_helper( ctx, uid, '-', del )) == DRV_OK))
-		return DRV_OK;
-	return ret;
+	if (add || del) {
+		struct imap_cmd_refcounted_state *sts = imap_refcounted_new_state( cb, aux );
+		if ((add && imap_flags_helper( ctx, uid, '+', add, sts ) < 0) ||
+		    (del && imap_flags_helper( ctx, uid, '-', del, sts ) < 0))
+			return -1;
+		return 0;
+	} else {
+		return cb( DRV_OK, aux );
+	}
 }
 
 static int
-imap_close( store_t *ctx )
+imap_set_flags_p2( imap_store_t *ctx ATTR_UNUSED, struct imap_cmd *cmd, int response )
 {
-	return imap_exec_b( (imap_store_t *)ctx, 0, "CLOSE" );
+	struct imap_cmd_refcounted_state *sts = ((struct imap_cmd_refcounted *)cmd)->state;
+	switch (response) {
+	case RESP_CANCEL:
+		sts->ret_val = DRV_CANCELED;
+		break;
+	case RESP_NO:
+		if (sts->ret_val == DRV_OK) /* Don't override cancelation. */
+			sts->ret_val = DRV_MSG_BAD;
+		break;
+	}
+	return imap_refcounted_done( sts );
 }
 
+/******************* imap_close *******************/
+
 static int
-imap_trash_msg( store_t *gctx, message_t *msg )
+imap_close( store_t *ctx,
+            int (*cb)( int sts, void *aux ), void *aux )
 {
-	imap_store_t *ctx = (imap_store_t *)gctx;
-	struct imap_cmd_cb cb;
+	struct imap_cmd_simple *cmd;
 
-	memset( &cb, 0, sizeof(cb) );
-	cb.create = 1;
-	return imap_exec_m( ctx, &cb, "UID COPY %d \"%s%s\"",
-	                    msg->uid, ctx->prefix, gctx->conf->trash );
+	INIT_IMAP_CMD(imap_cmd_simple, cmd, cb, aux)
+	return imap_exec( (imap_store_t *)ctx, &cmd->gen, imap_done_simple_box, "CLOSE" );
 }
 
-#define TUIDL 8
+/******************* imap_trash_msg *******************/
 
 static int
-imap_store_msg( store_t *gctx, msg_data_t *data, int *uid )
+imap_trash_msg( store_t *gctx, message_t *msg,
+                int (*cb)( int sts, void *aux ), void *aux )
 {
 	imap_store_t *ctx = (imap_store_t *)gctx;
-	imap_t *imap = ctx->imap;
-	struct imap_cmd_cb cb;
-	char *fmap, *buf;
-	const char *prefix, *box;
-	int ret, i, j, d, len, extra, nocr;
-	int start, sbreak = 0, ebreak = 0;
-	char flagstr[128], tuid[TUIDL * 2 + 1];
-
-	memset( &cb, 0, sizeof(cb) );
-
-	fmap = data->data;
-	len = data->len;
-	nocr = !data->crlf;
-	extra = 0, i = 0;
-	if (!CAP(UIDPLUS) && uid) {
-	  nloop:
-		start = i;
-		while (i < len)
-			if (fmap[i++] == '\n') {
-				extra += nocr;
-				if (i - 2 + nocr == start) {
-					sbreak = ebreak = i - 2 + nocr;
-					goto mktid;
-				}
-				if (!memcmp( fmap + start, "X-TUID: ", 8 )) {
-					extra -= (ebreak = i) - (sbreak = start) + nocr;
-					goto mktid;
-				}
-				goto nloop;
-			}
-		/* invalid message */
-		free( fmap );
-		fprintf( stderr, "IMAP warning: storing message with incomplete header.\n" );
-		return DRV_MSG_BAD;
-	 mktid:
-		for (j = 0; j < TUIDL; j++)
-			sprintf( tuid + j * 2, "%02x", arc4_getbyte() );
-		extra += 8 + TUIDL * 2 + 2;
-	}
-	if (nocr)
-		for (; i < len; i++)
-			if (fmap[i] == '\n')
-				extra++;
-
-	cb.dlen = len + extra;
-	buf = cb.data = nfmalloc( cb.dlen );
-	i = 0;
-	if (!CAP(UIDPLUS) && uid) {
-		if (nocr) {
-			for (; i < sbreak; i++)
-				if (fmap[i] == '\n') {
-					*buf++ = '\r';
-					*buf++ = '\n';
-				} else
-					*buf++ = fmap[i];
-		} else {
-			memcpy( buf, fmap, sbreak );
-			buf += sbreak;
-		}
-		memcpy( buf, "X-TUID: ", 8 );
-		buf += 8;
-		memcpy( buf, tuid, TUIDL * 2 );
-		buf += TUIDL * 2;
-		*buf++ = '\r';
-		*buf++ = '\n';
-		i = ebreak;
-	}
-	if (nocr) {
-		for (; i < len; i++)
-			if (fmap[i] == '\n') {
-				*buf++ = '\r';
-				*buf++ = '\n';
-			} else
-				*buf++ = fmap[i];
-	} else
-		memcpy( buf, fmap + i, len - i );
+	struct imap_cmd_simple *cmd;
+
+	INIT_IMAP_CMD(imap_cmd_simple, cmd, cb, aux)
+	cmd->gen.param.create = 1;
+	cmd->gen.param.to_trash = 1;
+	return imap_exec( ctx, &cmd->gen, imap_done_simple_msg,
+	                  "UID COPY %d \"%s%s\"",
+	                  msg->uid, ctx->prefix, gctx->conf->trash );
+}
+
+/******************* imap_store_msg *******************/
 
-	free( fmap );
+static int imap_store_msg_p2( imap_store_t *, struct imap_cmd *, int );
+
+static int
+imap_store_msg( store_t *gctx, msg_data_t *data, int to_trash,
+                int (*cb)( int sts, int uid, void *aux ), void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)gctx;
+	struct imap_cmd_out_uid *cmd;
+	const char *prefix, *box;
+	int d;
+	char flagstr[128], buf[1024];
 
 	d = 0;
 	if (data->flags) {
@@ -1648,62 +1703,94 @@ imap_store_msg( store_t *gctx, msg_data_t *data, int *uid )
 	}
 	flagstr[d] = 0;
 
-	if (!uid) {
+	INIT_IMAP_CMD(imap_cmd_out_uid, cmd, cb, aux)
+	cmd->gen.param.data_len = data->len;
+	cmd->gen.param.data = data->data;
+	cmd->out_uid = -2;
+
+	if (to_trash) {
 		box = gctx->conf->trash;
 		prefix = ctx->prefix;
-		cb.create = 1;
-		if (ctx->trashnc)
-			imap->caps = imap->rcaps & ~(1 << LITERALPLUS);
+		cmd->gen.param.create = 1;
+		cmd->gen.param.to_trash = 1;
 	} else {
-		box = gctx->name;
-		prefix = !strcmp( box, "INBOX" ) ? "" : ctx->prefix;
-		cb.create = (gctx->opts & OPEN_CREATE) != 0;
-		/*if (ctx->currentnc)
-			imap->caps = imap->rcaps & ~(1 << LITERALPLUS);*/
-	}
-	cb.ctx = uid;
-	ret = imap_exec_m( ctx, &cb, "APPEND \"%s%s\" %s", prefix, box, flagstr );
-	imap->caps = imap->rcaps;
-	if (ret != DRV_OK)
-		return ret;
-	if (!uid)
-		ctx->trashnc = 0;
-	else {
-		/*ctx->currentnc = 0;*/
-		gctx->count++;
+		if (prepare_box( buf, ctx ) < 0)
+			return cb( DRV_BOX_BAD, -1, aux );
+		box = buf;
+		prefix = "";
 	}
+	return imap_exec( ctx, &cmd->gen, imap_store_msg_p2,
+	                  "APPEND \"%s%s\" %s", prefix, box, flagstr );
+}
 
-	if (CAP(UIDPLUS) || !uid)
-		return DRV_OK;
+static int
+imap_store_msg_p2( imap_store_t *ctx ATTR_UNUSED, struct imap_cmd *cmd, int response )
+{
+	struct imap_cmd_out_uid *cmdp = (struct imap_cmd_out_uid *)cmd;
 
-	/* Didn't receive an APPENDUID */
-	cb.uid = -1; /* we're looking for a UID */
-	cb.data = 0; /* reset; ctx still set */
-	return imap_exec_m( ctx, &cb, "UID SEARCH HEADER X-TUID %s", tuid );
+	transform_msg_response( &response );
+	return cmdp->callback( response, cmdp->out_uid, cmdp->callback_aux );
 }
 
+/******************* imap_find_new_msgs *******************/
+
 static int
-imap_list( store_t *gctx, string_list_t **retb )
+imap_find_new_msgs( store_t *gctx,
+                    int (*cb)( int sts, void *aux ), void *aux )
 {
 	imap_store_t *ctx = (imap_store_t *)gctx;
-	imap_t *imap = ctx->imap;
-	int ret;
+	struct imap_cmd_simple *cmd;
 
-	imap->boxes = 0;
-	if ((ret = imap_exec_b( ctx, 0, "LIST \"\" \"%s%%\"", ctx->prefix )) != DRV_OK)
-		return ret;
-	*retb = imap->boxes;
-	return DRV_OK;
+	INIT_IMAP_CMD(imap_cmd_simple, cmd, cb, aux)
+	return imap_exec( (imap_store_t *)ctx, &cmd->gen, imap_done_simple_box,
+	                  "UID FETCH %d:1000000000 (UID BODY.PEEK[HEADER.FIELDS (X-TUID)])", ctx->gen.uidnext );
 }
 
+/******************* imap_list *******************/
+
 static int
-imap_check( store_t *gctx )
+imap_list( store_t *gctx, int flags,
+           int (*cb)( int sts, void *aux ), void *aux )
+{
+	imap_store_t *ctx = (imap_store_t *)gctx;
+	struct imap_cmd_refcounted_state *sts = imap_refcounted_new_state( cb, aux );
+
+	if (((flags & LIST_PATH) && imap_exec( ctx, imap_refcounted_new_cmd( sts ), imap_refcounted_done_box,
+	                                       "LIST \"\" \"%s*\"", ctx->prefix ) < 0) ||
+	    ((flags & LIST_INBOX) && (!(flags & LIST_PATH) || *ctx->prefix) &&
+	     imap_exec( ctx, imap_refcounted_new_cmd( sts ), imap_refcounted_done_box, "LIST \"\" INBOX*" ) < 0))
+		return -1;
+	return 0;
+}
+
+/******************* imap_cancel *******************/
+
+static void
+imap_cancel( store_t *gctx,
+             void (*cb)( void *aux ), void *aux )
 {
-	(void) gctx;
-	/* flush queue here */
-	return DRV_OK;
+	imap_store_t *ctx = (imap_store_t *)gctx;
+
+	cancel_pending_imap_cmds( ctx );
+	if (ctx->in_progress) {
+		ctx->canceling = 1;
+		ctx->callbacks.imap_cancel = cb;
+		ctx->callback_aux = aux;
+	} else {
+		cb( aux );
+	}
 }
 
+/******************* imap_commit *******************/
+
+static void
+imap_commit( store_t *gctx )
+{
+	(void)gctx;
+}
+
+/******************* imap_parse_store *******************/
+
 imap_server_conf_t *servers, **serverapp = &servers;
 
 static int
@@ -1731,23 +1818,24 @@ imap_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 	} else
 		return 0;
 
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 	/* this will probably annoy people, but its the best default just in
 	 * case people forget to turn it on
 	 */
 	server->require_ssl = 1;
-	server->use_tlsv1 = 1;
+	server->sconf.use_tlsv1 = 1;
 #endif
+	server->max_in_progress = INT_MAX;
 
 	while (getcline( cfg ) && cfg->cmd) {
 		if (!strcasecmp( "Host", cfg->cmd )) {
 			/* The imap[s]: syntax is just a backwards compat hack. */
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 			if (!memcmp( "imaps:", cfg->val, 6 )) {
 				cfg->val += 6;
-				server->use_imaps = 1;
-				server->use_sslv2 = 1;
-				server->use_sslv3 = 1;
+				server->sconf.use_imaps = 1;
+				server->sconf.use_sslv2 = 1;
+				server->sconf.use_sslv3 = 1;
 			} else
 #endif
 			{
@@ -1756,44 +1844,49 @@ imap_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 			}
 			if (!memcmp( "//", cfg->val, 2 ))
 				cfg->val += 2;
-			server->host = nfstrdup( cfg->val );
+			server->sconf.host = nfstrdup( cfg->val );
 		}
 		else if (!strcasecmp( "User", cfg->cmd ))
 			server->user = nfstrdup( cfg->val );
 		else if (!strcasecmp( "Pass", cfg->cmd ))
 			server->pass = nfstrdup( cfg->val );
 		else if (!strcasecmp( "Port", cfg->cmd ))
-			server->port = parse_int( cfg );
-#if HAVE_LIBSSL
+			server->sconf.port = parse_int( cfg );
+		else if (!strcasecmp( "PipelineDepth", cfg->cmd )) {
+			if ((server->max_in_progress = parse_int( cfg )) < 1) {
+				error( "%s:%d: PipelineDepth must be at least 1\n", cfg->file, cfg->line );
+				*err = 1;
+			}
+		}
+#ifdef HAVE_LIBSSL
 		else if (!strcasecmp( "CertificateFile", cfg->cmd )) {
-			server->cert_file = expand_strdup( cfg->val );
-			if (access( server->cert_file, R_OK )) {
-				fprintf( stderr, "%s:%d: CertificateFile '%s': %s\n",
-				         cfg->file, cfg->line, server->cert_file, strerror( errno ) );
+			server->sconf.cert_file = expand_strdup( cfg->val );
+			if (access( server->sconf.cert_file, R_OK )) {
+				sys_error( "%s:%d: CertificateFile '%s'",
+				           cfg->file, cfg->line, server->sconf.cert_file );
 				*err = 1;
 			}
 		} else if (!strcasecmp( "RequireSSL", cfg->cmd ))
 			server->require_ssl = parse_bool( cfg );
 		else if (!strcasecmp( "UseIMAPS", cfg->cmd ))
-			server->use_imaps = parse_bool( cfg );
+			server->sconf.use_imaps = parse_bool( cfg );
 		else if (!strcasecmp( "UseSSLv2", cfg->cmd ))
-			server->use_sslv2 = parse_bool( cfg );
+			server->sconf.use_sslv2 = parse_bool( cfg );
 		else if (!strcasecmp( "UseSSLv3", cfg->cmd ))
-			server->use_sslv3 = parse_bool( cfg );
+			server->sconf.use_sslv3 = parse_bool( cfg );
 		else if (!strcasecmp( "UseTLSv1", cfg->cmd ))
-			server->use_tlsv1 = parse_bool( cfg );
+			server->sconf.use_tlsv1 = parse_bool( cfg );
 		else if (!strcasecmp( "RequireCRAM", cfg->cmd ))
 			server->require_cram = parse_bool( cfg );
 #endif
 		else if (!strcasecmp( "Tunnel", cfg->cmd ))
-			server->tunnel = nfstrdup( cfg->val );
+			server->sconf.tunnel = nfstrdup( cfg->val );
 		else if (store) {
 			if (!strcasecmp( "Account", cfg->cmd )) {
 				for (srv = servers; srv; srv = srv->next)
 					if (srv->name && !strcmp( srv->name, cfg->val ))
 						goto gotsrv;
-				fprintf( stderr, "%s:%d: unknown IMAP account '%s'\n",
-				         cfg->file, cfg->line, cfg->val );
+				error( "%s:%d: unknown IMAP account '%s'\n", cfg->file, cfg->line, cfg->val );
 				*err = 1;
 				continue;
 			  gotsrv:
@@ -1802,23 +1895,24 @@ imap_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 				store->use_namespace = parse_bool( cfg );
 			else if (!strcasecmp( "Path", cfg->cmd ))
 				store->gen.path = nfstrdup( cfg->val );
+			else if (!strcasecmp( "PathDelimiter", cfg->cmd ))
+				store->delimiter = *cfg->val;
 			else
 				parse_generic_store( &store->gen, cfg, err );
 			continue;
 		} else {
-			fprintf( stderr, "%s:%d: unknown/misplaced keyword '%s'\n",
-			         cfg->file, cfg->line, cfg->cmd );
+			error( "%s:%d: unknown/misplaced keyword '%s'\n", cfg->file, cfg->line, cfg->cmd );
 			*err = 1;
 			continue;
 		}
 		acc_opt = 1;
 	}
 	if (!store || !store->server) {
-		if (!server->tunnel && !server->host) {
+		if (!server->sconf.tunnel && !server->sconf.host) {
 			if (store)
-				fprintf( stderr, "IMAP store '%s' has incomplete/missing connection details\n", store->gen.name );
+				error( "IMAP store '%s' has incomplete/missing connection details\n", store->gen.name );
 			else
-				fprintf( stderr, "IMAP account '%s' has incomplete/missing connection details\n", server->name );
+				error( "IMAP account '%s' has incomplete/missing connection details\n", server->name );
 			*err = 1;
 			return 1;
 		}
@@ -1829,7 +1923,7 @@ imap_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 			memcpy( store->server, &sserver, sizeof(sserver) );
 			store->server->name = store->gen.name;
 		} else if (acc_opt) {
-			fprintf( stderr, "IMAP store '%s' has both Account and account-specific options\n", store->gen.name );
+			error( "IMAP store '%s' has both Account and account-specific options\n", store->gen.name );
 			*err = 1;
 		}
 	}
@@ -1837,16 +1931,23 @@ imap_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 }
 
 struct driver imap_driver = {
+	DRV_CRLF,
 	imap_parse_store,
+	imap_cleanup,
 	imap_open_store,
-	imap_close_store,
+	imap_disown_store,
+	imap_own_store,
+	imap_cancel_store,
 	imap_list,
-	imap_prepare,
+	imap_prepare_opts,
 	imap_select,
+	imap_load,
 	imap_fetch_msg,
 	imap_store_msg,
+	imap_find_new_msgs,
 	imap_set_flags,
 	imap_trash_msg,
-	imap_check,
-	imap_close
+	imap_close,
+	imap_cancel,
+	imap_commit,
 };
diff --git src/drv_maildir.c src/drv_maildir.c
index e6cf08d..9f087bd 100644
--- src/drv_maildir.c
+++ src/drv_maildir.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
  * Copyright (C) 2004 Theodore Y. Ts'o <tytso@mit.edu>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -15,8 +15,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -24,6 +23,7 @@
 
 #include "isync.h"
 
+#include <assert.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
@@ -62,7 +62,7 @@ typedef struct maildir_message {
 typedef struct maildir_store {
 	store_t gen;
 	int uvfd, uvok, nuid;
-	int minuid, maxuid, nexcs, *excs;
+	int minuid, maxuid, newuid, nexcs, *excs;
 #ifdef USE_DB
 	DB *db;
 #endif /* USE_DB */
@@ -92,24 +92,22 @@ maildir_parse_flags( const char *base )
 	return flags;
 }
 
-static void maildir_close_store( store_t *gctx );
-
-static store_t *
-maildir_open_store( store_conf_t *conf, store_t *oldctx )
+static void
+maildir_open_store( store_conf_t *conf,
+                    int (*cb)( store_t *ctx, void *aux ), void *aux )
 {
 	maildir_store_t *ctx;
 	struct stat st;
 
-	if (oldctx)
-		maildir_close_store( oldctx );
 	if (stat( conf->path, &st ) || !S_ISDIR(st.st_mode)) {
-		fprintf( stderr, "Maildir error: cannot open store %s\n", conf->path );
-		return 0;
+		error( "Maildir error: cannot open store '%s'\n", conf->path );
+		cb( 0, aux );
+		return;
 	}
 	ctx = nfcalloc( sizeof(*ctx) );
 	ctx->gen.conf = conf;
 	ctx->uvfd = -1;
-	return &ctx->gen;
+	cb( &ctx->gen, aux );
 }
 
 static void
@@ -134,48 +132,113 @@ maildir_cleanup( store_t *gctx )
 	if (ctx->db)
 		ctx->db->close( ctx->db, 0 );
 #endif /* USE_DB */
-	if (gctx->path)
-		free( gctx->path );
-	if (ctx->excs)
-		free( ctx->excs );
+	free( gctx->path );
+	free( ctx->excs );
 	if (ctx->uvfd >= 0)
 		close( ctx->uvfd );
 }
 
 static void
-maildir_close_store( store_t *gctx )
+maildir_disown_store( store_t *gctx )
 {
 	maildir_cleanup( gctx );
+	free_string_list( gctx->boxes );
 	free( gctx );
 }
 
+static store_t *
+maildir_own_store( store_conf_t *conf )
+{
+	(void)conf;
+	return 0;
+}
+
+static void
+maildir_cleanup_drv( void )
+{
+}
+
+static int maildir_list_part( store_t *gctx, int doInbox, int *flags );
+
 static int
-maildir_list( store_t *gctx, string_list_t **retb )
+maildir_list_recurse( store_t *gctx, int isBox, int *flags, const char *inbox,
+                      char *path, int pathLen, char *name, int nameLen )
 {
 	DIR *dir;
+	int pl, nl;
 	struct dirent *de;
+	struct stat st;
 
-	if (!(dir = opendir( gctx->conf->path ))) {
-		fprintf( stderr, "%s: %s\n", gctx->conf->path, strerror(errno) );
-		return DRV_STORE_BAD;
+	if (isBox) {
+		nfsnprintf( path + pathLen, _POSIX_PATH_MAX - pathLen, "/cur" );
+		if (stat( path, &st ) || !S_ISDIR(st.st_mode))
+			return 0;
+		add_string_list( &gctx->boxes, name );
+		name[nameLen++] = '/';
+	}
+	if (!(dir = opendir( path ))) {
+		sys_error( "Maildir error: cannot list %s", path );
+		return -1;
 	}
-	*retb = 0;
 	while ((de = readdir( dir ))) {
-		const char *inbox = ((maildir_store_conf_t *)gctx->conf)->inbox;
-		int bl;
-		struct stat st;
-		char buf[PATH_MAX];
-
-		if (*de->d_name == '.')
-			continue;
-		bl = nfsnprintf( buf, sizeof(buf), "%s%s/cur", gctx->conf->path, de->d_name );
-		if (stat( buf, &st ) || !S_ISDIR(st.st_mode))
-			continue;
-		add_string_list( retb, !memcmp( buf, inbox, bl - 4 ) && !inbox[bl - 4] ? "INBOX" : de->d_name );
+		const char *ent = de->d_name;
+		pl = pathLen + nfsnprintf( path + pathLen, _POSIX_PATH_MAX - pathLen, "%s", ent );
+		if (inbox && !memcmp( path, inbox, pl ) && !inbox[pl]) {
+			if (maildir_list_part( gctx, 1, flags ) < 0)
+				return -1;
+		} else {
+			if (!memcmp( ent, "INBOX", 6 )) {
+				path[pathLen] = 0;
+				warn( "Maildir warning: ignoring INBOX in %s\n", path );
+				continue;
+			}
+			if (*ent == '.') {
+				if (!isBox)
+					continue;
+				ent++;
+			} else {
+				if (isBox)
+					continue;
+			}
+			nl = nameLen + nfsnprintf( name + nameLen, _POSIX_PATH_MAX - nameLen, "%s", ent );
+			if (maildir_list_recurse( gctx, 1, flags, inbox, path, pl, name, nl ) < 0)
+				return -1;
+		}
 	}
 	closedir (dir);
+	return 0;
+}
 
-	return DRV_OK;
+static int
+maildir_list_part( store_t *gctx, int doInbox, int *flags )
+{
+	int pl, nl;
+	const char *inbox = ((maildir_store_conf_t *)gctx->conf)->inbox;
+	char path[_POSIX_PATH_MAX], name[_POSIX_PATH_MAX];
+
+	if (doInbox) {
+		*flags &= ~LIST_INBOX;
+		pl = nfsnprintf( path, _POSIX_PATH_MAX, "%s", inbox );
+		nl = nfsnprintf( name, _POSIX_PATH_MAX, "INBOX" );
+		return maildir_list_recurse( gctx, 1, flags, 0, path, pl, name, nl );
+	} else {
+		pl = nfsnprintf( path, _POSIX_PATH_MAX, "%s", gctx->conf->path );
+		return maildir_list_recurse( gctx, 0, flags, inbox, path, pl, name, 0 );
+	}
+}
+
+static int
+maildir_list( store_t *gctx, int flags,
+              int (*cb)( int sts, void *aux ), void *aux )
+{
+	if (((flags & LIST_PATH) && maildir_list_part( gctx, 0, &flags ) < 0) ||
+	    ((flags & LIST_INBOX) && maildir_list_part( gctx, 1, &flags ) < 0)) {
+		gctx->bad_callback( gctx->bad_callback_aux );
+		cb( DRV_CANCELED, aux );
+		return -1;
+	}
+
+	return cb( DRV_OK, aux );
 }
 
 static const char *subdirs[] = { "cur", "new", "tmp" };
@@ -184,6 +247,7 @@ typedef struct {
 	char *base;
 	int size;
 	unsigned uid:31, recent:1;
+	char tuid[TUIDL];
 } msg_t;
 
 typedef struct {
@@ -198,8 +262,7 @@ maildir_free_scan( msglist_t *msglist )
 
 	if (msglist->ents) {
 		for (i = 0; i < msglist->nents; i++)
-			if (msglist->ents[i].base)
-				free( msglist->ents[i].base );
+			free( msglist->ents[i].base );
 		free( msglist->ents );
 	}
 }
@@ -207,7 +270,7 @@ maildir_free_scan( msglist_t *msglist )
 #define _24_HOURS (3600 * 24)
 
 static int
-maildir_validate( const char *prefix, const char *box, int create )
+maildir_validate( const char *prefix, const char *box, int create, maildir_store_t *ctx )
 {
 	DIR *dirp;
 	struct dirent *entry;
@@ -221,56 +284,52 @@ maildir_validate( const char *prefix, const char *box, int create )
 		if (errno == ENOENT) {
 			if (create) {
 				if (mkdir( buf, 0700 )) {
-					fprintf( stderr, "Maildir error: mkdir %s: %s (errno %d)\n",
-					         buf, strerror(errno), errno );
-					return DRV_STORE_BAD;
+					sys_error( "Maildir error: cannot create mailbox '%s'", buf );
+					ctx->gen.bad_callback( ctx->gen.bad_callback_aux );
+					return DRV_CANCELED;
 				}
 				for (i = 0; i < 3; i++) {
 					memcpy( buf + bl, subdirs[i], 4 );
 					if (mkdir( buf, 0700 )) {
-						fprintf( stderr, "Maildir error: mkdir %s: %s (errno %d)\n",
-						         buf, strerror(errno), errno );
+						sys_error( "Maildir error: cannot create directory %s", buf );
 						return DRV_BOX_BAD;
 					}
 				}
 			} else {
-				fprintf( stderr, "Maildir error: mailbox '%s' does not exist\n", buf );
+				error( "Maildir error: mailbox '%s' does not exist\n", buf );
 				return DRV_BOX_BAD;
 			}
 		} else {
-			fprintf( stderr, "Maildir error: stat %s: %s (errno %d)\n",
-			         buf, strerror(errno), errno );
+			sys_error( "Maildir error: cannot access mailbox '%s'", buf );
 			return DRV_BOX_BAD;
 		}
 	} else {
 		for (i = 0; i < 3; i++) {
 			memcpy( buf + bl, subdirs[i], 4 );
 			if (stat( buf, &st ) || !S_ISDIR(st.st_mode)) {
-				fprintf( stderr, "Maildir error: '%.*s' is no valid mailbox\n", bl, buf );
+				error( "Maildir error: '%.*s' is no valid mailbox\n", bl, buf );
 				return DRV_BOX_BAD;
 			}
 		}
 		memcpy( buf + bl, "tmp/", 5 );
 		bl += 4;
 		if (!(dirp = opendir( buf ))) {
-			fprintf( stderr, "Maildir error: opendir: %s: %s (errno %d)\n",
-			         buf, strerror(errno), errno );
+			sys_error( "Maildir error: cannot list %s", buf );
 			return DRV_BOX_BAD;
 		}
 		time( &now );
 		while ((entry = readdir( dirp ))) {
 			nfsnprintf( buf + bl, sizeof(buf) - bl, "%s", entry->d_name );
-			if (stat( buf, &st ))
-				fprintf( stderr, "Maildir error: stat: %s: %s (errno %d)\n",
-				         buf, strerror(errno), errno );
-			else if (S_ISREG(st.st_mode) && now - st.st_ctime >= _24_HOURS) {
+			if (stat( buf, &st )) {
+				if (errno != ENOENT)
+					sys_error( "Maildir error: cannot access %s", buf );
+			} else if (S_ISREG(st.st_mode) && now - st.st_ctime >= _24_HOURS) {
 				/* this should happen infrequently enough that it won't be
 				 * bothersome to the user to display when it occurs.
 				 */
 				info( "Maildir notice: removing stale file %s\n", buf );
-				if (unlink( buf ))
-					fprintf( stderr, "Maildir error: unlink: %s: %s (errno %d)\n",
-					         buf, strerror(errno), errno );
+				if (unlink( buf ) && errno != ENOENT)
+					sys_error( "Maildir error: cannot remove %s", buf );
 			}
 		}
 		closedir( dirp );
@@ -303,9 +362,6 @@ maildir_set_uid( maildir_store_t *ctx, const char *name, int *uid )
 	if ((ret = ctx->db->put( ctx->db, 0, &key, &value, 0 ))) {
 	  tbork:
 		ctx->db->err( ctx->db, ret, "Maildir error: db->put()" );
-	  bork:
-		ctx->db->close( ctx->db, 0 );
-		ctx->db = 0;
 		return DRV_BOX_BAD;
 	}
 	if (uid) {
@@ -317,7 +373,7 @@ maildir_set_uid( maildir_store_t *ctx, const char *name, int *uid )
 	}
 	if ((ret = ctx->db->sync( ctx->db, 0 ))) {
 		ctx->db->err( ctx->db, ret, "Maildir error: db->sync()" );
-		goto bork;
+		return DRV_BOX_BAD;
 	}
 	return DRV_OK;
 }
@@ -332,16 +388,15 @@ maildir_store_uid( maildir_store_t *ctx )
 	n = sprintf( buf, "%d\n%d\n", ctx->gen.uidvalidity, ctx->nuid );
 	lseek( ctx->uvfd, 0, SEEK_SET );
 	if (write( ctx->uvfd, buf, n ) != n || ftruncate( ctx->uvfd, n )) {
-		fprintf( stderr, "Maildir error: cannot write UIDVALIDITY.\n" );
+		error( "Maildir error: cannot write UIDVALIDITY.\n" );
 		return DRV_BOX_BAD;
 	}
 	return DRV_OK;
 }
 
 static int
-maildir_init_uid( maildir_store_t *ctx, const char *msg )
+maildir_init_uid( maildir_store_t *ctx )
 {
-	info( "Maildir notice: %s.\n", msg ? msg : "cannot read UIDVALIDITY, creating new" );
 	ctx->gen.uidvalidity = time( 0 );
 	ctx->nuid = 0;
 	ctx->uvok = 0;
@@ -356,6 +411,13 @@ maildir_init_uid( maildir_store_t *ctx, const char *msg )
 }
 
 static int
+maildir_init_uid_new( maildir_store_t *ctx )
+{
+	info( "Maildir notice: no UIDVALIDITY, creating new.\n" );
+	return maildir_init_uid( ctx );
+}
+
+static int
 maildir_uidval_lock( maildir_store_t *ctx )
 {
 	int n;
@@ -364,7 +426,7 @@ maildir_uidval_lock( maildir_store_t *ctx )
 #ifdef LEGACY_FLOCK
 	/* This is legacy only */
 	if (flock( ctx->uvfd, LOCK_EX ) < 0) {
-		fprintf( stderr, "Maildir error: cannot flock UIDVALIDITY.\n" );
+		error( "Maildir error: cannot flock UIDVALIDITY.\n" );
 		return DRV_BOX_BAD;
 	}
 #endif
@@ -375,13 +437,22 @@ maildir_uidval_lock( maildir_store_t *ctx )
 #endif
 	lck.l_type = F_WRLCK;
 	if (fcntl( ctx->uvfd, F_SETLKW, &lck )) {
-		fprintf( stderr, "Maildir error: cannot fcntl lock UIDVALIDITY.\n" );
+		error( "Maildir error: cannot fcntl lock UIDVALIDITY.\n" );
 		return DRV_BOX_BAD;
 	}
 	lseek( ctx->uvfd, 0, SEEK_SET );
 	if ((n = read( ctx->uvfd, buf, sizeof(buf) )) <= 0 ||
 	    (buf[n] = 0, sscanf( buf, "%d\n%d", &ctx->gen.uidvalidity, &ctx->nuid ) != 2)) {
-		return maildir_init_uid( ctx, 0 );
+#if 1
+		/* In a generic driver, resetting the UID validity would be the right thing.
+		 * But this would mess up the sync state completely. So better bail out and
+		 * give the user a chance to fix the mailbox. */
+		if (n) {
+			error( "Maildir error: cannot read UIDVALIDITY.\n" );
+			return DRV_BOX_BAD;
+		}
+#endif
+		return maildir_init_uid_new( ctx );
 	} else
 		ctx->uvok = 1;
 	return DRV_OK;
@@ -471,6 +542,7 @@ static int
 maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 {
 	DIR *d;
+	FILE *f;
 	struct dirent *e;
 	const char *u, *ru;
 #ifdef USE_DB
@@ -501,6 +573,7 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 			}
 			if ((tdb->open)( tdb, 0, 0, 0, DB_HASH, DB_CREATE, 0 )) {
 				fputs( "Maildir error: tdb->open() failed\n", stderr );
+			  bork:
 				tdb->close( tdb, 0 );
 				return DRV_BOX_BAD;
 			}
@@ -510,14 +583,7 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 		for (i = 0; i < 2; i++) {
 			memcpy( buf + bl, subdirs[i], 4 );
 			if (!(d = opendir( buf ))) {
-				perror( buf );
-#ifdef USE_DB
-				if (!ctx->db)
-#endif /* USE_DB */
-					maildir_uidval_unlock( ctx );
-#ifdef USE_DB
-			  bork:
-#endif /* USE_DB */
+				sys_error( "Maildir error: cannot list %s", buf );
 				maildir_free_scan( msglist );
 #ifdef USE_DB
 				if (ctx->db)
@@ -536,8 +602,8 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 					if ((ret = ctx->db->get( ctx->db, 0, &key, &value, 0 ))) {
 						if (ret != DB_NOTFOUND) {
 							ctx->db->err( ctx->db, ret, "Maildir error: db->get()" );
-							ctx->db->close( ctx->db, 0 );
-							ctx->db = 0;
+						  mbork:
+							maildir_free_scan( msglist );
 							goto bork;
 						}
 						uid = INT_MAX;
@@ -545,7 +611,7 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 						value.size = 0;
 						if ((ret = tdb->put( tdb, 0, &key, &value, 0 ))) {
 							tdb->err( tdb, ret, "Maildir error: tdb->put()" );
-							goto bork;
+							goto mbork;
 						}
 						uid = *(int *)value.data;
 					}
@@ -573,6 +639,7 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 					entry->uid = uid;
 					entry->recent = i;
 					entry->size = 0;
+					entry->tuid[0] = 0;
 				}
 			}
 			closedir( d );
@@ -610,15 +677,23 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 			entry = &msglist->ents[i];
 			if (entry->uid != INT_MAX) {
 				if (uid == entry->uid) {
-					if ((ret = maildir_init_uid( ctx, "duplicate UID; changing UIDVALIDITY" )) != DRV_OK) {
+#if 1
+					/* See comment in maildir_uidval_lock() why this is fatal. */
+					error( "Maildir error: duplicate UID %d.\n", uid );
+					maildir_free_scan( msglist );
+					return DRV_BOX_BAD;
+#else
+					info( "Maildir notice: duplicate UID; changing UIDVALIDITY.\n");
+					if ((ret = maildir_init_uid( ctx )) != DRV_OK) {
 						maildir_free_scan( msglist );
 						return ret;
 					}
 					maildir_free_scan( msglist );
 					goto again;
+#endif
 				}
 				uid = entry->uid;
-				if (ctx->gen.opts & OPEN_SIZE)
+				if ((ctx->gen.opts & OPEN_SIZE) || ((ctx->gen.opts & OPEN_FIND) && uid >= ctx->newuid))
 					nfsnprintf( buf + bl, sizeof(buf) - bl, "%s/%s", subdirs[entry->recent], entry->base );
 #ifdef USE_DB
 			} else if (ctx->db) {
@@ -627,7 +702,7 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 					return ret;
 				}
 				entry->uid = uid;
-				if (ctx->gen.opts & OPEN_SIZE)
+				if ((ctx->gen.opts & OPEN_SIZE) || ((ctx->gen.opts & OPEN_FIND) && uid >= ctx->newuid))
 					nfsnprintf( buf + bl, sizeof(buf) - bl, "%s/%s", subdirs[entry->recent], entry->base );
 #endif /* USE_DB */
 			} else {
@@ -647,9 +722,9 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 				memcpy( nbuf, buf, bl + 4 );
 				nfsnprintf( nbuf + bl + 4, sizeof(nbuf) - bl - 4, "%s", entry->base );
 				if (rename( nbuf, buf )) {
+				  notok:
 					if (errno != ENOENT) {
-						perror( buf );
-						maildir_uidval_unlock( ctx );
+						sys_error( "Maildir error: cannot rename %s to %s", nbuf, buf );
 						maildir_free_scan( msglist );
 						return DRV_BOX_BAD;
 					}
@@ -661,12 +736,23 @@ maildir_scan( maildir_store_t *ctx, msglist_t *msglist )
 				memcpy( entry->base, buf + bl + 4, fnl );
 			}
 			if (ctx->gen.opts & OPEN_SIZE) {
-				if (stat( buf, &st )) {
-					maildir_free_scan( msglist );
-					goto again;
-				}
+				if (stat( buf, &st ))
+					goto notok;
 				entry->size = st.st_size;
 			}
+			if ((ctx->gen.opts & OPEN_FIND) && uid >= ctx->newuid) {
+				if (!(f = fopen( buf, "r" )))
+					goto notok;
+				while (fgets( nbuf, sizeof(nbuf), f )) {
+					if (!nbuf[0] || nbuf[0] == '\n')
+						break;
+					if (!memcmp( nbuf, "X-TUID: ", 8 ) && nbuf[8 + TUIDL] == '\n') {
+						memcpy( entry->tuid, nbuf + 8, TUIDL );
+						break;
+					}
+				}
+				fclose( f );
+			}
 		}
 		ctx->uvok = 1;
 	}
@@ -683,6 +769,8 @@ maildir_init_msg( maildir_store_t *ctx, maildir_message_t *msg, msg_t *entry )
 	msg->base = entry->base;
 	entry->base = 0; /* prevent deletion */
 	msg->gen.size = entry->size;
+	msg->gen.srec = 0;
+	strncpy( msg->gen.tuid, entry->tuid, TUIDL );
 	if (entry->recent)
 		msg->gen.status |= M_RECENT;
 	if (ctx->gen.opts & OPEN_FLAGS) {
@@ -704,53 +792,60 @@ maildir_app_msg( maildir_store_t *ctx, message_t ***msgapp, msg_t *entry )
 	maildir_init_msg( ctx, msg, entry );
 }
 
-static void
-maildir_prepare( store_t *gctx, int opts )
+static char *
+maildir_join_path( const char *prefix, const char *box )
 {
-	maildir_store_t *ctx = (maildir_store_t *)gctx;
-
-	maildir_cleanup( gctx );
-	gctx->msgs = 0;
-	ctx->uvfd = -1;
-#ifdef USE_DB
-	ctx->db = 0;
-#endif /* USE_DB */
-	if (!strcmp( gctx->name, "INBOX" ))
-		gctx->path = nfstrdup( ((maildir_store_conf_t *)gctx->conf)->inbox );
-	else
-		nfasprintf( &gctx->path, "%s%s", gctx->conf->path, gctx->name );
-	if (opts & OPEN_SETFLAGS)
-		opts |= OPEN_OLD;
-	if (opts & OPEN_EXPUNGE)
-		opts |= OPEN_OLD|OPEN_NEW|OPEN_FLAGS;
-	gctx->opts = opts;
+	char *out, *p;
+	int pl, bl, n;
+	char c;
+
+	pl = strlen( prefix );
+	for (bl = 0, n = 0; (c = box[bl]); bl++)
+		if (c == '/')
+			n++;
+	out = nfmalloc( pl + bl + n + 1 );
+	memcpy( out, prefix, pl );
+	p = out + pl;
+	while ((c = *box++)) {
+		*p++ = c;
+		if (c == '/')
+			*p++ = '.';
+	}
+	*p = 0;
+	return out;
 }
 
 static int
-maildir_select( store_t *gctx, int minuid, int maxuid, int *excs, int nexcs )
+maildir_select( store_t *gctx, int create,
+                int (*cb)( int sts, void *aux ), void *aux )
 {
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
-	message_t **msgapp;
-	msglist_t msglist;
-	int i;
-#ifdef USE_DB
 	int ret;
+#ifdef USE_DB
+	struct stat st;
 #endif /* USE_DB */
 	char uvpath[_POSIX_PATH_MAX];
 
-	ctx->minuid = minuid;
-	ctx->maxuid = maxuid;
-	ctx->excs = nfrealloc( excs, nexcs * sizeof(int) );
-	ctx->nexcs = nexcs;
+	maildir_cleanup( gctx );
+	gctx->msgs = 0;
+	ctx->excs = 0;
+	ctx->uvfd = -1;
+#ifdef USE_DB
+	ctx->db = 0;
+#endif /* USE_DB */
+	gctx->path =
+		(!memcmp( gctx->name, "INBOX", 5 ) && (!gctx->name[5] || gctx->name[5] == '/')) ?
+			maildir_join_path( ((maildir_store_conf_t *)gctx->conf)->inbox, gctx->name + 5 ) :
+			maildir_join_path( gctx->conf->path, gctx->name );
 
-	if (maildir_validate( gctx->path, "", ctx->gen.opts & OPEN_CREATE ) != DRV_OK)
-		return DRV_BOX_BAD;
+	if ((ret = maildir_validate( gctx->path, "", create, ctx )) != DRV_OK)
+		return cb( ret, aux );
 
 	nfsnprintf( uvpath, sizeof(uvpath), "%s/.uidvalidity", gctx->path );
 #ifndef USE_DB
 	if ((ctx->uvfd = open( uvpath, O_RDWR|O_CREAT, 0600 )) < 0) {
-		perror( uvpath );
-		return DRV_BOX_BAD;
+		sys_error( "Maildir error: cannot write %s", uvpath );
+		return cb( DRV_BOX_BAD, aux );
 	}
 #else
 	if ((ctx->uvfd = open( uvpath, O_RDWR, 0600 )) < 0) {
@@ -764,8 +859,8 @@ maildir_select( store_t *gctx, int minuid, int maxuid, int *excs, int nexcs )
 				if ((ctx->uvfd = open( uvpath, O_RDWR|O_CREAT, 0600 )) >= 0)
 					goto fnok;
 			}
-			perror( uvpath );
-			return DRV_BOX_BAD;
+			sys_error( "Maildir error: cannot write %s", uvpath );
+			return cb( DRV_BOX_BAD, aux );
 		}
 	  dbok:
 #if SEEK_SET != 0
@@ -773,48 +868,80 @@ maildir_select( store_t *gctx, int minuid, int maxuid, int *excs, int nexcs )
 #endif
 		lck.l_type = F_WRLCK;
 		if (fcntl( ctx->uvfd, F_SETLKW, &lck )) {
-			perror( uvpath );
-		  bork:
-			close( ctx->uvfd );
-			ctx->uvfd = -1;
-			return DRV_BOX_BAD;
+			sys_error( "Maildir error: cannot lock %s", uvpath );
+			return cb( DRV_BOX_BAD, aux );
+		}
+		if (fstat( ctx->uvfd, &st )) {
+			sys_error( "Maildir error: cannot stat %s", uvpath );
+			return cb( DRV_BOX_BAD, aux );
 		}
 		if (db_create( &ctx->db, 0, 0 )) {
 			fputs( "Maildir error: db_create() failed\n", stderr );
-			goto bork;
+			return cb( DRV_BOX_BAD, aux );
 		}
-		if ((ret = (ctx->db->open)( ctx->db, 0, uvpath, 0, DB_HASH, DB_CREATE, 0 ))) {
+		if ((ret = (ctx->db->open)( ctx->db, 0, uvpath, 0, DB_HASH,
+		                            st.st_size ? 0 : DB_CREATE | DB_TRUNCATE, 0 ))) {
 			ctx->db->err( ctx->db, ret, "Maildir error: db->open(%s)", uvpath );
-		  dbork:
-			ctx->db->close( ctx->db, 0 );
-			goto bork;
+			return cb( DRV_BOX_BAD, aux );
 		}
 		key.data = (void *)"UIDVALIDITY";
 		key.size = 11;
 		if ((ret = ctx->db->get( ctx->db, 0, &key, &value, 0 ))) {
 			if (ret != DB_NOTFOUND) {
 				ctx->db->err( ctx->db, ret, "Maildir error: db->get()" );
-				goto dbork;
+				return cb( DRV_BOX_BAD, aux );
 			}
-			if (maildir_init_uid( ctx, 0 ) != DRV_OK)
-				goto dbork;
+			if (maildir_init_uid_new( ctx ) != DRV_OK)
+				return cb( DRV_BOX_BAD, aux );
 		} else {
 			ctx->gen.uidvalidity = ((int *)value.data)[0];
 			ctx->nuid = ((int *)value.data)[1];
 			ctx->uvok = 1;
 		}
+		return cb( DRV_OK, aux );
 	}
   fnok:
 #endif /* USE_DB */
+	if ((ret = maildir_uidval_lock( ctx )) != DRV_OK)
+		return ret;
+	maildir_uidval_unlock( ctx );
+
+	return cb( DRV_OK, aux );
+}
+
+static void
+maildir_prepare_opts( store_t *gctx, int opts )
+{
+	if (opts & OPEN_SETFLAGS)
+		opts |= OPEN_OLD;
+	if (opts & OPEN_EXPUNGE)
+		opts |= OPEN_OLD|OPEN_NEW|OPEN_FLAGS;
+	gctx->opts = opts;
+}
+
+static int
+maildir_load( store_t *gctx, int minuid, int maxuid, int newuid, int *excs, int nexcs,
+              int (*cb)( int sts, void *aux ), void *aux )
+{
+	maildir_store_t *ctx = (maildir_store_t *)gctx;
+	message_t **msgapp;
+	msglist_t msglist;
+	int i;
+
+	ctx->minuid = minuid;
+	ctx->maxuid = maxuid;
+	ctx->newuid = newuid;
+	ctx->excs = nfrealloc( excs, nexcs * sizeof(int) );
+	ctx->nexcs = nexcs;
 
 	if (maildir_scan( ctx, &msglist ) != DRV_OK)
-		return DRV_BOX_BAD;
+		return cb( DRV_BOX_BAD, aux );
 	msgapp = &ctx->gen.msgs;
 	for (i = 0; i < msglist.nents; i++)
 		maildir_app_msg( ctx, &msgapp, msglist.ents + i );
 	maildir_free_scan( &msglist );
 
-	return DRV_OK;
+	return cb( DRV_OK, aux );
 }
 
 static int
@@ -869,12 +996,13 @@ maildir_rescan( maildir_store_t *ctx )
 }
 
 static int
-maildir_again( maildir_store_t *ctx, maildir_message_t *msg, const char *fn )
+maildir_again( maildir_store_t *ctx, maildir_message_t *msg,
+               const char *err, const char *fn, const char *fn2 )
 {
 	int ret;
 
 	if (errno != ENOENT) {
-		perror( fn );
+		sys_error( err, fn, fn2 );
 		return DRV_BOX_BAD;
 	}
 	if ((ret = maildir_rescan( ctx )) != DRV_OK)
@@ -883,7 +1011,8 @@ maildir_again( maildir_store_t *ctx, maildir_message_t *msg, const char *fn )
 }
 
 static int
-maildir_fetch_msg( store_t *gctx, message_t *gmsg, msg_data_t *data )
+maildir_fetch_msg( store_t *gctx, message_t *gmsg, msg_data_t *data,
+                   int (*cb)( int sts, void *aux ), void *aux )
 {
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
 	maildir_message_t *msg = (maildir_message_t *)gmsg;
@@ -895,22 +1024,21 @@ maildir_fetch_msg( store_t *gctx, message_t *gmsg, msg_data_t *data )
 		nfsnprintf( buf, sizeof(buf), "%s/%s/%s", gctx->path, subdirs[gmsg->status & M_RECENT], msg->base );
 		if ((fd = open( buf, O_RDONLY )) >= 0)
 			break;
-		if ((ret = maildir_again( ctx, msg, buf )) != DRV_OK)
-			return ret;
+		if ((ret = maildir_again( ctx, msg, "Cannot open %s", buf, 0 )) != DRV_OK)
+			return cb( ret, aux );
 	}
 	fstat( fd, &st );
-	data->crlf = 0;
 	data->len = st.st_size;
 	data->data = nfmalloc( data->len );
 	if (read( fd, data->data, data->len ) != data->len) {
-		perror( buf );
+		sys_error( "Maildir error: cannot read %s", buf );
 		close( fd );
-		return DRV_MSG_BAD;
+		return cb( DRV_MSG_BAD, aux );
 	}
 	close( fd );
 	if (!(gmsg->status & M_FLAGS))
 		data->flags = maildir_parse_flags( msg->base );
-	return DRV_OK;
+	return cb( DRV_OK, aux );
 }
 
 static int
@@ -929,29 +1057,32 @@ maildir_make_flags( int flags, char *buf )
 }
 
 static int
-maildir_store_msg( store_t *gctx, msg_data_t *data, int *uid )
+maildir_store_msg( store_t *gctx, msg_data_t *data, int to_trash,
+                   int (*cb)( int sts, int uid, void *aux ), void *aux )
 {
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
 	const char *prefix, *box;
-	int ret, fd, bl;
+	int ret, fd, bl, uid;
 	char buf[_POSIX_PATH_MAX], nbuf[_POSIX_PATH_MAX], fbuf[NUM_FLAGS + 3], base[128];
 
 	bl = nfsnprintf( base, sizeof(base), "%ld.%d_%d.%s", time( 0 ), Pid, ++MaildirCount, Hostname );
-	if (uid) {
+	if (!to_trash) {
 #ifdef USE_DB
 		if (ctx->db) {
-			if ((ret = maildir_set_uid( ctx, base, uid )) != DRV_OK) {
+			if ((ret = maildir_set_uid( ctx, base, &uid )) != DRV_OK) {
 				free( data->data );
-				return ret;
+				return cb( ret, 0, aux );
 			}
 		} else
 #endif /* USE_DB */
 		{
 			if ((ret = maildir_uidval_lock( ctx )) != DRV_OK ||
-			    (ret = maildir_obtain_uid( ctx, uid )) != DRV_OK)
-				return ret;
+			    (ret = maildir_obtain_uid( ctx, &uid )) != DRV_OK) {
+				free( data->data );
+				return cb( ret, 0, aux );
+			}
 			maildir_uidval_unlock( ctx );
-			nfsnprintf( base + bl, sizeof(base) - bl, ",U=%d", *uid );
+			nfsnprintf( base + bl, sizeof(base) - bl, ",U=%d", uid );
 		}
 		prefix = gctx->path;
 		box = "";
@@ -964,44 +1095,55 @@ maildir_store_msg( store_t *gctx, msg_data_t *data, int *uid )
 	nfsnprintf( buf, sizeof(buf), "%s%s/tmp/%s%s", prefix, box, base, fbuf );
 	if ((fd = open( buf, O_WRONLY|O_CREAT|O_EXCL, 0600 )) < 0) {
 		if (errno != ENOENT) {
-			perror( buf );
+			sys_error( "Maildir error: cannot create %s", buf );
 			free( data->data );
-			return DRV_BOX_BAD;
+			return cb( DRV_BOX_BAD, 0, aux );
 		}
-		if ((ret = maildir_validate( gctx->conf->path, gctx->conf->trash, gctx->opts & OPEN_CREATE )) != DRV_OK) {
+		if ((ret = maildir_validate( gctx->conf->path, gctx->conf->trash, 1, ctx )) != DRV_OK) {
 			free( data->data );
-			return ret;
+			return cb( ret, 0, aux );
 		}
 		if ((fd = open( buf, O_WRONLY|O_CREAT|O_EXCL, 0600 )) < 0) {
-			perror( buf );
+			sys_error( "Maildir error: cannot create %s", buf );
 			free( data->data );
-			return DRV_BOX_BAD;
+			return cb( DRV_BOX_BAD, 0, aux );
 		}
 	}
-	strip_cr( data );
 	ret = write( fd, data->data, data->len );
 	free( data->data );
 	if (ret != data->len) {
 		if (ret < 0)
-			perror( buf );
+			sys_error( "Maildir error: cannot write %s", buf );
 		else
-			fprintf( stderr, "Maildir error: %s: partial write\n", buf );
+			error( "Maildir error: cannot write %s. Disk full?\n", buf );
 		close( fd );
-		return DRV_BOX_BAD;
+		return cb( DRV_BOX_BAD, 0, aux );
 	}
-	close( fd );
+	if (close( fd ) < 0) {
+		/* Quota exceeded may cause this. */
+		sys_error( "Maildir error: cannot write %s", buf );
+		return cb( DRV_BOX_BAD, 0, aux );
+	}
+	/* Moving seen messages to cur/ is strictly speaking incorrect, but makes mutt happy. */
 	nfsnprintf( nbuf, sizeof(nbuf), "%s%s/%s/%s%s", prefix, box, subdirs[!(data->flags & F_SEEN)], base, fbuf );
 	if (rename( buf, nbuf )) {
-		perror( nbuf );
-		return DRV_BOX_BAD;
+		sys_error( "Maildir error: cannot rename %s to %s", buf, nbuf );
+		return cb( DRV_BOX_BAD, 0, aux );
 	}
-	if (uid)
-		gctx->count++;
-	return DRV_OK;
+	return cb( DRV_OK, uid, aux );
 }
 
 static int
-maildir_set_flags( store_t *gctx, message_t *gmsg, int uid, int add, int del )
+maildir_find_new_msgs( store_t *gctx ATTR_UNUSED,
+                       int (*cb)( int sts, void *aux ) ATTR_UNUSED, void *aux ATTR_UNUSED )
+{
+	assert( !"maildir_find_new_msgs is not supposed to be called" );
+	return -1;
+}
+
+static int
+maildir_set_flags( store_t *gctx, message_t *gmsg, int uid, int add, int del,
+                   int (*cb)( int sts, void *aux ), void *aux )
 {
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
 	maildir_message_t *msg = (maildir_message_t *)gmsg;
@@ -1043,8 +1185,8 @@ maildir_set_flags( store_t *gctx, message_t *gmsg, int uid, int add, int del )
 		}
 		if (!rename( buf, nbuf ))
 			break;
-		if ((ret = maildir_again( ctx, msg, buf )) != DRV_OK)
-			return ret;
+		if ((ret = maildir_again( ctx, msg, "Maildir error: cannot rename %s to %s", buf, nbuf )) != DRV_OK)
+			return cb( ret, aux );
 	}
 	free( msg->base );
 	msg->base = nfmalloc( tl + 1 );
@@ -1053,7 +1195,7 @@ maildir_set_flags( store_t *gctx, message_t *gmsg, int uid, int add, int del )
 	msg->gen.flags &= ~del;
 	gmsg->status &= ~M_RECENT;
 
-	return DRV_OK;
+	return cb( DRV_OK, aux );
 }
 
 #ifdef USE_DB
@@ -1065,8 +1207,6 @@ maildir_purge_msg( maildir_store_t *ctx, const char *name )
 	make_key( &key, (char *)name );
 	if ((ret = ctx->db->del( ctx->db, 0, &key, 0 ))) {
 		ctx->db->err( ctx->db, ret, "Maildir error: db->del()" );
-		ctx->db->close( ctx->db, 0 );
-		ctx->db = 0;
 		return DRV_BOX_BAD;
 	}
 	return DRV_OK;
@@ -1074,7 +1214,8 @@ maildir_purge_msg( maildir_store_t *ctx, const char *name )
 #endif /* USE_DB */
 
 static int
-maildir_trash_msg( store_t *gctx, message_t *gmsg )
+maildir_trash_msg( store_t *gctx, message_t *gmsg,
+                   int (*cb)( int sts, void *aux ), void *aux )
 {
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
 	maildir_message_t *msg = (maildir_message_t *)gmsg;
@@ -1091,30 +1232,31 @@ maildir_trash_msg( store_t *gctx, message_t *gmsg )
 		if (!rename( buf, nbuf ))
 			break;
 		if (!stat( buf, &st )) {
-			if ((ret = maildir_validate( gctx->conf->path, gctx->conf->trash, 1 )) != DRV_OK)
-				return ret;
+			if ((ret = maildir_validate( gctx->conf->path, gctx->conf->trash, 1, ctx )) != DRV_OK)
+				return cb( ret, aux );
 			if (!rename( buf, nbuf ))
 				break;
 			if (errno != ENOENT) {
-				perror( nbuf );
-				return DRV_BOX_BAD;
+				sys_error( "Maildir error: cannot move %s to %s", buf, nbuf );
+				return cb( DRV_BOX_BAD, aux );
 			}
 		}
-		if ((ret = maildir_again( ctx, msg, buf )) != DRV_OK)
-			return ret;
+		if ((ret = maildir_again( ctx, msg, "Maildir error: cannot move %s to %s", buf, nbuf )) != DRV_OK)
+			return cb( ret, aux );
 	}
 	gmsg->status |= M_DEAD;
 	gctx->count--;
 
 #ifdef USE_DB
 	if (ctx->db)
-		return maildir_purge_msg( ctx, msg->base );
+		return cb( maildir_purge_msg( ctx, msg->base ), aux );
 #endif /* USE_DB */
-	return DRV_OK;
+	return cb( DRV_OK, aux );
 }
 
 static int
-maildir_close( store_t *gctx )
+maildir_close( store_t *gctx,
+               int (*cb)( int sts, void *aux ), void *aux )
 {
 #ifdef USE_DB
 	maildir_store_t *ctx = (maildir_store_t *)gctx;
@@ -1133,28 +1275,35 @@ maildir_close( store_t *gctx )
 					if (errno == ENOENT)
 						retry = 1;
 					else
-						perror( buf );
+						sys_error( "Maildir error: cannot remove %s", buf );
 				} else {
 					msg->status |= M_DEAD;
 					gctx->count--;
 #ifdef USE_DB
 					if (ctx->db && (ret = maildir_purge_msg( ctx, ((maildir_message_t *)msg)->base )) != DRV_OK)
-						return ret;
+						return cb( ret, aux );
 #endif /* USE_DB */
 				}
 			}
 		if (!retry)
-			return DRV_OK;
+			return cb( DRV_OK, aux );
 		if ((ret = maildir_rescan( (maildir_store_t *)gctx )) != DRV_OK)
-			return ret;
+			return cb( ret, aux );
 	}
 }
 
-static int
-maildir_check( store_t *gctx )
+static void
+maildir_cancel( store_t *gctx,
+                void (*cb)( void *aux ), void *aux )
+{
+	(void)gctx;
+	cb( aux );
+}
+
+static void
+maildir_commit( store_t *gctx )
 {
 	(void) gctx;
-	return DRV_OK;
 }
 
 static int
@@ -1177,6 +1326,8 @@ maildir_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 		else if (!strcasecmp( "AltMap", cfg->cmd ))
 			store->alt_map = parse_bool( cfg );
 #endif /* USE_DB */
+		else if (!strcasecmp( "Trash", cfg->cmd ))
+			store->gen.trash = maildir_join_path( "", cfg->val );
 		else
 			parse_generic_store( &store->gen, cfg, err );
 	if (!store->inbox)
@@ -1186,16 +1337,23 @@ maildir_parse_store( conffile_t *cfg, store_conf_t **storep, int *err )
 }
 
 struct driver maildir_driver = {
+	0, /* XXX DRV_CRLF? */
 	maildir_parse_store,
+	maildir_cleanup_drv,
 	maildir_open_store,
-	maildir_close_store,
+	maildir_disown_store,
+	maildir_own_store,
+	maildir_disown_store, /* _cancel_, but it's the same */
 	maildir_list,
-	maildir_prepare,
+	maildir_prepare_opts,
 	maildir_select,
+	maildir_load,
 	maildir_fetch_msg,
 	maildir_store_msg,
+	maildir_find_new_msgs,
 	maildir_set_flags,
 	maildir_trash_msg,
-	maildir_check,
-	maildir_close
+	maildir_close,
+	maildir_cancel,
+	maildir_commit,
 };
diff --git src/isync.h src/isync.h
index 147702b..617cdad 100644
--- src/isync.h
+++ src/isync.h
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -31,6 +30,9 @@
 
 #define as(ar) (sizeof(ar)/sizeof(ar[0]))
 
+#define __stringify(x) #x
+#define stringify(x) __stringify(x)
+
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
 # define ATTR_UNUSED __attribute__((unused))
 # define ATTR_NORETURN __attribute__((noreturn))
@@ -41,8 +43,72 @@
 # define ATTR_PRINTFLIKE(fmt,var)
 #endif
 
+#ifdef __GNUC__
+# define INLINE __inline__
+#else
+# define INLINE
+#endif
+
 #define EXE "mbsync"
 
+typedef struct ssl_st SSL;
+typedef struct ssl_ctx_st SSL_CTX;
+typedef struct x509_store_st X509_STORE;
+
+typedef struct server_conf {
+	char *tunnel;
+	char *host;
+	int port;
+#ifdef HAVE_LIBSSL
+	char *cert_file;
+	unsigned use_imaps:1;
+	unsigned use_sslv2:1;
+	unsigned use_sslv3:1;
+	unsigned use_tlsv1:1;
+
+	/* these are actually variables and are leaked at the end */
+	SSL_CTX *SSLContext;
+	X509_STORE *cert_store;
+#endif
+} server_conf_t;
+
+typedef struct buff_chunk {
+	struct buff_chunk *next;
+	char *data;
+	int len;
+	char buf[1];
+} buff_chunk_t;
+
+typedef struct {
+	/* connection */
+	int fd;
+	int state;
+	const server_conf_t *conf; /* needed during connect */
+	char *name;
+#ifdef HAVE_LIBSSL
+	SSL *ssl;
+#endif
+
+	void (*bad_callback)( void *aux ); /* async fail while sending or listening */
+	void (*read_callback)( void *aux ); /* data available for reading */
+	int (*write_callback)( void *aux ); /* all *queued* data was sent */
+	union {
+		void (*connect)( int ok, void *aux );
+		int (*starttls)( int ok, void *aux );
+	} callbacks;
+	void *callback_aux;
+
+	/* writing */
+	buff_chunk_t *write_buf, **write_buf_append; /* buffer head & tail */
+	int write_offset; /* offset into buffer head */
+
+	/* reading */
+	int offset; /* start of filled bytes in buffer */
+	int bytes; /* number of filled bytes in buffer */
+	int scanoff; /* offset to continue scanning for newline at, relative to 'offset' */
+	char buf[100000];
+} conn_t;
+
 typedef struct {
 	const char *file;
 	FILE *fp;
@@ -73,8 +139,8 @@ typedef struct store_conf {
 	char *name;
 	driver_t *driver;
 	const char *path; /* should this be here? its interpretation is driver-specific */
-	char *map_inbox;
-	char *trash;
+	const char *map_inbox;
+	const char *trash;
 	unsigned max_size; /* off_t is overkill */
 	unsigned trash_remote_new:1, trash_only_new:1;
 } store_conf_t;
@@ -84,20 +150,23 @@ typedef struct string_list {
 	char string[1];
 } string_list_t;
 
+#define M 0 /* master */
+#define S 1 /* slave */
+
 typedef struct channel_conf {
 	struct channel_conf *next;
-	char *name;
-	store_conf_t *master, *slave;
-	char *master_name, *slave_name;
+	const char *name;
+	store_conf_t *stores[2];
+	const char *boxes[2];
 	char *sync_state;
 	string_list_t *patterns;
-	int mops, sops;
+	int ops[2];
 	unsigned max_messages; /* for slave only */
 } channel_conf_t;
 
 typedef struct group_conf {
 	struct group_conf *next;
-	char *name;
+	const char *name;
 	string_list_t *channels;
 } group_conf_t;
 
@@ -115,16 +184,17 @@ typedef struct group_conf {
 #define M_RECENT       (1<<0) /* unsyncable flag; maildir_* depend on this being 1<<0 */
 #define M_DEAD         (1<<1) /* expunged */
 #define M_FLAGS        (1<<2) /* flags fetched */
-#define M_PROCESSED    (1<<3) /* registered in pair */
-#define M_NOT_SYNCED   (1<<4) /* not in remote mailbox, yet */
-#define M_EXPIRED      (1<<5) /* kicked out by MaxMessages */
+
+#define TUIDL 12
 
 typedef struct message {
 	struct message *next;
+	struct sync_rec *srec;
 	/* string_list_t *keywords; */
 	size_t size; /* zero implies "not fetched" */
 	int uid;
 	unsigned char flags, status;
+	char tuid[TUIDL];
 } message_t;
 
 /* For opts, both in store and driver_t->select() */
@@ -132,50 +202,158 @@ typedef struct message {
 #define OPEN_NEW        (1<<1)
 #define OPEN_FLAGS      (1<<2)
 #define OPEN_SIZE       (1<<3)
-#define OPEN_CREATE     (1<<4)
 #define OPEN_EXPUNGE    (1<<5)
 #define OPEN_SETFLAGS   (1<<6)
 #define OPEN_APPEND     (1<<7)
+#define OPEN_FIND       (1<<8)
 
 typedef struct store {
+	struct store *next;
 	store_conf_t *conf; /* foreign */
+	string_list_t *boxes; /* _list results - own */
+	unsigned listed:1; /* was _list already run? */
+
+	void (*bad_callback)( void *aux );
+	void *bad_callback_aux;
 
 	/* currently open mailbox */
 	const char *name; /* foreign! maybe preset? */
 	char *path; /* own */
 	message_t *msgs; /* own */
 	int uidvalidity;
-	unsigned char opts; /* maybe preset? */
+	int uidnext; /* from SELECT responses */
+	unsigned opts; /* maybe preset? */
 	/* note that the following do _not_ reflect stats from msgs, but mailbox totals */
 	int count; /* # of messages */
 	int recent; /* # of recent messages - don't trust this beyond the initial read */
 } store_t;
 
+/* When the callback is invoked (at most once per store), the store is fubar;
+ * call the driver's cancel_store() to dispose of it. */
+static INLINE void
+set_bad_callback( store_t *ctx, void (*cb)( void *aux ), void *aux )
+{
+	ctx->bad_callback = cb;
+	ctx->bad_callback_aux = aux;
+}
+
 typedef struct {
 	char *data;
 	int len;
 	unsigned char flags;
-	unsigned char crlf:1;
 } msg_data_t;
 
 #define DRV_OK          0
-#define DRV_MSG_BAD     -1
-#define DRV_BOX_BAD     -2
-#define DRV_STORE_BAD   -3
+/* Message went missing, or mailbox is full, etc. */
+#define DRV_MSG_BAD     1
+/* Something is wrong with the current mailbox - probably it's somehow inaccessible. */
+#define DRV_BOX_BAD     2
+/* The command has been cancel()ed or cancel_store()d. */
+#define DRV_CANCELED    3
+
+/* All memory belongs to the driver's user, unless stated otherwise. */
+
+/* A negative return value from a function or a callback indicates an error condition
+ * which has already been handled; the shortest route out of the call stack should be
+ * taken as a consequence. */
+
+/*
+   This flag says that the driver CAN store messages with CRLFs,
+   not that it must. The lack of it OTOH implies that it CANNOT,
+   and as CRLF is the canonical format, we convert.
+*/
+#define DRV_CRLF        1
+
+#define LIST_PATH       1
+#define LIST_INBOX      2
 
 struct driver {
+	int flags;
+
+	/* Parse configuration. */
 	int (*parse_store)( conffile_t *cfg, store_conf_t **storep, int *err );
-	store_t *(*open_store)( store_conf_t *conf, store_t *oldctx );
-	void (*close_store)( store_t *ctx );
-	int (*list)( store_t *ctx, string_list_t **boxes );
-	void (*prepare)( store_t *ctx, int opts );
-	int (*select)( store_t *ctx, int minuid, int maxuid, int *excs, int nexcs );
-	int (*fetch_msg)( store_t *ctx, message_t *msg, msg_data_t *data );
-	int (*store_msg)( store_t *ctx, msg_data_t *data, int *uid ); /* if uid is null, store to trash */
-	int (*set_flags)( store_t *ctx, message_t *msg, int uid, int add, int del ); /* msg can be null, therefore uid as a fallback */
-	int (*trash_msg)( store_t *ctx, message_t *msg ); /* This may expunge the original message immediately, but it needn't to */
-	int (*check)( store_t *ctx ); /* IMAP-style: flush */
-	int (*close)( store_t *ctx ); /* IMAP-style: expunge inclusive */
+
+	/* Close remaining server connections. All stores must be disowned first. */
+	void (*cleanup)( void );
+
+	/* Open a store with the given configuration. This may recycle existing
+	 * server connections. Upon failure, a null store is passed to the callback. */
+	void (*open_store)( store_conf_t *conf,
+	                    int (*cb)( store_t *ctx, void *aux ), void *aux );
+
+	/* Mark the store as available for recycling. Server connection may be kept alive. */
+	void (*disown_store)( store_t *ctx );
+
+	/* Try to recycle a store with the given configuration. */
+	store_t *(*own_store)( store_conf_t *conf );
+
+	/* Discard the store after a bad_callback. The server connections will be closed.
+	 * Pending commands will have their callbacks synchronously invoked with DRV_CANCELED. */
+	void (*cancel_store)( store_t *ctx );
+
+	/* List the mailboxes in this store. Flags are ORed LIST_* values. */
+	int (*list)( store_t *ctx, int flags,
+	             int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Invoked before select(), this informs the driver which operations (OP_*)
+	 * will be performed on the mailbox. The driver may extend the set by implicitly
+	 * needed or available operations. */
+	void (*prepare_opts)( store_t *ctx, int opts );
+
+	/* Open the mailbox ctx->name. Optionally create missing boxes.
+	 * As a side effect, this should resolve ctx->path if applicable. */
+	int (*select)( store_t *ctx, int create,
+	               int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Load the message attributes needed to perform the requested operations.
+	 * Consider only messages with UIDs between minuid and maxuid (inclusive)
+	 * and those named in the excs array (smaller than minuid).
+	 * The driver takes ownership of the excs array. Messages below newuid do not need
+	 * to have the TUID populated even if OPEN_FIND is set. */
+	int (*load)( store_t *ctx, int minuid, int maxuid, int newuid, int *excs, int nexcs,
+	             int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Fetch the contents and flags of the given message from the current mailbox. */
+	int (*fetch_msg)( store_t *ctx, message_t *msg, msg_data_t *data,
+	                  int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Store the given message to either the current mailbox or the trash folder.
+	 * If the new copy's UID can be immediately determined, return it, otherwise -1. */
+	int (*store_msg)( store_t *ctx, msg_data_t *data, int to_trash,
+	                  int (*cb)( int sts, int uid, void *aux ), void *aux );
+
+	/* Index the messages which have newly appeared in the mailbox, including their
+	 * temporary UID headers. This is needed if store_msg() does not guarantee returning
+	 * a UID; otherwise the driver needs to implement only the OPEN_FIND flag. */
+	int (*find_new_msgs)( store_t *ctx,
+	                      int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Add/remove the named flags to/from the given message. The message may be either
+	 * a pre-fetched one (in which case the in-memory representation is updated),
+	 * or it may be identifed by UID only. The operation may be delayed until commit()
+	 * is called. */
+	int (*set_flags)( store_t *ctx, message_t *msg, int uid, int add, int del,
+	                  int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Move the given message from the current mailbox to the trash folder.
+	 * This may expunge the original message immediately, but it needn't to. */
+	int (*trash_msg)( store_t *ctx, message_t *msg,
+	                  int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Expunge deleted messages from the current mailbox and close it.
+	 * There is no need to explicitly close a mailbox if no expunge is needed. */
+	int (*close)( store_t *ctx,
+	              int (*cb)( int sts, void *aux ), void *aux );
+
+	/* Cancel queued commands which are not in flight yet; they will have their
+	 * callbacks invoked with DRV_CANCELED. Afterwards, wait for the completion of
+	 * the in-flight commands. If the store is canceled before this command completes,
+	 * the callback will *not* be invoked. */
+	void (*cancel)( store_t *ctx,
+	                void (*cb)( void *aux ), void *aux );
+
+	/* Commit any pending set_flags() commands. */
+	void (*commit)( store_t *ctx );
 };
 
 
@@ -186,14 +364,56 @@ extern char Hostname[256];
 extern const char *Home;
 
 
+/* socket.c */
+
+/* call this before doing anything with the socket */
+static INLINE void socket_init( conn_t *conn,
+                                const server_conf_t *conf,
+                                void (*bad_callback)( void *aux ),
+                                void (*read_callback)( void *aux ),
+                                int (*write_callback)( void *aux ),
+                                void *aux )
+{
+	conn->conf = conf;
+	conn->bad_callback = bad_callback;
+	conn->read_callback = read_callback;
+	conn->write_callback = write_callback;
+	conn->callback_aux = aux;
+	conn->fd = -1;
+	conn->name = 0;
+	conn->write_buf_append = &conn->write_buf;
+}
+void socket_connect( conn_t *conn, void (*cb)( int ok, void *aux ) );
+int socket_start_tls( conn_t *conn, int (*cb)( int ok, void *aux ) );
+void socket_close( conn_t *sock );
+int socket_read( conn_t *sock, char *buf, int len ); /* never waits */
+char *socket_read_line( conn_t *sock ); /* don't free return value; never waits */
+typedef enum { KeepOwn = 0, GiveOwn } ownership_t;
+int socket_write( conn_t *sock, char *buf, int len, ownership_t takeOwn );
+
+void cram( const char *challenge, const char *user, const char *pass,
+           char **_final, int *_finallen );
+
+
 /* util.c */
 
-extern int Verbose, Quiet, Debug;
+#define DEBUG        1
+#define VERBOSE      2
+#define XVERBOSE     4
+#define QUIET        8
+#define VERYQUIET    16
+#define KEEPJOURNAL  32
+
+extern int DFlags;
 
-void debug( const char *, ... );
-void info( const char *, ... );
-void infoc( char );
-void warn( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) debug( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) debugn( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) info( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) infon( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) warn( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) error( const char *, ... );
+void ATTR_PRINTFLIKE(1, 2) sys_error( const char *, ... );
+void flushn( void );
 
 char *next_arg( char ** );
 
@@ -202,15 +422,13 @@ void free_string_list( string_list_t *list );
 
 void free_generic_messages( message_t * );
 
-void strip_cr( msg_data_t *msgdata );
-
 void *nfmalloc( size_t sz );
 void *nfcalloc( size_t sz );
 void *nfrealloc( void *mem, size_t sz );
 char *nfstrdup( const char *str );
 int nfvasprintf( char **str, const char *fmt, va_list va );
-int nfasprintf( char **str, const char *fmt, ... );
-int nfsnprintf( char *buf, int blen, const char *fmt, ... );
+int ATTR_PRINTFLIKE(2, 3) nfasprintf( char **str, const char *fmt, ... );
+int ATTR_PRINTFLIKE(3, 4) nfsnprintf( char *buf, int blen, const char *fmt, ... );
 void ATTR_NORETURN oob( void );
 
 char *expand_strdup( const char *s );
@@ -220,29 +438,49 @@ void sort_ints( int *arr, int len );
 void arc4_init( void );
 unsigned char arc4_getbyte( void );
 
+#ifdef HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#else
+# define POLLIN 1
+# define POLLOUT 4
+# define POLLERR 8
+#endif
+
+void add_fd( int fd, void (*cb)( int events, void *aux ), void *aux );
+void conf_fd( int fd, int and_events, int or_events );
+void fake_fd( int fd, int events );
+void del_fd( int fd );
+void main_loop( void );
+
 /* sync.c */
 
-#define SYNC_OK           0
-#define SYNC_FAIL         1
-#define SYNC_MASTER_BAD   2
-#define SYNC_SLAVE_BAD    3
+extern const char *str_ms[2], *str_hl[2];
 
-int sync_boxes( store_t *, const char *,
-                store_t *, const char *,
-                channel_conf_t * );
+#define SYNC_OK       0 /* assumed to be 0 */
+#define SYNC_FAIL     1
+#define SYNC_BAD(ms)  (2<<(ms))
+#define SYNC_NOGOOD   8 /* internal */
+#define SYNC_CANCELED 16 /* internal */
+
+/* All passed pointers must stay alive until cb is called. */
+void sync_boxes( store_t *ctx[], const char *names[], channel_conf_t *chan,
+                 void (*cb)( int sts, void *aux ), void *aux );
 
 /* config.c */
 
+#define N_DRIVERS 2
+extern driver_t *drivers[N_DRIVERS];
+
 extern channel_conf_t *channels;
 extern group_conf_t *groups;
-extern int global_mops, global_sops;
+extern int global_ops[2];
 extern char *global_sync_state;
 
 int parse_bool( conffile_t *cfile );
 int parse_int( conffile_t *cfile );
 int parse_size( conffile_t *cfile );
 int getcline( conffile_t *cfile );
-int merge_ops( int cops, int *mops, int *sops );
+int merge_ops( int cops, int ops[] );
 int load_config( const char *filename, int pseudo );
 void parse_generic_store( store_conf_t *store, conffile_t *cfg, int *err );
 
diff --git src/main.c src/main.c
index 3aa0038..6b1221b 100644
--- src/main.c
+++ src/main.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -24,8 +23,12 @@
 #include "isync.h"
 
 #include <stdlib.h>
+#include <stddef.h>
 #include <unistd.h>
 #include <string.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/wait.h>
 
 int Pid;		/* for maildir and imap */
 char Hostname[256];	/* for maildir */
@@ -44,7 +47,7 @@ usage( int code )
 	fputs(
 PACKAGE " " VERSION " - mailbox synchronizer\n"
 "Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>\n"
-"Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>\n"
+"Copyright (C) 2002-2006,2008,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>\n"
 "Copyright (C) 2004 Theodore Ts'o <tytso@mit.edu>\n"
 "usage:\n"
 " " EXE " [flags] {{channel[:box,...]|group} ...|-a}\n"
@@ -70,7 +73,7 @@ PACKAGE " " VERSION " - mailbox synchronizer\n"
 "--create and --expunge can be suffixed with -master/-slave. Read the man page.\n"
 "\nSupported mailbox formats are: IMAP4rev1, Maildir\n"
 "\nCompile time options:\n"
-#if HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
 "  +HAVE_LIBSSL\n"
 #else
 "  -HAVE_LIBSSL\n"
@@ -79,6 +82,36 @@ PACKAGE " " VERSION " - mailbox synchronizer\n"
 	exit( code );
 }
 
+#ifdef __linux__
+static void
+crashHandler( int n )
+{
+	int dpid;
+	char pbuf[10], pabuf[20];
+
+	close( 0 );
+	open( "/dev/tty", O_RDWR );
+	dup2( 0, 1 );
+	dup2( 0, 2 );
+	error( "*** " EXE " caught signal %d. Starting debugger ...\n", n );
+	switch ((dpid = fork())) {
+	case -1:
+		perror( "fork()" );
+		break;
+	case 0:
+		sprintf( pbuf, "%d", Pid );
+		sprintf( pabuf, "/proc/%d/exe", Pid );
+		execlp( "gdb", "gdb", pabuf, pbuf, (char *)0 );
+		perror( "execlp()" );
+		_exit( 1 );
+	default:
+		waitpid( dpid, 0, 0 );
+		break;
+	}
+	exit( 3 );
+}
+#endif
+
 static int
 matches( const char *t, const char *p )
 {
@@ -95,7 +128,7 @@ matches( const char *t, const char *p )
 		} else if (*p == '%') {
 			p++;
 			do {
-				if (*t == '.' || *t == '/') /* this is "somewhat" hacky ... */
+				if (*t == '/')
 					return 0;
 				if (matches( t, p ))
 					return 1;
@@ -137,36 +170,54 @@ filter_boxes( string_list_t *boxes, string_list_t *patterns )
 }
 
 static void
-merge_actions( channel_conf_t *chan, int mops, int sops, int have, int mask, int def )
+merge_actions( channel_conf_t *chan, int ops[], int have, int mask, int def )
 {
-	if (mops & have) {
-		chan->mops &= ~mask;
-		chan->mops |= mops & mask;
-		chan->sops &= ~mask;
-		chan->sops |= sops & mask;
-	} else if (!(chan->mops & have)) {
-		if (global_mops & have) {
-			chan->mops |= global_mops & mask;
-			chan->sops |= global_sops & mask;
+	if (ops[M] & have) {
+		chan->ops[M] &= ~mask;
+		chan->ops[M] |= ops[M] & mask;
+		chan->ops[S] &= ~mask;
+		chan->ops[S] |= ops[S] & mask;
+	} else if (!(chan->ops[M] & have)) {
+		if (global_ops[M] & have) {
+			chan->ops[M] |= global_ops[M] & mask;
+			chan->ops[S] |= global_ops[S] & mask;
 		} else {
-			chan->mops |= def;
-			chan->sops |= def;
+			chan->ops[M] |= def;
+			chan->ops[S] |= def;
 		}
 	}
 }
 
+typedef struct {
+	int t[2];
+	channel_conf_t *chan;
+	driver_t *drv[2];
+	store_t *ctx[2];
+	string_list_t *boxes[2], *cboxes, *chanptr;
+	const char *names[2];
+	char **argv, *boxlist, *boxp;
+	int oind, ret, multiple, all, list, ops[2], state[2];
+	unsigned done:1, skip:1, cben:1;
+} main_vars_t;
+
+#define AUX &mvars->t[t]
+#define MVARS(aux) \
+	int t = *(int *)aux; \
+	main_vars_t *mvars = (main_vars_t *)(((char *)(&((int *)aux)[-t])) - offsetof(main_vars_t, t));
+
+#define E_START  0
+#define E_OPEN   1
+#define E_SYNC   2
+
+static int sync_chans( main_vars_t *mvars, int ent );
+
 int
 main( int argc, char **argv )
 {
-	channel_conf_t *chan;
-	store_conf_t *mconf, *sconf;
+	main_vars_t mvars[1];
 	group_conf_t *group;
-	driver_t *mdriver, *sdriver;
-	store_t *mctx, *sctx;
-	string_list_t *umboxes, *usboxes, *mboxes, *sboxes, *mbox, *sbox, **mboxp, **sboxp, *cboxes, *chanptr;
-	char *config = 0, *channame, *boxlist, *opt, *ochar;
-	int all = 0, list = 0, cops = 0, mops = 0, sops = 0, gumboxes, gusboxes;
-	int oind, ret, op, multiple, pseudo = 0;
+	char *config = 0, *opt, *ochar;
+	int cops = 0, op, pseudo = 0;
 
 	gethostname( Hostname, sizeof(Hostname) );
 	if ((ochar = strchr( Hostname, '.' )))
@@ -178,46 +229,51 @@ main( int argc, char **argv )
 	}
 	arc4_init();
 
-	for (oind = 1, ochar = 0; ; ) {
+	memset( mvars, 0, sizeof(*mvars) );
+	mvars->t[1] = 1;
+
+	for (mvars->oind = 1, ochar = 0; ; ) {
 		if (!ochar || !*ochar) {
-			if (oind >= argc)
+			if (mvars->oind >= argc)
 				break;
-			if (argv[oind][0] != '-')
+			if (argv[mvars->oind][0] != '-')
 				break;
-			if (argv[oind][1] == '-') {
-				opt = argv[oind++] + 2;
+			if (argv[mvars->oind][1] == '-') {
+				opt = argv[mvars->oind++] + 2;
 				if (!*opt)
 					break;
 				if (!strcmp( opt, "config" )) {
-					if (oind >= argc) {
-						fprintf( stderr, "--config requires an argument.\n" );
+					if (mvars->oind >= argc) {
+						error( "--config requires an argument.\n" );
 						return 1;
 					}
-					config = argv[oind++];
+					config = argv[mvars->oind++];
 				} else if (!memcmp( opt, "config=", 7 ))
 					config = opt + 7;
 				else if (!strcmp( opt, "all" ))
-					all = 1;
+					mvars->all = 1;
 				else if (!strcmp( opt, "list" ))
-					list = 1;
+					mvars->list = 1;
 				else if (!strcmp( opt, "help" ))
 					usage( 0 );
 				else if (!strcmp( opt, "version" ))
 					version();
-				else if (!strcmp( opt, "quiet" ))
-					Quiet++;
-				else if (!strcmp( opt, "verbose" )) {
-					Verbose = 1;
-					if (!Quiet)
-						Quiet = 1;
-				} else if (!strcmp( opt, "debug" )) {
-					Debug = 1;
-					if (!Quiet)
-						Quiet = 1;
-				} else if (!strcmp( opt, "pull" ))
-					cops |= XOP_PULL, mops |= XOP_HAVE_TYPE;
+				else if (!strcmp( opt, "quiet" )) {
+					if (DFlags & QUIET)
+						DFlags |= VERYQUIET;
+					else
+						DFlags |= QUIET;
+				} else if (!strcmp( opt, "verbose" )) {
+					if (DFlags & VERBOSE)
+						DFlags |= XVERBOSE;
+					else
+						DFlags |= VERBOSE | QUIET;
+				} else if (!strcmp( opt, "debug" ))
+					DFlags |= DEBUG | QUIET;
+				else if (!strcmp( opt, "pull" ))
+					cops |= XOP_PULL, mvars->ops[M] |= XOP_HAVE_TYPE;
 				else if (!strcmp( opt, "push" ))
-					cops |= XOP_PUSH, mops |= XOP_HAVE_TYPE;
+					cops |= XOP_PUSH, mvars->ops[M] |= XOP_HAVE_TYPE;
 				else if (!memcmp( opt, "create", 6 )) {
 					opt += 6;
 					op = OP_CREATE|XOP_HAVE_CREATE;
@@ -225,24 +281,24 @@ main( int argc, char **argv )
 					if (!*opt)
 						cops |= op;
 					else if (!strcmp( opt, "-master" ))
-						mops |= op, ochar++;
+						mvars->ops[M] |= op, ochar++;
 					else if (!strcmp( opt, "-slave" ))
-						sops |= op, ochar++;
+						mvars->ops[S] |= op, ochar++;
 					else
 						goto badopt;
-					mops |= op & (XOP_HAVE_CREATE|XOP_HAVE_EXPUNGE);
+					mvars->ops[M] |= op & (XOP_HAVE_CREATE|XOP_HAVE_EXPUNGE);
 				} else if (!memcmp( opt, "expunge", 7 )) {
 					opt += 7;
 					op = OP_EXPUNGE|XOP_HAVE_EXPUNGE;
 					goto lcop;
 				} else if (!strcmp( opt, "no-expunge" ))
-					mops |= XOP_HAVE_EXPUNGE;
+					mvars->ops[M] |= XOP_HAVE_EXPUNGE;
 				else if (!strcmp( opt, "no-create" ))
-					mops |= XOP_HAVE_CREATE;
+					mvars->ops[M] |= XOP_HAVE_CREATE;
 				else if (!strcmp( opt, "full" ))
-					mops |= XOP_HAVE_TYPE|XOP_PULL|XOP_PUSH;
+					mvars->ops[M] |= XOP_HAVE_TYPE|XOP_PULL|XOP_PUSH;
 				else if (!strcmp( opt, "noop" ))
-					mops |= XOP_HAVE_TYPE;
+					mvars->ops[M] |= XOP_HAVE_TYPE;
 				else if (!memcmp( opt, "pull", 4 )) {
 					op = XOP_PULL;
 				  lcac:
@@ -270,54 +326,54 @@ main( int argc, char **argv )
 						op |= OP_FLAGS;
 					else {
 					  badopt:
-						fprintf( stderr, "Unknown option '%s'\n", argv[oind - 1] );
+						error( "Unknown option '%s'\n", argv[mvars->oind - 1] );
 						return 1;
 					}
 					switch (op & XOP_MASK_DIR) {
-					case XOP_PULL: sops |= op & OP_MASK_TYPE; break;
-					case XOP_PUSH: mops |= op & OP_MASK_TYPE; break;
+					case XOP_PULL: mvars->ops[S] |= op & OP_MASK_TYPE; break;
+					case XOP_PUSH: mvars->ops[M] |= op & OP_MASK_TYPE; break;
 					default: cops |= op; break;
 					}
-					mops |= XOP_HAVE_TYPE;
+					mvars->ops[M] |= XOP_HAVE_TYPE;
 				}
 				continue;
 			}
-			ochar = argv[oind++] + 1;
+			ochar = argv[mvars->oind++] + 1;
 			if (!*ochar) {
-				fprintf( stderr, "Invalid option '-'\n" );
+				error( "Invalid option '-'\n" );
 				return 1;
 			}
 		}
 		switch (*ochar++) {
 		case 'a':
-			all = 1;
+			mvars->all = 1;
 			break;
 		case 'l':
-			list = 1;
+			mvars->list = 1;
 			break;
 		case 'c':
 			if (*ochar == 'T') {
 				ochar++;
 				pseudo = 1;
 			}
-			if (oind >= argc) {
-				fprintf( stderr, "-c requires an argument.\n" );
+			if (mvars->oind >= argc) {
+				error( "-c requires an argument.\n" );
 				return 1;
 			}
-			config = argv[oind++];
+			config = argv[mvars->oind++];
 			break;
 		case 'C':
 			op = OP_CREATE|XOP_HAVE_CREATE;
 		  cop:
 			if (*ochar == 'm')
-				mops |= op, ochar++;
+				mvars->ops[M] |= op, ochar++;
 			else if (*ochar == 's')
-				sops |= op, ochar++;
+				mvars->ops[S] |= op, ochar++;
 			else if (*ochar == '-')
 				ochar++;
 			else
 				cops |= op;
-			mops |= op & (XOP_HAVE_CREATE|XOP_HAVE_EXPUNGE);
+			mvars->ops[M] |= op & (XOP_HAVE_CREATE|XOP_HAVE_EXPUNGE);
 			break;
 		case 'X':
 			op = OP_EXPUNGE|XOP_HAVE_EXPUNGE;
@@ -325,7 +381,7 @@ main( int argc, char **argv )
 		case 'F':
 			cops |= XOP_PULL|XOP_PUSH;
 		case '0':
-			mops |= XOP_HAVE_TYPE;
+			mvars->ops[M] |= XOP_HAVE_TYPE;
 			break;
 		case 'n':
 		case 'd':
@@ -348,13 +404,13 @@ main( int argc, char **argv )
 			}
 			if (op & OP_MASK_TYPE)
 				switch (op & XOP_MASK_DIR) {
-				case XOP_PULL: sops |= op & OP_MASK_TYPE; break;
-				case XOP_PUSH: mops |= op & OP_MASK_TYPE; break;
+				case XOP_PULL: mvars->ops[S] |= op & OP_MASK_TYPE; break;
+				case XOP_PUSH: mvars->ops[M] |= op & OP_MASK_TYPE; break;
 				default: cops |= op; break;
 				}
 			else
 				cops |= op;
-			mops |= XOP_HAVE_TYPE;
+			mvars->ops[M] |= XOP_HAVE_TYPE;
 			break;
 		case 'L':
 			op = XOP_PULL;
@@ -363,35 +419,48 @@ main( int argc, char **argv )
 			op = XOP_PUSH;
 			goto cac;
 		case 'q':
-			Quiet++;
+			if (DFlags & QUIET)
+				DFlags |= VERYQUIET;
+			else
+				DFlags |= QUIET;
 			break;
 		case 'V':
-			Verbose = 1;
-			if (!Quiet)
-				Quiet = 1;
+			if (DFlags & VERBOSE)
+				DFlags |= XVERBOSE;
+			else
+				DFlags |= VERBOSE | QUIET;
 			break;
 		case 'D':
-			Debug = 1;
-			if (!Quiet)
-				Quiet = 1;
+			DFlags |= DEBUG | QUIET;
+			break;
+		case 'J':
+			DFlags |= KEEPJOURNAL;
 			break;
 		case 'v':
 			version();
 		case 'h':
 			usage( 0 );
 		default:
-			fprintf( stderr, "Unknown option '-%c'\n", *(ochar - 1) );
+			error( "Unknown option '-%c'\n", *(ochar - 1) );
 			return 1;
 		}
 	}
 
-	if (merge_ops( cops, &mops, &sops ))
+#ifdef __linux__
+	if (DFlags & DEBUG) {
+		signal( SIGSEGV, crashHandler );
+		signal( SIGBUS, crashHandler );
+		signal( SIGILL, crashHandler );
+	}
+#endif
+
+	if (merge_ops( cops, mvars->ops ))
 		return 1;
 
 	if (load_config( config, pseudo ))
 		return 1;
 
-	if (!all && !argv[oind]) {
+	if (!mvars->all && !argv[mvars->oind]) {
 		fputs( "No channel specified. Try '" EXE " -h'\n", stderr );
 		return 1;
 	}
@@ -400,216 +469,297 @@ main( int argc, char **argv )
 		return 1;
 	}
 
-	ret = 0;
-	chan = channels;
-	chanptr = 0;
-	mctx = sctx = 0;
-	mconf = sconf = 0;	/* make-gcc-happy */
-	mdriver = sdriver = 0;	/* make-gcc-happy */
-	gumboxes = gusboxes = 0;
-	umboxes = usboxes = 0;
-	if (all)
-		multiple = channels->next != 0;
-	else if (argv[oind + 1])
-		multiple = 1;
-	else {
-		multiple = 0;
+	mvars->chan = channels;
+	if (mvars->all)
+		mvars->multiple = channels->next != 0;
+	else if (argv[mvars->oind + 1])
+		mvars->multiple = 1;
+	else
 		for (group = groups; group; group = group->next)
-			if (!strcmp( group->name, argv[oind] )) {
-				multiple = 1;
+			if (!strcmp( group->name, argv[mvars->oind] )) {
+				mvars->multiple = 1;
 				break;
 			}
+	mvars->argv = argv;
+	mvars->cben = 1;
+	sync_chans( mvars, E_START );
+	main_loop();
+	return mvars->ret;
+}
+
+#define ST_FRESH     0
+#define ST_OPEN      1
+#define ST_CLOSED    2
+
+static int store_opened( store_t *ctx, void *aux );
+static int store_listed( int sts, void *aux );
+static void done_sync_dyn( int sts, void *aux );
+static void done_sync( int sts, void *aux );
+
+#define nz(a,b) ((a)?(a):(b))
+
+static int
+sync_chans( main_vars_t *mvars, int ent )
+{
+	group_conf_t *group;
+	channel_conf_t *chan;
+	store_t *store;
+	string_list_t *mbox, *sbox, **mboxp, **sboxp;
+	char *channame;
+	int t;
+
+	if (!mvars->cben)
+		return 0;
+	switch (ent) {
+	case E_OPEN: goto opened;
+	case E_SYNC: goto syncone;
 	}
 	for (;;) {
-		boxlist = 0;
-		if (!all) {
-			if (chanptr)
-				channame = chanptr->string;
+		mvars->boxlist = 0;
+		if (!mvars->all) {
+			if (mvars->chanptr)
+				channame = mvars->chanptr->string;
 			else {
 				for (group = groups; group; group = group->next)
-					if (!strcmp( group->name, argv[oind] )) {
-						chanptr = group->channels;
-						channame = chanptr->string;
+					if (!strcmp( group->name, mvars->argv[mvars->oind] )) {
+						mvars->chanptr = group->channels;
+						channame = mvars->chanptr->string;
 						goto gotgrp;
 					}
-				channame = argv[oind];
+				channame = mvars->argv[mvars->oind];
 			  gotgrp: ;
 			}
-			if ((boxlist = strchr( channame, ':' )))
-				*boxlist++ = 0;
+			if ((mvars->boxlist = strchr( channame, ':' )))
+				*mvars->boxlist++ = 0;
 			for (chan = channels; chan; chan = chan->next)
 				if (!strcmp( chan->name, channame ))
 					goto gotchan;
-			fprintf( stderr, "No channel or group named '%s' defined.\n", channame );
-			ret = 1;
+			error( "No channel or group named '%s' defined.\n", channame );
+			mvars->ret = 1;
 			goto gotnone;
-		  gotchan: ;
+		  gotchan:
+			mvars->chan = chan;
 		}
-		merge_actions( chan, mops, sops, XOP_HAVE_TYPE, OP_MASK_TYPE, OP_MASK_TYPE );
-		merge_actions( chan, mops, sops, XOP_HAVE_CREATE, OP_CREATE, 0 );
-		merge_actions( chan, mops, sops, XOP_HAVE_EXPUNGE, OP_EXPUNGE, 0 );
-
-		mboxes = sboxes = cboxes = 0;
-		/* possible todo: handle master <-> slave swaps */
-		if (mctx) {
-			if (mconf == chan->master)
-				goto gotmctx;
-			free_string_list( umboxes );
-			umboxes = 0;
-			gumboxes = 0;
-			if (mconf->driver != chan->master->driver) {
-				mdriver->close_store( mctx );
-				mctx = 0;
-			}
-		}
-		mconf = chan->master;
-		mdriver = mconf->driver;
-		if (!(mctx = mdriver->open_store( chan->master, mctx ))) {
-			ret = 1;
-			goto next;
+		merge_actions( mvars->chan, mvars->ops, XOP_HAVE_TYPE, OP_MASK_TYPE, OP_MASK_TYPE );
+		merge_actions( mvars->chan, mvars->ops, XOP_HAVE_CREATE, OP_CREATE, 0 );
+		merge_actions( mvars->chan, mvars->ops, XOP_HAVE_EXPUNGE, OP_EXPUNGE, 0 );
+
+		mvars->state[M] = mvars->state[S] = ST_FRESH;
+		info( "Channel %s\n", mvars->chan->name );
+		mvars->boxes[M] = mvars->boxes[S] = mvars->cboxes = 0;
+		mvars->skip = mvars->cben = 0;
+		for (t = 0; t < 2; t++) {
+			mvars->drv[t] = mvars->chan->stores[t]->driver;
+			if ((store = mvars->drv[t]->own_store( mvars->chan->stores[t] )))
+				store_opened( store, AUX );
 		}
-	  gotmctx:
-		if (sctx) {
-			if (sconf == chan->slave)
-				goto gotsctx;
-			free_string_list( usboxes );
-			usboxes = 0;
-			gusboxes = 0;
-			if (sconf->driver != chan->slave->driver) {
-				sdriver->close_store( sctx );
-				sctx = 0;
+		for (t = 0; t < 2 && !mvars->skip; t++)
+			if (mvars->state[t] == ST_FRESH) {
+				info( "Opening %s %s...\n", str_ms[t], mvars->chan->stores[t]->name );
+				mvars->drv[t]->open_store( mvars->chan->stores[t], store_opened, AUX );
 			}
-		}
-		sconf = chan->slave;
-		sdriver = sconf->driver;
-		if (!(sctx = sdriver->open_store( chan->slave, sctx ))) {
-			ret = 1;
+		mvars->cben = 1;
+	  opened:
+		if (mvars->skip)
 			goto next;
-		}
-	  gotsctx:
-		info( "Channel %s\n", chan->name );
-		if (list && multiple)
-			printf( "%s:\n", chan->name );
-		if (boxlist) {
-			for (boxlist = strtok( boxlist, ",\n" ); boxlist; boxlist = strtok( 0, ",\n" ))
-				if (list)
-					puts( boxlist );
-				else
-					switch (sync_boxes( mctx, boxlist, sctx, boxlist, chan )) {
-					case SYNC_MASTER_BAD: goto screwm;
-					case SYNC_SLAVE_BAD: goto screws;
-					case SYNC_FAIL: ret = 1;
-					}
-		} else if (chan->patterns) {
-			if (!gumboxes) {
-				if (mdriver->list( mctx, &umboxes ) != DRV_OK) {
-				  screwm:
-					mdriver->close_store( mctx );
-					free_string_list( umboxes );
-					umboxes = 0;
-					gumboxes = 0;
-					mctx = 0;
-					ret = 1;
-					goto next;
-				} else {
-					gumboxes = 1;
-					if (mctx->conf->map_inbox)
-						add_string_list( &umboxes, mctx->conf->map_inbox );
-				}
-			}
-			if (!gusboxes) {
-				if (sdriver->list( sctx, &usboxes ) != DRV_OK) {
-				  screws:
-					sdriver->close_store( sctx );
-					free_string_list( usboxes );
-					usboxes = 0;
-					gusboxes = 0;
-					sctx = 0;
-					ret = 1;
-					goto next;
-				} else {
-					gusboxes = 1;
-					if (sctx->conf->map_inbox)
-						add_string_list( &usboxes, sctx->conf->map_inbox );
-				}
-			}
-			mboxes = filter_boxes( umboxes, chan->patterns );
-			sboxes = filter_boxes( usboxes, chan->patterns );
-			for (mboxp = &mboxes; (mbox = *mboxp); ) {
-				for (sboxp = &sboxes; (sbox = *sboxp); sboxp = &sbox->next)
+		if (mvars->state[M] != ST_OPEN || mvars->state[S] != ST_OPEN)
+			return 0;
+
+		if (mvars->boxlist)
+			mvars->boxp = mvars->boxlist;
+		else if (mvars->chan->patterns) {
+			mvars->boxes[M] = filter_boxes( mvars->ctx[M]->boxes, mvars->chan->patterns );
+			mvars->boxes[S] = filter_boxes( mvars->ctx[S]->boxes, mvars->chan->patterns );
+			for (mboxp = &mvars->boxes[M]; (mbox = *mboxp); ) {
+				for (sboxp = &mvars->boxes[S]; (sbox = *sboxp); sboxp = &sbox->next)
 					if (!strcmp( sbox->string, mbox->string )) {
 						*sboxp = sbox->next;
 						free( sbox );
 						*mboxp = mbox->next;
-						mbox->next = cboxes;
-						cboxes = mbox;
+						mbox->next = mvars->cboxes;
+						mvars->cboxes = mbox;
 						goto gotdupe;
 					}
 				mboxp = &mbox->next;
 			  gotdupe: ;
 			}
-			for (mbox = cboxes; mbox; mbox = mbox->next)
-				if (list)
-					puts( mbox->string );
-				else
-					switch (sync_boxes( mctx, mbox->string, sctx, mbox->string, chan )) {
-					case SYNC_MASTER_BAD: goto screwm;
-					case SYNC_SLAVE_BAD: goto screws;
-					case SYNC_FAIL: ret = 1;
-					}
-			if ((chan->sops & OP_MASK_TYPE) && (chan->sops & OP_CREATE)) {
-				for (mbox = mboxes; mbox; mbox = mbox->next)
-					if (list)
-						puts( mbox->string );
-					else
-						switch (sync_boxes( mctx, mbox->string, sctx, mbox->string, chan )) {
-						case SYNC_MASTER_BAD: goto screwm;
-						case SYNC_SLAVE_BAD: goto screws;
-						case SYNC_FAIL: ret = 1;
-						}
+		}
+
+		if (mvars->list && mvars->multiple)
+			printf( "%s:\n", mvars->chan->name );
+	  syncml:
+		mvars->done = mvars->cben = 0;
+	  syncmlx:
+		if (mvars->boxlist) {
+			if ((mvars->names[S] = strsep( &mvars->boxp, ",\n" ))) {
+				if (!*mvars->names[S])
+					mvars->names[S] = 0;
+				if (!mvars->list) {
+					mvars->names[M] = mvars->names[S];
+					sync_boxes( mvars->ctx, mvars->names, mvars->chan, done_sync, mvars );
+					goto syncw;
+				}
+				puts( nz( mvars->names[S], "INBOX" ) );
+				goto syncmlx;
 			}
-			if ((chan->mops & OP_MASK_TYPE) && (chan->mops & OP_CREATE)) {
-				for (mbox = sboxes; mbox; mbox = mbox->next)
-					if (list)
-						puts( mbox->string );
-					else
-						switch (sync_boxes( mctx, mbox->string, sctx, mbox->string, chan )) {
-						case SYNC_MASTER_BAD: goto screwm;
-						case SYNC_SLAVE_BAD: goto screws;
-						case SYNC_FAIL: ret = 1;
-						}
+		} else if (mvars->chan->patterns) {
+			if ((mbox = mvars->cboxes)) {
+				mvars->cboxes = mbox->next;
+				if (!mvars->list) {
+					mvars->names[M] = mvars->names[S] = mbox->string;
+					sync_boxes( mvars->ctx, mvars->names, mvars->chan, done_sync_dyn, mvars );
+					goto syncw;
+				}
+				puts( mbox->string );
+				free( mbox );
+				goto syncmlx;
 			}
-		} else
-			if (list)
-				printf( "%s <=> %s\n", chan->master_name, chan->slave_name );
-			else
-				switch (sync_boxes( mctx, chan->master_name, sctx, chan->slave_name, chan )) {
-				case SYNC_MASTER_BAD: goto screwm;
-				case SYNC_SLAVE_BAD: goto screws;
-				case SYNC_FAIL: ret = 1;
+			for (t = 0; t < 2; t++)
+				if ((mbox = mvars->boxes[t])) {
+					mvars->boxes[t] = mbox->next;
+					if ((mvars->chan->ops[1-t] & OP_MASK_TYPE) && (mvars->chan->ops[1-t] & OP_CREATE)) {
+						if (!mvars->list) {
+							mvars->names[M] = mvars->names[S] = mbox->string;
+							sync_boxes( mvars->ctx, mvars->names, mvars->chan, done_sync_dyn, mvars );
+							goto syncw;
+						}
+						puts( mbox->string );
+					}
+					free( mbox );
+					goto syncmlx;
 				}
+		} else {
+			if (!mvars->list) {
+				sync_boxes( mvars->ctx, mvars->chan->boxes, mvars->chan, done_sync, mvars );
+				mvars->skip = 1;
+			  syncw:
+				mvars->cben = 1;
+				if (!mvars->done)
+					return 0;
+			  syncone:
+				if (!mvars->skip)
+					goto syncml;
+			} else
+				printf( "%s <=> %s\n", nz( mvars->chan->boxes[M], "INBOX" ), nz( mvars->chan->boxes[S], "INBOX" ) );
+		}
 
 	  next:
-		free_string_list( cboxes );
-		free_string_list( mboxes );
-		free_string_list( sboxes );
-		if (all) {
-			if (!(chan = chan->next))
+		for (t = 0; t < 2; t++)
+			if (mvars->state[t] == ST_OPEN) {
+				mvars->drv[t]->disown_store( mvars->ctx[t] );
+				mvars->state[t] = ST_CLOSED;
+			}
+		if (mvars->state[M] != ST_CLOSED || mvars->state[S] != ST_CLOSED) {
+			mvars->skip = mvars->cben = 1;
+			return 0;
+		}
+		free_string_list( mvars->cboxes );
+		free_string_list( mvars->boxes[M] );
+		free_string_list( mvars->boxes[S] );
+		if (mvars->all) {
+			if (!(mvars->chan = mvars->chan->next))
 				break;
 		} else {
-			if (chanptr && (chanptr = chanptr->next))
+			if (mvars->chanptr && (mvars->chanptr = mvars->chanptr->next))
 				continue;
 		  gotnone:
-			if (!argv[++oind])
+			if (!mvars->argv[++mvars->oind])
 				break;
 		}
 	}
-	free_string_list( usboxes );
-	if (sctx)
-		sdriver->close_store( sctx );
-	free_string_list( umboxes );
-	if (mctx)
-		mdriver->close_store( mctx );
-
-	return ret;
+	for (t = 0; t < N_DRIVERS; t++)
+		drivers[t]->cleanup();
+	return -1;
+}
+
+static void
+store_bad( void *aux )
+{
+	MVARS(aux)
+
+	mvars->drv[t]->cancel_store( mvars->ctx[t] );
+	mvars->ret = mvars->skip = 1;
+	mvars->state[t] = ST_CLOSED;
+	sync_chans( mvars, E_OPEN );
+}
+
+static int
+store_opened( store_t *ctx, void *aux )
+{
+	MVARS(aux)
+	string_list_t *cpat;
+	int flags;
+
+	if (!ctx) {
+		mvars->ret = mvars->skip = 1;
+		mvars->state[t] = ST_CLOSED;
+		sync_chans( mvars, E_OPEN );
+		return -1;
+	}
+	mvars->ctx[t] = ctx;
+	if (mvars->skip) {
+		mvars->state[t] = ST_OPEN;
+		return sync_chans( mvars, E_OPEN );
+	}
+	if (!mvars->boxlist && mvars->chan->patterns && !ctx->listed) {
+		for (flags = 0, cpat = mvars->chan->patterns; cpat; cpat = cpat->next) {
+			const char *pat = cpat->string;
+			if (*pat != '!')
+				flags |= (!memcmp( pat, "INBOX", 5 ) && (!pat[5] || pat[5] == '/')) ? LIST_INBOX : LIST_PATH;
+		}
+		set_bad_callback( ctx, store_bad, AUX );
+		return mvars->drv[t]->list( ctx, flags, store_listed, AUX );
+	} else {
+		mvars->state[t] = ST_OPEN;
+		return sync_chans( mvars, E_OPEN );
+	}
+}
+
+static int
+store_listed( int sts, void *aux )
+{
+	MVARS(aux)
+
+	switch (sts) {
+	case DRV_CANCELED:
+		return -1;
+	case DRV_OK:
+		mvars->ctx[t]->listed = 1;
+		if (mvars->ctx[t]->conf->map_inbox)
+			add_string_list( &mvars->ctx[t]->boxes, mvars->ctx[t]->conf->map_inbox );
+		break;
+	default:
+		mvars->ret = mvars->skip = 1;
+		break;
+	}
+	mvars->state[t] = ST_OPEN;
+	return sync_chans( mvars, E_OPEN );
+}
+
+static void
+done_sync_dyn( int sts, void *aux )
+{
+	main_vars_t *mvars = (main_vars_t *)aux;
+
+	free( ((char *)mvars->names[S]) - offsetof(string_list_t, string) );
+	done_sync( sts, aux );
+}
+
+static void
+done_sync( int sts, void *aux )
+{
+	main_vars_t *mvars = (main_vars_t *)aux;
+
+	mvars->done = 1;
+	if (sts) {
+		mvars->ret = 1;
+		if (sts & (SYNC_BAD(M) | SYNC_BAD(S))) {
+			mvars->skip = 1;
+			if (sts & SYNC_BAD(M))
+				mvars->state[M] = ST_CLOSED;
+			if (sts & SYNC_BAD(S))
+				mvars->state[S] = ST_CLOSED;
+		}
+	}
+	sync_chans( mvars, E_SYNC );
 }
diff --git src/mbsync.1 src/mbsync.1
index 14b5c99..07e91dc 100644
--- src/mbsync.1
+++ src/mbsync.1
@@ -15,13 +15,12 @@
 \"  GNU General Public License for more details.
 \"
 \"  You should have received a copy of the GNU General Public License
-\"  along with this program; if not, write to the Free Software
-\"  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\"  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 \"
 \" As a special exception, mbsync may be linked with the OpenSSL library,
 \" despite that library's more restrictive license.
 ..
-.TH mbsync 1 "2004 Mar 27"
+.TH mbsync 1 "2011 Apr 10"
 ..
 .SH NAME
 mbsync - synchronize IMAP4 and Maildir mailboxes
@@ -131,7 +130,7 @@ directory.
 Messages larger than that will not be propagated into this Store.
 This is useful for weeding out messages with large attachments.
 \fBK\fR and \fBM\fR can be appended to the size to specify KiBytes resp.
-MeBytes instead of bytes. \fBB\fR is accepted but superflous.
+MeBytes instead of bytes. \fBB\fR is accepted but superfluous.
 If \fIsize\fR is 0, the maximum message size is \fBunlimited\fR.
 (Default: \fI0\fR)
 ..
@@ -140,6 +139,7 @@ If \fIsize\fR is 0, the maximum message size is \fBunlimited\fR.
 Create a virtual mailbox (relative to \fBPath\fR), which is backed by
 the \fBINBOX\fR. Makes sense in conjunction with \fBPatterns\fR in the
 Channels section.
+This virtual mailbox does not support subfolders.
 ..
 .TP
 \fBTrash\fR \fImailbox\fR
@@ -233,7 +233,8 @@ will prompt you for it.
 \fBTunnel\fR \fIcommand\fR
 Specify a command to run to establish a connection rather than opening a TCP
 socket.  This allows you to run an IMAP session over an SSH tunnel, for
-example.  This makes most other IMAPAccount options superflous.
+example.
+\fBHost\fR and \fBPort\fR are ignored when \fBTunnel\fR is set.
 ..
 .TP
 \fBRequireCRAM\fR \fIyes\fR|\fIno\fR
@@ -276,6 +277,13 @@ Use SSLv3 for communication with the IMAP server over SSL?
 Use TLSv1 for communication with the IMAP server over SSL?
 (Default: \fIyes\fR)
 ..
+.TP
+\fBPipelineDepth\fR \fIdepth\fR
+Maximum number of IMAP commands which can be simultaneously in flight.
+Setting this to \fI1\fR disables pipelining.
+This is mostly a debugging only option.
+(Default: \fIunlimited\fR)
+..
 .SS IMAP Stores
 The reference point for relative \fBPath\fRs is whatever the server likes it
 to be; probably the user's $HOME or $HOME/Mail on that server. The location
@@ -298,6 +306,11 @@ mailbox names. Disabling this makes sense for some broken IMAP servers.
 This option is meaningless if a \fBPath\fR was specified.
 (Default: \fIyes\fR)
 ..
+.TP
+\fBPathDelimiter\fR \fIdelim\fR
+Specify the server's hierarchy delimiter character.
+(Default: taken from the server's first "personal" NAMESPACE)
+..
 .SS Channels
 .TP
 \fBChannel\fR \fIname\fR
@@ -451,11 +464,13 @@ times within a Group.
 .SH INHERENT PROBLEMS
 Changes done after \fBmbsync\fR has retrieved the message list will not be
 synchronised until the next time \fBmbsync\fR is invoked.
-.P
+..
+.SH BUGS
 Using \fBTrash\fR on IMAP Stores bears a race condition: messages will be
 lost if they are marked as deleted after the message list was retrieved but
-before the mailbox is expunged. There is no risk as long as the IMAP mailbox
-is not simultaneously accessed by \fBmbsync\fR and another mail client.
+before the mailbox is expunged. This can be fixed by using UID EXPUNGE.
+There is no risk as long as the IMAP mailbox is not simultaneously accessed
+by \fBmbsync\fR and another mail client.
 ..
 .SH FILES
 .TP
@@ -470,9 +485,7 @@ mdconvert(1), isync(1), mutt(1), maildir(5)
 .P
 Up to date information on \fBmbsync\fR can be found at http://isync.sf.net/
 ..
-.SH AUTHOR
-Written by Michael R. Elkins <me@mutt.org>,
-.br
-rewritten and maintained by Oswald Buddenhagen <ossi@users.sf.net>,
-.br
-contributions by Theodore Y. Ts'o <tytso@mit.edu>.
+.SH AUTHORS
+Originally written by Michael R. Elkins,
+rewritten and currently maintained by Oswald Buddenhagen,
+contributions by Theodore Y. Ts'o.
diff --git src/mdconvert.1 src/mdconvert.1
index c915be3..17f0789 100644
--- src/mdconvert.1
+++ src/mdconvert.1
@@ -13,8 +13,7 @@
 \"  GNU General Public License for more details.
 \"
 \"  You should have received a copy of the GNU General Public License
-\"  along with this program; if not, write to the Free Software
-\"  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\"  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ..
 .TH mdconvert 1 "2004 Mar 27"
 ..
diff --git src/mdconvert.c src/mdconvert.c
index 2de59ed..2eefff6 100644
--- src/mdconvert.c
+++ src/mdconvert.c
@@ -13,8 +13,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <config.h>
@@ -35,17 +34,43 @@
 
 #define EXE "mdconvert"
 
-static int
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+# define ATTR_NORETURN __attribute__((noreturn))
+# define ATTR_PRINTFLIKE(fmt,var) __attribute__((format(printf,fmt,var)))
+#else
+# define ATTR_NORETURN
+# define ATTR_PRINTFLIKE(fmt,var)
+#endif
+
+static void ATTR_NORETURN
+oob( void )
+{
+	fputs( "Fatal: buffer too small. Please report a bug.\n", stderr );
+	abort();
+}
+
+static void ATTR_PRINTFLIKE(1, 2)
+sys_error( const char *msg, ... )
+{
+	va_list va;
+	char buf[1024];
+
+	va_start( va, msg );
+	if ((unsigned)vsnprintf( buf, sizeof(buf), msg, va ) >= sizeof(buf))
+		oob();
+	va_end( va );
+	perror( buf );
+}
+
+static int ATTR_PRINTFLIKE(3, 4)
 nfsnprintf( char *buf, int blen, const char *fmt, ... )
 {
 	int ret;
 	va_list va;
 
 	va_start( va, fmt );
-	if (blen <= 0 || (unsigned)(ret = vsnprintf( buf, blen, fmt, va )) >= (unsigned)blen) {
-		fputs( "Fatal: buffer too small. Please report a bug.\n", stderr );
-		abort();
-	}
+	if (blen <= 0 || (unsigned)(ret = vsnprintf( buf, blen, fmt, va )) >= (unsigned)blen)
+		oob();
 	va_end( va );
 	return ret;
 }
@@ -54,7 +79,7 @@ static const char *subdirs[] = { "cur", "new" };
 static struct flock lck;
 static DBT key, value;
 
-static inline int
+static int
 convert( const char *box, int altmap )
 {
 	DB *db;
@@ -81,22 +106,22 @@ convert( const char *box, int altmap )
 	nfsnprintf( tdpath, sizeof(tdpath), "%s.tmp", dpath );
 	if ((sfd = open( spath, O_RDWR )) < 0) {
 		if (errno != ENOENT)
-			perror( spath );
+			sys_error( "Cannot open %s", spath );
 		return 1;
 	}
 	if (fcntl( sfd, F_SETLKW, &lck )) {
-		perror( spath );
+		sys_error( "Cannot lock %s", spath );
 		goto sbork;
 	}
 	if ((dfd = open( tdpath, O_RDWR|O_CREAT, 0600 )) < 0) {
-		perror( tdpath );
+		sys_error( "Cannot create %s", tdpath );
 		goto sbork;
 	}
 	if (db_create( &db, 0, 0 )) {
 		fputs( "Error: db_create() failed\n", stderr );
 		goto tbork;
 	}
-	if ((ret = (db->open)( db, 0, dbpath, 0, DB_HASH, DB_CREATE, 0 ))) {
+	if ((ret = (db->open)( db, 0, dbpath, 0, DB_HASH, altmap ? DB_CREATE|DB_TRUNCATE : 0, 0 ))) {
 		db->err( db, ret, "Error: db->open(%s)", dbpath );
 	  dbork:
 		db->close( db, 0 );
@@ -138,7 +163,7 @@ convert( const char *box, int altmap )
 	for (i = 0; i < 2; i++) {
 		bl = nfsnprintf( buf, sizeof(buf), "%s/%s/", box, subdirs[i] );
 		if (!(d = opendir( buf ))) {
-			perror( "opendir" );
+			sys_error( "Cannot list %s", buf );
 			goto dbork;
 		}
 		while ((e = readdir( d ))) {
@@ -185,7 +210,7 @@ convert( const char *box, int altmap )
 			if (rename( buf, buf2 )) {
 				if (errno == ENOENT)
 					goto again;
-				perror( buf );
+				sys_error( "Cannot rename %s to %s", buf, buf2 );
 			  ebork:
 				closedir( d );
 				goto dbork;
@@ -198,11 +223,11 @@ convert( const char *box, int altmap )
 	db->close( db, 0 );
 	close( dfd );
 	if (rename( tdpath, dpath )) {
-		perror( dpath );
+		sys_error( "Cannot rename %s to %s", tdpath, dpath );
 		return 1;
 	}
 	if (unlink( spath ))
-		perror( spath );
+		sys_error( "Cannot remove %s", spath );
 	close( sfd );
 	return 0;
 }
diff --git src/run-tests.pl src/run-tests.pl
new file mode 100755
index 0000000..99c24bd
--- /dev/null
+++ src/run-tests.pl
@@ -0,0 +1,634 @@
+#! /usr/bin/perl -w
+#
+# Copyright (C) 2006 Oswald Buddenhagen <ossi@users.sf.net>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+use strict;
+use File::Path;
+
+-d "tmp" or mkdir "tmp";
+chdir "tmp" or die "Cannot enter temp direcory.\n";
+
+sub show($$@);
+sub test($$);
+
+################################################################################
+
+# generic syncing tests
+my @x01 = (
+ [ 8,
+   1, 1, "F", 2, 2, "", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "F", 7, 7, "FT", 9, 0, "" ],
+ [ 8,
+   1, 1, "", 2, 2, "F", 3, 3, "F", 4, 4, "", 5, 5, "", 7, 7, "", 8, 8, "", 10, 0, "" ],
+ [ 8, 0, 0,
+   1, 1, "", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "", 6, 6, "", 7, 7, "", 8, 8, "" ],
+);
+
+#show("01", "01", "", "", "");
+my @X01 = (
+ [ "", "", "" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "FT", 7, 7, "FT", 9, 9, "", 10, 10, "" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 7, 7, "FT", 8, 8, "T", 9, 10, "", 10, 9, "" ],
+ [ 9, 0, 9,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 0, "", 7, 7, "FT", 0, 8, "", 10, 9, "", 9, 10, "" ],
+);
+test(\@x01, \@X01);
+
+#show("01", "02", "", "", "Expunge Both\n");
+my @X02 = (
+ [ "", "", "Expunge Both\n" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 9, 9, "", 10, 10, "" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 9, 10, "", 10, 9, "" ],
+ [ 9, 0, 9,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 10, 9, "", 9, 10, "" ],
+);
+test(\@x01, \@X02);
+
+#show("01", "03", "", "", "Expunge Slave\n");
+my @X03 = (
+ [ "", "", "Expunge Slave\n" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "FT", 7, 7, "FT", 9, 9, "", 10, 10, "" ],
+ [ 10,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 9, 10, "", 10, 9, "" ],
+ [ 9, 0, 9,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 0, "T", 6, 0, "", 7, 0, "T", 10, 9, "", 9, 10, "" ],
+);
+test(\@x01, \@X03);
+
+#show("01", "04", "", "", "Sync Pull\n");
+my @X04 = (
+ [ "", "", "Sync Pull\n" ],
+ [ 9,
+   1, 1, "F", 2, 2, "", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "F", 7, 7, "FT", 9, 9, "" ],
+ [ 9,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 7, 7, "FT", 8, 8, "T", 9, 9, "", 10, 0, "" ],
+ [ 9, 0, 0,
+   1, 1, "F", 2, 2, "", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "", 7, 7, "FT", 0, 8, "", 9, 9, "" ],
+);
+test(\@x01, \@X04);
+
+#show("01", "05", "", "", "Sync Flags\n");
+my @X05 = (
+ [ "", "", "Sync Flags\n" ],
+ [ 8,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "F", 7, 7, "FT", 9, 0, "" ],
+ [ 8,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 7, 7, "FT", 8, 8, "", 10, 0, "" ],
+ [ 8, 0, 0,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "", 7, 7, "FT", 8, 8, "" ],
+);
+test(\@x01, \@X05);
+
+#show("01", "06", "", "", "Sync Delete\n");
+my @X06 = (
+ [ "", "", "Sync Delete\n" ],
+ [ 8,
+   1, 1, "F", 2, 2, "", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "FT", 7, 7, "FT", 9, 0, "" ],
+ [ 8,
+   1, 1, "", 2, 2, "F", 3, 3, "F", 4, 4, "", 5, 5, "", 7, 7, "", 8, 8, "T", 10, 0, "" ],
+ [ 8, 0, 0,
+   1, 1, "", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "", 6, 0, "", 7, 7, "", 0, 8, "" ],
+);
+test(\@x01, \@X06);
+
+#show("01", "07", "", "", "Sync New\n");
+my @X07 = (
+ [ "", "", "Sync New\n" ],
+ [ 10,
+   1, 1, "F", 2, 2, "", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "F", 7, 7, "FT", 9, 9, "", 10, 10, "" ],
+ [ 10,
+   1, 1, "", 2, 2, "F", 3, 3, "F", 4, 4, "", 5, 5, "", 7, 7, "", 8, 8, "", 9, 10, "", 10, 9, "" ],
+ [ 9, 0, 9,
+   1, 1, "", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "", 6, 6, "", 7, 7, "", 8, 8, "", 10, 9, "", 9, 10, "" ],
+);
+test(\@x01, \@X07);
+
+#show("01", "08", "", "", "Sync PushFlags PullDelete\n");
+my @X08 = (
+ [ "", "", "Sync PushFlags PullDelete\n" ],
+ [ 8,
+   1, 1, "F", 2, 2, "F", 3, 3, "FS", 4, 4, "", 5, 5, "T", 6, 6, "F", 7, 7, "FT", 9, 0, "" ],
+ [ 8,
+   1, 1, "", 2, 2, "F", 3, 3, "F", 4, 4, "", 5, 5, "", 7, 7, "", 8, 8, "T", 10, 0, "" ],
+ [ 8, 0, 0,
+   1, 1, "", 2, 2, "F", 3, 3, "F", 4, 4, "", 5, 5, "", 6, 6, "", 7, 7, "", 0, 8, "" ],
+);
+test(\@x01, \@X08);
+
+# size restriction tests
+
+my @x10 = (
+ [ 0,
+   1, 0, "", 2, 0, "*" ],
+ [ 0,
+   3, 0, "*" ],
+ [ 0, 0, 0,
+    ],
+);
+
+#show("10", "11", "MaxSize 1k\n", "MaxSize 1k\n", "");
+my @X11 = (
+ [ "MaxSize 1k\n", "MaxSize 1k\n", "" ],
+ [ 2,
+   1, 1, "", 2, 2, "*" ],
+ [ 2,
+   3, 1, "*", 1, 2, "" ],
+ [ 2, 0, 1,
+   -1, 1, "", 1, 2, "", 2, -1, "" ],
+);
+test(\@x10, \@X11);
+
+my @x20 = @X11[1,2,3];
+
+#show("20", "11", "MaxSize 1k\n", "MaxSize 1k\n", ""); # sic! - 11
+test(\@x20, \@X11);
+
+#show("20", "22", "", "MaxSize 1k\n", "");
+my @X22 = (
+ [ "", "MaxSize 1k\n", "" ],
+ [ 3,
+   1, 1, "", 2, 2, "*", 3, 3, "*" ],
+ [ 2,
+   3, 1, "*", 1, 2, "" ],
+ [ 2, 0, 1,
+   3, 1, "", 1, 2, "", 2, -1, "" ],
+);
+test(\@x20, \@X22);
+
+# expiration tests
+
+my @x30 = (
+ [ 0,
+   1, 0, "F", 2, 0, "", 3, 0, "", 4, 0, "", 5, 0, "" ],
+ [ 0,
+   ],
+ [ 0, 0, 0,
+    ],
+);
+
+#show("30", "31", "", "", "MaxMessages 3\n");
+my @X31 = (
+ [ "", "", "MaxMessages 3\n" ],
+ [ 5,
+   1, 1, "F", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5,
+   1, 1, "F", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5, 0, 0,
+   1, 1, "F", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "" ],
+);
+test(\@x30, \@X31);
+
+my @x40 = @X31[1,2,3];
+
+#show("40", "41", "", "", "MaxMessages 3\nExpunge Both\n");
+my @X41 = (
+ [ "", "", "MaxMessages 3\nExpunge Both\n" ],
+ [ 5,
+   1, 1, "F", 2, 2, "", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5,
+   1, 1, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5, 2, 0,
+   1, 1, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+);
+test(\@x40, \@X41);
+
+my @x50 = (
+ [ 5,
+   1, 1, "F", 2, 2, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5,
+   1, 1, " ", 2, 2, "T", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5, 2, 0,
+   1, 1, "F", 2, 2, "X", 3, 3, "", 4, 4, "", 5, 5, "" ],
+);
+
+#show("50", "51", "", "", "MaxMessages 3\nExpunge Both\n");
+my @X51 = (
+ [ "", "", "MaxMessages 3\nExpunge Both\n" ],
+ [ 5,
+   1, 1, "", 2, 2, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5,
+   2, 2, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+ [ 5, 2, 0,
+   2, 2, "F", 3, 3, "", 4, 4, "", 5, 5, "" ],
+);
+test(\@x50, \@X51);
+
+
+################################################################################
+
+chdir "..";
+rmdir "tmp";
+print "OK.\n";
+exit 0;
+
+
+sub qm($)
+{
+	shift;
+	s/\\/\\\\/g;
+	s/\"/\\"/g;
+	s/\"/\\"/g;
+	s/\n/\\n/g;
+	return $_;
+}
+
+# $global, $master, $slave
+sub writecfg($$$)
+{
+	open(FILE, ">", ".mbsyncrc") or
+		die "Cannot open .mbsyncrc.\n";
+	print FILE
+"MaildirStore master
+Path ./
+Inbox ./master
+".shift()."
+MaildirStore slave
+Path ./
+Inbox ./slave
+".shift()."
+Channel test
+Master :master:
+Slave :slave:
+SyncState *
+".shift();
+	close FILE;
+}
+
+sub killcfg()
+{
+	unlink ".mbsyncrc";
+}
+
+# $options
+sub runsync($)
+{
+#	open FILE, "valgrind -q --log-fd=3 ../mbsync ".shift()." -c .mbsyncrc test 3>&2 2>&1 |";
+	open FILE, "../mbsync -D ".shift()." -c .mbsyncrc test 2>&1 |";
+	my @out = <FILE>;
+	close FILE or push(@out, $! ? "*** error closing mbsync: $!\n" : "*** mbsync exited with signal ".($?&127).", code ".($?>>8)."\n");
+	return $?, @out;
+}
+
+
+# $path
+sub readbox($)
+{
+	my $bn = shift;
+
+	(-d $bn) or
+		die "No mailbox '$bn'.\n";
+	(-d $bn."/tmp" and -d $bn."/new" and -d $bn."/cur") or
+		die "Invalid mailbox '$bn'.\n";
+	open(FILE, "<", $bn."/.uidvalidity") or die "Cannot read UID validity of mailbox '$bn'.\n";
+	my $dummy = <FILE>;
+	chomp(my $mu = <FILE>);
+	close FILE;
+	my %ms = ();
+	for my $d ("cur", "new") {
+		opendir(DIR, $bn."/".$d) or next;
+		for my $f (grep(!/^\.\.?$/, readdir(DIR))) {
+			my ($uid, $flg, $num);
+			if ($f =~ /^\d+\.\d+_\d+\.[-[:alnum:]]+,U=(\d+):2,(.*)$/) {
+				($uid, $flg) = ($1, $2);
+			} elsif ($f =~ /^\d+\.\d+_(\d+)\.[-[:alnum:]]+:2,(.*)$/) {
+				($uid, $flg) = (0, $2);
+			} else {
+				print STDERR "unrecognided file name '$f' in '$bn'.\n";
+				exit 1;
+			}
+			open(FILE, "<", $bn."/".$d."/".$f) or die "Cannot read message '$f' in '$bn'.\n";
+			my $sz = 0;
+			while (<FILE>) {
+				/^Subject: (\d+)$/ && ($num = $1);
+				$sz += length($_);
+			}
+			close FILE;
+			if (!defined($num)) {
+				print STDERR "message '$f' in '$bn' has no identifier.\n";
+				exit 1;
+			}
+			@{ $ms{$num} } = ($uid, $flg.($sz>1000?"*":""));
+		}
+	}
+	return ($mu, %ms);
+}
+
+# $boxname
+sub showbox($)
+{
+	my ($bn) = @_;
+
+	my ($mu, %ms) = readbox($bn);
+	print " [ $mu,\n   ";
+	my $frst = 1;
+	for my $num (sort {my ($ca, $cb) = ($ms{$a}[0], $ms{$b}[0]); ($ca?$ca:$a+1000) <=> ($cb?$cb:$b+1000)} keys %ms) {
+		if ($frst) {
+			$frst = 0;
+		} else {
+			print ", ";
+		}
+		print "$num, $ms{$num}[0], \"$ms{$num}[1]\"";
+	}
+	print " ],\n";
+}
+
+# $filename
+sub showstate($)
+{
+	my ($fn) = @_;
+
+	if (!open(FILE, "<", $fn)) {
+		print STDERR " Cannot read sync state $fn: $!\n";
+		return;
+	}
+	$_ = <FILE>;
+	if (!defined $_) {
+		print STDERR " Missing sync state header.\n";
+		close FILE;
+		return;
+	}
+	if (!/^1:(\d+):0 1:(\d+):(\d+):0\n$/) {
+		print STDERR " Malformed sync state header '$_'.\n";
+		close FILE;
+		return;
+	}
+	print " [ $1, $2, $3,\n   ";
+	my $frst = 1;
+	for (<FILE>) {
+		if ($frst) {
+			$frst = 0;
+		} else {
+			print ", ";
+		}
+		if (!/^(-?\d+) (-?\d+) (.*)\n$/) {
+			print "??, ??, \"??\"";
+		} else {
+			print "$1, $2, \"$3\"";
+		}
+	}
+	print " ],\n";
+	close FILE;
+}
+
+# $filename
+sub showchan($)
+{
+	my ($fn) = @_;
+
+	showbox("master");
+	showbox("slave");
+	showstate($fn);
+}
+
+sub show($$@)
+{
+	my ($sx, $tx, @sfx) = @_;
+	my @sp;
+	eval "\@sp = \@x$sx";
+	mkchan($sp[0], $sp[1], @{ $sp[2] });
+	print "my \@x$sx = (\n";
+	showchan("slave/.mbsyncstate");
+	print ");\n";
+	&writecfg(@sfx);
+	runsync("");
+	killcfg();
+	print "my \@X$tx = (\n";
+	print " [ ".join(", ", map('"'.qm($_).'"', @sfx))." ],\n";
+	showchan("slave/.mbsyncstate");
+	print ");\n";
+	print "test(\\\@x$sx, \\\@X$tx);\n\n";
+	rmtree "slave";
+	rmtree "master";
+}
+
+# $boxname, $maxuid, @msgs
+sub mkbox($$@)
+{
+	my ($bn, $mu, @ms) = @_;
+
+	rmtree($bn);
+	(mkdir($bn) and mkdir($bn."/tmp") and mkdir($bn."/new") and mkdir($bn."/cur")) or
+		die "Cannot create mailbox $bn.\n";
+	open(FILE, ">", $bn."/.uidvalidity") or die "Cannot create UID validity for mailbox $bn.\n";
+	print FILE "1\n$mu\n";
+	close FILE;
+	while (@ms) {
+		my ($num, $uid, $flg) = (shift @ms, shift @ms, shift @ms);
+		if ($uid) {
+			$uid = ",U=".$uid;
+		} else {
+			$uid = "";
+		}
+		my $big = $flg =~ s/\*//;
+		open(FILE, ">", $bn."/cur/0.1_".$num.".local".$uid.":2,".$flg) or
+			die "Cannot create message $num in mailbox $bn.\n";
+		print FILE "From: foo\nTo: bar\nDate: Thu, 1 Jan 1970 00:00:00 +0000\nSubject: $num\n\n".(("A"x50)."\n")x($big*30);
+		close FILE;
+	}
+}
+
+# \@master, \@slave, @syncstate
+sub mkchan($$@)
+{
+	my ($m, $s, @t) = @_;
+	&mkbox("master", @{ $m });
+	&mkbox("slave", @{ $s });
+	open(FILE, ">", "slave/.mbsyncstate") or
+		die "Cannot create sync state.\n";
+	print FILE "1:".shift(@t)." 1:".shift(@t).":".shift(@t)."\n";
+	while (@t) {
+		print FILE shift(@t)." ".shift(@t)." ".shift(@t)."\n";
+	}
+	close FILE;
+}
+
+# $config, $boxname, $maxuid, @msgs
+sub ckbox($$$@)
+{
+	my ($bn, $MU, @MS) = @_;
+
+	my ($mu, %ms) = readbox($bn);
+	if ($mu != $MU) {
+		print STDERR "MAXUID mismatch for '$bn'.\n";
+		return 1;
+	}
+	while (@MS) {
+		my ($num, $uid, $flg) = (shift @MS, shift @MS, shift @MS);
+		if (!defined $ms{$num}) {
+			print STDERR "No message $bn:$num.\n";
+			return 1;
+		}
+		if ($ms{$num}[0] ne $uid) {
+			print STDERR "UID mismatch for $bn:$num.\n";
+			return 1;
+		}
+		if ($ms{$num}[1] ne $flg) {
+			print STDERR "Flag mismatch for $bn:$num.\n";
+			return 1;
+		}
+		delete $ms{$num};
+	}
+	if (%ms) {
+		print STDERR "Excess messages in '$bn': ".join(", ", sort({$a <=> $b } keys(%ms))).".\n";
+		return 1;
+	}
+	return 0;
+}
+
+# $filename, @syncstate
+sub ckstate($@)
+{
+	my ($fn, @T) = @_;
+	open(FILE, "<", $fn) or die "Cannot read sync state $fn.\n";
+	my $l = <FILE>;
+	chomp(my @ls = <FILE>);
+	close FILE;
+	if (!defined $l) {
+		print STDERR "Sync state header missing.\n";
+		return 1;
+	}
+	chomp($l);
+	my $xl = "1:".shift(@T).":0 1:".shift(@T).":".shift(@T).":0";
+	if ($l ne $xl) {
+		print STDERR "Sync state header mismatch: '$l' instead of '$xl'.\n";
+		return 1;
+	} else {
+		for $l (@ls) {
+			$xl = shift(@T)." ".shift(@T)." ".shift(@T);
+			if ($l ne $xl) {
+				print STDERR "Sync state entry mismatch: '$l' instead of '$xl'.\n";
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+# \@master, \@slave, @syncstate
+sub ckchan($$@)
+{
+	my ($M, $S, @T) = @_;
+	my $rslt = ckstate("slave/.mbsyncstate.new", @T);
+	$rslt |= &ckbox("master", @{ $M });
+	$rslt |= &ckbox("slave", @{ $S });
+	return $rslt;
+}
+
+sub printbox($$@)
+{
+	my ($bn, $mu, @ms) = @_;
+
+	print " [ $mu,\n   ";
+	my $frst = 1;
+	while (@ms) {
+		if ($frst) {
+			$frst = 0;
+		} else {
+			print ", ";
+		}
+		print shift(@ms).", ".shift(@ms).", \"".shift(@ms)."\"";
+	}
+	print " ],\n";
+}
+
+# @syncstate
+sub printstate(@)
+{
+	my (@t) = @_;
+
+	print " [ ".shift(@t).", ".shift(@t).", ".shift(@t).",\n   ";
+	my $frst = 1;
+	while (@t) {
+		if ($frst) {
+			$frst = 0;
+		} else {
+			print ", ";
+		}
+		print shift(@t).", ".shift(@t).", \"".shift(@t)."\"";
+	}
+	print " ],\n";
+	close FILE;
+}
+
+# \@master, \@slave, @syncstate
+sub printchan($$@)
+{
+	my ($m, $s, @t) = @_;
+
+	&printbox("master", @{ $m });
+	&printbox("slave", @{ $s });
+	printstate(@t);
+}
+
+sub test($$)
+{
+	my ($sx, $tx) = @_;
+
+	mkchan($$sx[0], $$sx[1], @{ $$sx[2] });
+	&writecfg(@{ $$tx[0] });
+	my ($xc, @ret) = runsync("-J");
+	if ($xc) {
+		print "Input:\n";
+		printchan($$sx[0], $$sx[1], @{ $$sx[2] });
+		print "Options:\n";
+		print " [ ".join(", ", map('"'.qm($_).'"', @{ $$tx[0] }))." ]\n";
+		print "Expected result:\n";
+		printchan($$tx[1], $$tx[2], @{ $$tx[3] });
+		print "Debug output:\n";
+		print @ret;
+		exit 1;
+	}
+	if (ckchan($$tx[1], $$tx[2], @{ $$tx[3] })) {
+		print "Input:\n";
+		printchan($$sx[0], $$sx[1], @{ $$sx[2] });
+		print "Options:\n";
+		print " [ ".join(", ", map('"'.qm($_).'"', @{ $$tx[0] }))." ]\n";
+		print "Expected result:\n";
+		printchan($$tx[1], $$tx[2], @{ $$tx[3] });
+		print "Actual result:\n";
+		showchan("slave/.mbsyncstate.new");
+		print "Debug output:\n";
+		print @ret;
+		exit 1;
+	}
+	open(FILE, "<", "slave/.mbsyncstate.journal") or
+		die "Cannot read journal.\n";
+	my @nj = <FILE>;
+	close FILE;
+	@ret = runsync("");
+	killcfg();
+	if (ckstate("slave/.mbsyncstate", @{ $$tx[3] })) {
+		print "Options:\n";
+		print " [ ".join(", ", map('"'.qm($_).'"', @{ $$tx[0] }))." ]\n";
+		print "Old State:\n";
+		printstate(@{ $$sx[2] });
+		print "Journal:\n".join("", @nj)."\n";
+		print "Expected New State:\n";
+		printstate(@{ $$tx[3] });
+		print "New State:\n";
+		showstate("slave/.mbsyncstate");
+		print "Debug output:\n";
+		print @ret;
+		exit 1;
+	}
+	rmtree "slave";
+	rmtree "master";
+}
diff --git src/socket.c src/socket.c
new file mode 100644
index 0000000..2d68958
--- /dev/null
+++ src/socket.c
@@ -0,0 +1,749 @@
+/*
+ * mbsync - mailbox synchronizer
+ * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2002-2006,2008,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2004 Theodore Y. Ts'o <tytso@mit.edu>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * As a special exception, mbsync may be linked with the OpenSSL library,
+ * despite that library's more restrictive license.
+ */
+
+/* This must come before isync.h to avoid our #define S messing up
+ * blowfish.h on MacOS X. */
+#include <config.h>
+#ifdef HAVE_LIBSSL
+# include <openssl/ssl.h>
+# include <openssl/err.h>
+# include <openssl/hmac.h>
+#endif
+
+#include "isync.h"
+
+#include <assert.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+enum {
+	SCK_CONNECTING,
+#ifdef HAVE_LIBSSL
+	SCK_STARTTLS,
+#endif
+	SCK_READY
+};
+
+static void
+socket_fail( conn_t *conn )
+{
+	conn->bad_callback( conn->callback_aux );
+}
+
+#ifdef HAVE_LIBSSL
+static int
+ssl_return( const char *func, conn_t *conn, int ret )
+{
+	int err;
+
+	switch ((err = SSL_get_error( conn->ssl, ret ))) {
+	case SSL_ERROR_NONE:
+		return ret;
+	case SSL_ERROR_WANT_WRITE:
+		conf_fd( conn->fd, POLLIN, POLLOUT );
+		/* fallthrough */
+	case SSL_ERROR_WANT_READ:
+		return 0;
+	case SSL_ERROR_SYSCALL:
+	case SSL_ERROR_SSL:
+		if (!(err = ERR_get_error())) {
+			if (ret == 0)
+				error( "Socket error: secure %s %s: unexpected EOF\n", func, conn->name );
+			else
+				sys_error( "Socket error: secure %s %s", func, conn->name );
+		} else {
+			error( "Socket error: secure %s %s: %s\n", func, conn->name, ERR_error_string( err, 0 ) );
+		}
+		break;
+	default:
+		error( "Socket error: secure %s %s: unhandled SSL error %d\n", func, conn->name, err );
+		break;
+	}
+	if (conn->state == SCK_STARTTLS)
+		conn->callbacks.starttls( 0, conn->callback_aux );
+	else
+		socket_fail( conn );
+	return -1;
+}
+
+/* Some of this code is inspired by / lifted from mutt. */
+
+static int
+compare_certificates( X509 *cert, X509 *peercert,
+                      unsigned char *peermd, unsigned peermdlen )
+{
+	unsigned char md[EVP_MAX_MD_SIZE];
+	unsigned mdlen;
+
+	/* Avoid CPU-intensive digest calculation if the certificates are
+	 * not even remotely equal. */
+	if (X509_subject_name_cmp( cert, peercert ) ||
+	    X509_issuer_name_cmp( cert, peercert ))
+		return -1;
+
+	if (!X509_digest( cert, EVP_sha1(), md, &mdlen ) ||
+	    peermdlen != mdlen || memcmp( peermd, md, mdlen ))
+		return -1;
+
+	return 0;
+}
+
+#if OPENSSL_VERSION_NUMBER >= 0x00904000L
+#define READ_X509_KEY(fp, key) PEM_read_X509( fp, key, 0, 0 )
+#else
+#define READ_X509_KEY(fp, key) PEM_read_X509( fp, key, 0 )
+#endif
+
+/* this gets called when a certificate is to be verified */
+static int
+verify_cert( const server_conf_t *conf, conn_t *sock )
+{
+	server_conf_t *mconf = (server_conf_t *)conf;
+	SSL *ssl = sock->ssl;
+	X509 *cert, *lcert;
+	BIO *bio;
+	FILE *fp;
+	int err;
+	unsigned n, i;
+	X509_STORE_CTX xsc;
+	char buf[256];
+	unsigned char md[EVP_MAX_MD_SIZE];
+
+	cert = SSL_get_peer_certificate( ssl );
+	if (!cert) {
+		error( "Error, no server certificate\n" );
+		return -1;
+	}
+
+	while (conf->cert_file) { /* while() instead of if() so break works */
+		if (X509_cmp_current_time( X509_get_notBefore( cert )) >= 0) {
+			error( "Server certificate is not yet valid\n" );
+			break;
+		}
+		if (X509_cmp_current_time( X509_get_notAfter( cert )) <= 0) {
+			error( "Server certificate has expired\n" );
+			break;
+		}
+		if (!X509_digest( cert, EVP_sha1(), md, &n )) {
+			error( "*** Unable to calculate digest\n" );
+			break;
+		}
+		if (!(fp = fopen( conf->cert_file, "rt" ))) {
+			sys_error( "Unable to load CertificateFile '%s'", conf->cert_file );
+			return -1;
+		}
+		err = -1;
+		for (lcert = 0; READ_X509_KEY( fp, &lcert ); )
+			if (!(err = compare_certificates( lcert, cert, md, n )))
+				break;
+		X509_free( lcert );
+		fclose( fp );
+		if (!err)
+			return 0;
+		break;
+	}
+
+	if (!mconf->cert_store) {
+		if (!(mconf->cert_store = X509_STORE_new())) {
+			error( "Error creating certificate store\n" );
+			return -1;
+		}
+		if (!X509_STORE_set_default_paths( mconf->cert_store ))
+			warn( "Error while loading default certificate files: %s\n",
+			      ERR_error_string( ERR_get_error(), 0 ) );
+		if (!conf->cert_file) {
+			info( "Note: CertificateFile not defined\n" );
+		} else if (!X509_STORE_load_locations( mconf->cert_store, conf->cert_file, 0 )) {
+			error( "Error while loading certificate file '%s': %s\n",
+			       conf->cert_file, ERR_error_string( ERR_get_error(), 0 ) );
+			return -1;
+		}
+	}
+
+	X509_STORE_CTX_init( &xsc, mconf->cert_store, cert, 0 );
+	err = X509_verify_cert( &xsc ) > 0 ? 0 : X509_STORE_CTX_get_error( &xsc );
+	X509_STORE_CTX_cleanup( &xsc );
+	if (!err)
+		return 0;
+	error( "Error, cannot verify certificate: %s (%d)\n",
+	       X509_verify_cert_error_string( err ), err );
+
+	X509_NAME_oneline( X509_get_subject_name( cert ), buf, sizeof(buf) );
+	info( "\nSubject: %s\n", buf );
+	X509_NAME_oneline( X509_get_issuer_name( cert ), buf, sizeof(buf) );
+	info( "Issuer:  %s\n", buf );
+	bio = BIO_new( BIO_s_mem() );
+	ASN1_TIME_print( bio, X509_get_notBefore( cert ) );
+	memset( buf, 0, sizeof(buf) );
+	BIO_read( bio, buf, sizeof(buf) - 1 );
+	info( "Valid from: %s\n", buf );
+	ASN1_TIME_print( bio, X509_get_notAfter( cert ) );
+	memset( buf, 0, sizeof(buf) );
+	BIO_read( bio, buf, sizeof(buf) - 1 );
+	BIO_free( bio );
+	info( "      to:   %s\n", buf );
+	if (!X509_digest( cert, EVP_md5(), md, &n )) {
+		error( "*** Unable to calculate fingerprint\n" );
+	} else {
+		info( "Fingerprint: " );
+		for (i = 0; i < n; i += 2)
+			info( "%02X%02X ", md[i], md[i + 1] );
+		info( "\n" );
+	}
+
+	fputs( "\nAccept certificate? [y/N]: ",  stderr );
+	if (fgets( buf, sizeof(buf), stdin ) && (buf[0] == 'y' || buf[0] == 'Y'))
+		return 0;
+	return -1;
+}
+
+static int
+init_ssl_ctx( const server_conf_t *conf )
+{
+	server_conf_t *mconf = (server_conf_t *)conf;
+	const SSL_METHOD *method;
+	int options = 0;
+
+	if (conf->use_tlsv1 && !conf->use_sslv2 && !conf->use_sslv3)
+		method = TLSv1_client_method();
+	else
+		method = SSLv23_client_method();
+	mconf->SSLContext = SSL_CTX_new( method );
+
+	if (!conf->use_sslv2)
+		options |= SSL_OP_NO_SSLv2;
+	if (!conf->use_sslv3)
+		options |= SSL_OP_NO_SSLv3;
+	if (!conf->use_tlsv1)
+		options |= SSL_OP_NO_TLSv1;
+
+	SSL_CTX_set_options( mconf->SSLContext, options );
+
+	/* we check the result of the verification after SSL_connect() */
+	SSL_CTX_set_verify( mconf->SSLContext, SSL_VERIFY_NONE, 0 );
+	return 0;
+}
+
+static int start_tls_p2( conn_t * );
+static int start_tls_p3( conn_t *, int );
+
+int
+socket_start_tls( conn_t *conn, int (*cb)( int ok, void *aux ) )
+{
+	static int ssl_inited;
+
+	conn->callbacks.starttls = cb;
+
+	if (!ssl_inited) {
+		SSL_library_init();
+		SSL_load_error_strings();
+		ssl_inited = 1;
+	}
+
+	if (!conn->conf->SSLContext && init_ssl_ctx( conn->conf ))
+		return start_tls_p3( conn, 0 );
+
+	conn->ssl = SSL_new( ((server_conf_t *)conn->conf)->SSLContext );
+	SSL_set_fd( conn->ssl, conn->fd );
+	SSL_set_mode( conn->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER );
+	return start_tls_p2( conn );
+}
+
+static int
+start_tls_p2( conn_t *conn )
+{
+	switch (ssl_return( "connect to", conn, SSL_connect( conn->ssl ) )) {
+	case -1:
+		start_tls_p3( conn, 0 );
+		return -1;
+	case 0:
+		return 0;
+	default:
+		/* verify the server certificate */
+		if (verify_cert( conn->conf, conn )) {
+			return start_tls_p3( conn, 0 );
+		} else {
+			info( "Connection is now encrypted\n" );
+			return start_tls_p3( conn, 1 );
+		}
+	}
+}
+
+static int
+start_tls_p3( conn_t *conn, int ok )
+{
+	conn->state = SCK_READY;
+	return conn->callbacks.starttls( ok, conn->callback_aux );
+}
+
+#endif /* HAVE_LIBSSL */
+
+static void socket_fd_cb( int, void * );
+
+static void socket_connected2( conn_t * );
+static void socket_connect_bail( conn_t * );
+
+static void
+socket_close_internal( conn_t *sock )
+{
+	del_fd( sock->fd );
+	close( sock->fd );
+	sock->fd = -1;
+}
+
+void
+socket_connect( conn_t *sock, void (*cb)( int ok, void *aux ) )
+{
+	const server_conf_t *conf = sock->conf;
+	struct hostent *he;
+	struct sockaddr_in addr;
+	int s, a[2];
+
+	sock->callbacks.connect = cb;
+
+	/* open connection to IMAP server */
+	if (conf->tunnel) {
+		nfasprintf( &sock->name, "tunnel '%s'", conf->tunnel );
+		infon( "Starting %s... ", sock->name );
+
+		if (socketpair( PF_UNIX, SOCK_STREAM, 0, a )) {
+			perror( "socketpair" );
+			exit( 1 );
+		}
+
+		if (fork() == 0) {
+			if (dup2( a[0], 0 ) == -1 || dup2( a[0], 1 ) == -1)
+				_exit( 127 );
+			close( a[0] );
+			close( a[1] );
+			execl( "/bin/sh", "sh", "-c", conf->tunnel, (char *)0 );
+			_exit( 127 );
+		}
+
+		close( a[0] );
+		sock->fd = a[1];
+
+		fcntl( a[1], F_SETFL, O_NONBLOCK );
+		add_fd( a[1], socket_fd_cb, sock );
+
+	} else {
+		memset( &addr, 0, sizeof(addr) );
+		addr.sin_port = conf->port ? htons( conf->port ) :
+#ifdef HAVE_LIBSSL
+		                conf->use_imaps ? htons( 993 ) :
+#endif
+		                htons( 143 );
+		addr.sin_family = AF_INET;
+
+		infon( "Resolving %s... ", conf->host );
+		he = gethostbyname( conf->host );
+		if (!he) {
+			error( "IMAP error: Cannot resolve server '%s'\n", conf->host );
+			goto bail;
+		}
+		info( "ok\n" );
+
+		addr.sin_addr.s_addr = *((int *)he->h_addr_list[0]);
+
+		s = socket( PF_INET, SOCK_STREAM, 0 );
+		if (s < 0) {
+			perror( "socket" );
+			exit( 1 );
+		}
+		sock->fd = s;
+		fcntl( s, F_SETFL, O_NONBLOCK );
+		add_fd( s, socket_fd_cb, sock );
+
+		nfasprintf( &sock->name, "%s (%s:%hu)",
+		            conf->host, inet_ntoa( addr.sin_addr ), ntohs( addr.sin_port ) );
+		infon( "Connecting to %s... ", sock->name );
+		if (connect( s, (struct sockaddr *)&addr, sizeof(addr) )) {
+			if (errno != EINPROGRESS) {
+				sys_error( "Cannot connect to %s", sock->name );
+				socket_close_internal( sock );
+				goto bail;
+			}
+			conf_fd( s, 0, POLLOUT );
+			sock->state = SCK_CONNECTING;
+			info( "\n" );
+			return;
+		}
+
+	}
+	info( "ok\n" );
+	socket_connected2( sock );
+	return;
+
+  bail:
+	socket_connect_bail( sock );
+}
+
+static void
+socket_connected( conn_t *conn )
+{
+	int soerr;
+	socklen_t selen = sizeof(soerr);
+
+	if (getsockopt( conn->fd, SOL_SOCKET, SO_ERROR, &soerr, &selen )) {
+		perror( "getsockopt" );
+		exit( 1 );
+	}
+	if (soerr) {
+		errno = soerr;
+		sys_error( "Cannot connect to %s", conn->name );
+		socket_close_internal( conn );
+		socket_connect_bail( conn );
+		return;
+	}
+	socket_connected2( conn );
+}
+
+static void
+socket_connected2( conn_t *conn )
+{
+	conf_fd( conn->fd, 0, POLLIN );
+	conn->state = SCK_READY;
+	conn->callbacks.connect( 1, conn->callback_aux );
+}
+
+static void
+socket_connect_bail( conn_t *conn )
+{
+	free( conn->name );
+	conn->name = 0;
+	conn->callbacks.connect( 0, conn->callback_aux );
+}
+
+static void dispose_chunk( conn_t *conn );
+
+void
+socket_close( conn_t *sock )
+{
+	if (sock->fd >= 0)
+		socket_close_internal( sock );
+	free( sock->name );
+	sock->name = 0;
+#ifdef HAVE_LIBSSL
+	if (sock->ssl) {
+		SSL_free( sock->ssl );
+		sock->ssl = 0;
+	}
+#endif
+	while (sock->write_buf)
+		dispose_chunk( sock );
+}
+
+static void
+socket_fill( conn_t *sock )
+{
+	char *buf;
+	int n = sock->offset + sock->bytes;
+	int len = sizeof(sock->buf) - n;
+	if (!len) {
+		error( "Socket error: receive buffer full. Probably protocol error.\n" );
+		socket_fail( sock );
+		return;
+	}
+	assert( sock->fd >= 0 );
+	buf = sock->buf + n;
+#ifdef HAVE_LIBSSL
+	if (sock->ssl) {
+		int any = 0;
+		for (;;) {
+			if ((n = ssl_return( "read from", sock, SSL_read( sock->ssl, buf, len ) )) < 0)
+				return;
+			if (!n) {
+				if (!any)
+					return;
+				break;
+			}
+			sock->bytes += n;
+			buf += n;
+			len -= n;
+			if (!len) {
+				if (SSL_pending( sock->ssl ))
+					fake_fd( sock->fd, POLLIN );
+				break;
+			}
+			any = 1;
+		}
+	} else
+#endif
+	{
+		if ((n = read( sock->fd, buf, len )) < 0) {
+			sys_error( "Socket error: read from %s", sock->name );
+			socket_fail( sock );
+			return;
+		} else if (!n) {
+			error( "Socket error: read from %s: unexpected EOF\n", sock->name );
+			socket_fail( sock );
+			return;
+		}
+		sock->bytes += n;
+	}
+	sock->read_callback( sock->callback_aux );
+}
+
+int
+socket_read( conn_t *conn, char *buf, int len )
+{
+	int n = conn->bytes;
+	if (n > len)
+		n = len;
+	memcpy( buf, conn->buf + conn->offset, n );
+	if (!(conn->bytes -= n))
+		conn->offset = 0;
+	else
+		conn->offset += n;
+	return n;
+}
+
+char *
+socket_read_line( conn_t *b )
+{
+	char *p, *s;
+	int n;
+
+	s = b->buf + b->offset;
+	p = memchr( s + b->scanoff, '\n', b->bytes - b->scanoff );
+	if (!p) {
+		b->scanoff = b->bytes;
+		if (b->offset + b->bytes == sizeof(b->buf)) {
+			memmove( b->buf, b->buf + b->offset, b->bytes );
+			b->offset = 0;
+		}
+		return 0;
+	}
+	n = p + 1 - s;
+	b->offset += n;
+	b->bytes -= n;
+	b->scanoff = 0;
+	if (p != s && p[-1] == '\r')
+		p--;
+	*p = 0;
+	if (DFlags & VERBOSE)
+		puts( s );
+	return s;
+}
+
+static int
+do_write( conn_t *sock, char *buf, int len )
+{
+	int n;
+
+	assert( sock->fd >= 0 );
+#ifdef HAVE_LIBSSL
+	if (sock->ssl)
+		return ssl_return( "write to", sock, SSL_write( sock->ssl, buf, len ) );
+#endif
+	n = write( sock->fd, buf, len );
+	if (n < 0) {
+		if (errno != EAGAIN && errno != EWOULDBLOCK) {
+			sys_error( "Socket error: write to %s", sock->name );
+			socket_fail( sock );
+		} else {
+			n = 0;
+			conf_fd( sock->fd, POLLIN, POLLOUT );
+		}
+	} else if (n != len) {
+		conf_fd( sock->fd, POLLIN, POLLOUT );
+	}
+	return n;
+}
+
+static void
+dispose_chunk( conn_t *conn )
+{
+	buff_chunk_t *bc = conn->write_buf;
+	if (!(conn->write_buf = bc->next))
+		conn->write_buf_append = &conn->write_buf;
+	if (bc->data != bc->buf)
+		free( bc->data );
+	free( bc );
+}
+
+static int
+do_queued_write( conn_t *conn )
+{
+	buff_chunk_t *bc;
+
+	if (!conn->write_buf)
+		return 0;
+
+	while ((bc = conn->write_buf)) {
+		int n, len = bc->len - conn->write_offset;
+		if ((n = do_write( conn, bc->data + conn->write_offset, len )) < 0)
+			return -1;
+		if (n != len) {
+			conn->write_offset += n;
+			return 0;
+		}
+		conn->write_offset = 0;
+		dispose_chunk( conn );
+	}
+#ifdef HAVE_LIBSSL
+	if (conn->ssl && SSL_pending( conn->ssl ))
+		fake_fd( conn->fd, POLLIN );
+#endif
+	return conn->write_callback( conn->callback_aux );
+}
+
+static void
+do_append( conn_t *conn, char *buf, int len, ownership_t takeOwn )
+{
+	buff_chunk_t *bc;
+
+	if (takeOwn == GiveOwn) {
+		bc = nfmalloc( offsetof(buff_chunk_t, buf) );
+		bc->data = buf;
+	} else {
+		bc = nfmalloc( offsetof(buff_chunk_t, buf) + len );
+		bc->data = bc->buf;
+		memcpy( bc->data, buf, len );
+	}
+	bc->len = len;
+	bc->next = 0;
+	*conn->write_buf_append = bc;
+	conn->write_buf_append = &bc->next;
+}
+
+int
+socket_write( conn_t *conn, char *buf, int len, ownership_t takeOwn )
+{
+	if (conn->write_buf) {
+		do_append( conn, buf, len, takeOwn );
+		return len;
+	} else {
+		int n = do_write( conn, buf, len );
+		if (n != len && n >= 0) {
+			conn->write_offset = n;
+			do_append( conn, buf, len, takeOwn );
+		} else if (takeOwn) {
+			free( buf );
+		}
+		return n;
+	}
+}
+
+static void
+socket_fd_cb( int events, void *aux )
+{
+	conn_t *conn = (conn_t *)aux;
+
+	if (events & POLLERR) {
+		error( "Unidentified socket error from %s.\n", conn->name );
+		socket_fail( conn );
+		return;
+	}
+
+	if (conn->state == SCK_CONNECTING) {
+		socket_connected( conn );
+		return;
+	}
+
+	if (events & POLLOUT)
+		conf_fd( conn->fd, POLLIN, 0 );
+
+#ifdef HAVE_LIBSSL
+	if (conn->state == SCK_STARTTLS) {
+		start_tls_p2( conn );
+		return;
+	}
+	if (conn->ssl) {
+		if (do_queued_write( conn ) < 0)
+			return;
+		socket_fill( conn );
+		return;
+	}
+#endif
+
+	if ((events & POLLOUT) && do_queued_write( conn ) < 0)
+		return;
+	if (events & POLLIN)
+		socket_fill( conn );
+}
+
+#ifdef HAVE_LIBSSL
+/* this isn't strictly socket code, but let's have all OpenSSL use in one file. */
+
+#define ENCODED_SIZE(n) (4*((n+2)/3))
+
+static char
+hexchar( unsigned int b )
+{
+	if (b < 10)
+		return '0' + b;
+	return 'a' + (b - 10);
+}
+
+void
+cram( const char *challenge, const char *user, const char *pass, char **_final, int *_finallen )
+{
+	unsigned char *response, *final;
+	unsigned hashlen;
+	int i, clen, rlen, blen, flen, olen;
+	unsigned char hash[16];
+	char buf[256], hex[33];
+	HMAC_CTX hmac;
+
+	HMAC_Init( &hmac, (unsigned char *)pass, strlen( pass ), EVP_md5() );
+
+	clen = strlen( challenge );
+	/* response will always be smaller than challenge because we are decoding. */
+	response = nfcalloc( 1 + clen );
+	rlen = EVP_DecodeBlock( response, (unsigned char *)challenge, clen );
+	HMAC_Update( &hmac, response, rlen );
+	free( response );
+
+	hashlen = sizeof(hash);
+	HMAC_Final( &hmac, hash, &hashlen );
+	assert( hashlen == sizeof(hash) );
+
+	hex[32] = 0;
+	for (i = 0; i < 16; i++) {
+		hex[2 * i] = hexchar( (hash[i] >> 4) & 0xf );
+		hex[2 * i + 1] = hexchar( hash[i] & 0xf );
+	}
+
+	blen = nfsnprintf( buf, sizeof(buf), "%s %s", user, hex );
+
+	flen = ENCODED_SIZE( blen );
+	final = nfmalloc( flen + 1 );
+	final[flen] = 0;
+	olen = EVP_EncodeBlock( (unsigned char *)final, (unsigned char *)buf, blen );
+	assert( olen == flen );
+
+	*_final = (char *)final;
+	*_finallen = flen;
+}
+#endif
diff --git src/sync.c src/sync.c
index 5a5d247..4a867b2 100644
--- src/sync.c
+++ src/sync.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2010,2011 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -26,6 +25,7 @@
 #include <stdio.h>
 #include <limits.h>
 #include <stdlib.h>
+#include <stddef.h>
 #include <unistd.h>
 #include <time.h>
 #include <fcntl.h>
@@ -33,6 +33,17 @@
 #include <errno.h>
 #include <sys/stat.h>
 
+const char *str_ms[] = { "master", "slave" }, *str_hl[] = { "push", "pull" };
+
+void
+Fclose( FILE *f )
+{
+	if (fclose( f ) == EOF) {
+		sys_error( "Error: cannot close file. Disk full?" );
+		exit( 1 );
+	}
+}
+
 void
 Fprintf( FILE *f, const char *msg, ... )
 {
@@ -43,7 +54,7 @@ Fprintf( FILE *f, const char *msg, ... )
 	r = vfprintf( f, msg, va );
 	va_end( va );
 	if (r < 0) {
-		perror( "cannot write file" );
+		sys_error( "Error: cannot write file. Disk full?" );
 		exit( 1 );
 	}
 }
@@ -76,379 +87,407 @@ make_flags( int flags, char *buf )
 	return d;
 }
 
-static void
-makeopts( int dops, store_conf_t *dconf, int *dopts,
-          store_conf_t *sconf, int *sopts )
-{
-	if (dops & (OP_DELETE|OP_FLAGS)) {
-		*dopts |= OPEN_SETFLAGS;
-		*sopts |= OPEN_OLD;
-		if (dops & OP_FLAGS)
-			*sopts |= OPEN_FLAGS;
-	}
-	if (dops & (OP_NEW|OP_RENEW)) {
-		*dopts |= OPEN_APPEND;
-		if (dops & OP_RENEW)
-			*sopts |= OPEN_OLD;
-		if (dops & OP_NEW)
-			*sopts |= OPEN_NEW;
-		if (dops & OP_EXPUNGE)
-			*sopts |= OPEN_FLAGS;
-		if (dconf->max_size)
-			*sopts |= OPEN_SIZE;
-	}
-	if (dops & OP_EXPUNGE) {
-		*dopts |= OPEN_EXPUNGE;
-		if (dconf->trash) {
-			if (!dconf->trash_only_new)
-				*dopts |= OPEN_OLD;
-			*dopts |= OPEN_NEW|OPEN_FLAGS;
-		} else if (sconf->trash && sconf->trash_remote_new)
-			*dopts |= OPEN_NEW|OPEN_FLAGS;
-	}
-	if (dops & OP_CREATE)
-		*dopts |= OPEN_CREATE;
-}
-
-static void
-dump_box( store_t *ctx )
-{
-	message_t *msg;
-	char fbuf[16]; /* enlarge when support for keywords is added */
-
-	if (Debug)
-		for (msg = ctx->msgs; msg; msg = msg->next) {
-			make_flags( msg->flags, fbuf );
-			printf( "  message %d, %s, %d\n", msg->uid, fbuf, msg->size );
-		}
-}
-
-static message_t *
-findmsg( store_t *ctx, int uid, message_t **nmsg, const char *who )
-{
-	message_t *msg;
-
-	if (uid > 0) {
-		if (*nmsg && (*nmsg)->uid == uid) {
-			debug( " %s came in sequence\n", who );
-			msg = *nmsg;
-		  found:
-			*nmsg = msg->next;
-			if (!(msg->status & M_DEAD)) {
-				msg->status |= M_PROCESSED;
-				return msg;
-			}
-			debug( "  ... but it vanished under our feet!\n" );
-		} else {
-			for (msg = ctx->msgs; msg; msg = msg->next)
-				if (msg->uid == uid) {
-					debug( " %s came out of sequence\n", who );
-					goto found;
-				}
-				debug( " %s not present\n", who );
-		}
-	} else
-		debug( " no %s expected\n", who );
-	return 0;
-}
 
 #define S_DEAD         (1<<0)
-#define S_EXPIRED      (1<<1)
-#define S_DEL_MASTER   (1<<2)
-#define S_DEL_SLAVE    (1<<3)
-#define S_EXP_SLAVE    (1<<4)
+#define S_DONE         (1<<1)
+#define S_DEL(ms)      (1<<(2+(ms)))
+#define S_EXPIRED      (1<<4)
+#define S_EXPIRE       (1<<5)
+#define S_NEXPIRE      (1<<6)
+#define S_EXP_S        (1<<7)
+#define S_FIND         (1<<8)
+
+#define mvBit(in,ib,ob) ((unsigned char)(((unsigned)in) * (ob) / (ib)))
 
 typedef struct sync_rec {
 	struct sync_rec *next;
 	/* string_list_t *keywords; */
-	int muid, suid;
-	unsigned char flags, status;
+	int uid[2];
+	message_t *msg[2];
+	unsigned char status, flags, aflags[2], dflags[2];
+	char tuid[TUIDL];
 } sync_rec_t;
 
 
-#define EX_OK           0
-#define EX_FAIL         1
-#define EX_STORE_BAD    2
-#define EX_RSTORE_BAD   3
-
-static int
-expunge( store_t *ctx, store_t *rctx )
-{
-	driver_t *driver = ctx->conf->driver, *rdriver = rctx->conf->driver;
-	message_t *msg;
-	msg_data_t msgdata;
-
-	for (msg = ctx->msgs; msg; msg = msg->next)
-		if (msg->flags & F_DELETED) {
-			if (ctx->conf->trash) {
-				if (!ctx->conf->trash_only_new || (msg->status & M_NOT_SYNCED)) {
-					debug( "  trashing message %d\n", msg->uid );
-					switch (driver->trash_msg( ctx, msg )) {
-					case DRV_STORE_BAD: return EX_STORE_BAD;
-					default: return EX_FAIL;
-					case DRV_OK: break;
-					}
-				} else
-					debug( "  not trashing message %d - not new\n", msg->uid );
-			} else if (rctx->conf->trash && rctx->conf->trash_remote_new) {
-				if (msg->status & M_NOT_SYNCED) {
-					if (!rctx->conf->max_size || msg->size <= rctx->conf->max_size) {
-						debug( "  remote trashing message %d\n", msg->uid );
-						msgdata.flags = msg->flags;
-						switch (driver->fetch_msg( ctx, msg, &msgdata )) {
-						case DRV_STORE_BAD: return EX_STORE_BAD;
-						default: return EX_FAIL;
-						case DRV_OK: break;
-						}
-						switch (rdriver->store_msg( rctx, &msgdata, 0 )) {
-						case DRV_STORE_BAD: return EX_RSTORE_BAD;
-						default: return EX_FAIL;
-						case DRV_OK: break;
-						}
-					} else
-						debug( "  not remote trashing message %d - too big\n", msg->uid );
-				} else
-					debug( "  not remote trashing message %d - not new\n", msg->uid );
-			}
-		}
-
-	switch (driver->close( ctx )) {
-	case DRV_STORE_BAD: return EX_STORE_BAD;
-	default: return EX_FAIL;
-	case DRV_OK: return EX_OK;;
-	}
-}
-
 /* cases:
    a) both non-null
    b) only master null
-   b.1) muid 0
-   b.2) muid -1
+   b.1) uid[M] 0
+   b.2) uid[M] -1
    b.3) master not scanned
    b.4) master gone
    c) only slave null
-   c.1) suid 0
-   c.2) suid -1
+   c.1) uid[S] 0
+   c.2) uid[S] -1
    c.3) slave not scanned
    c.4) slave gone
    d) both null
    d.1) both gone
-   d.2) muid 0, slave not scanned
-   d.3) muid -1, slave not scanned
+   d.2) uid[M] 0, slave not scanned
+   d.3) uid[M] -1, slave not scanned
    d.4) master gone, slave not scanned
-   d.5) muid 0, slave gone
-   d.6) muid -1, slave gone
-   d.7) suid 0, master not scanned
-   d.8) suid -1, master not scanned
+   d.5) uid[M] 0, slave gone
+   d.6) uid[M] -1, slave gone
+   d.7) uid[S] 0, master not scanned
+   d.8) uid[S] -1, master not scanned
    d.9) slave gone, master not scanned
-   d.10) suid 0, master gone
-   d.11) suid -1, master gone
-   impossible cases: both muid & suid 0 or -1, both not scanned
+   d.10) uid[S] 0, master gone
+   d.11) uid[S] -1, master gone
+   impossible cases: both uid[M] & uid[S] 0 or -1, both not scanned
 */
-static int
-sync_old( int tops, store_t *sctx, store_t *tctx, store_conf_t *tconf, FILE *jfp, int pull,
-          unsigned char *nflags, sync_rec_t *srec, message_t *smsg, message_t *tmsg, int dels, int delt )
-{
-	driver_t *tdriver = tctx->conf->driver, *sdriver = sctx->conf->driver;
-	int uid, tuid, unex;
-	unsigned char sflags, aflags, dflags;
-	msg_data_t msgdata;
-
-	/* excludes (push) c.3) d.2) d.3) d.4) / (pull) b.3) d.7) d.8) d.9) */
-	tuid = pull ? srec->suid : srec->muid;
-	if (!tuid) {
-		/* b.1) / c.1) */
-		debug( pull ? "  no more slave\n" : "  no more master\n" );
-	} else if (dels) {
-		/* c.4) d.9) / b.4) d.4) */
-		debug( pull ? "  master vanished\n" : "  slave vanished\n" );
-		if (tmsg && tmsg->flags != *nflags)
-			info( "Info: conflicting changes in (%d,%d)\n", srec->muid, srec->suid );
-		if (tops & OP_DELETE) {
-			debug( pull ? "  -> pulling delete\n" : "  -> pushing delete\n" );
-			switch (tdriver->set_flags( tctx, tmsg, tuid, F_DELETED, 0 )) {
-			case DRV_STORE_BAD: return pull ? SYNC_SLAVE_BAD : SYNC_MASTER_BAD;
-			case DRV_BOX_BAD: return SYNC_FAIL;
-			default: /* ok */ break;
-			case DRV_OK:
-				if (pull) {
-					Fprintf( jfp, "< %d %d 0\n", srec->muid, srec->suid );
-					srec->muid = 0;
-				} else {
-					Fprintf( jfp, "> %d %d 0\n", srec->muid, srec->suid );
-					srec->suid = 0;
-				}
-			}
-		}
-	} else if (!smsg)
-		/* c.1) c.2) d.7) d.8) / b.1) b.2) d.2) d.3) */
-		;
-	else if (tuid < 0) {
-		/* b.2) / c.2) */
-		debug( pull ? "  no slave yet\n" : "  no master yet\n" );
-		if (tops & OP_RENEW) {
-			if ((tops & OP_EXPUNGE) && (smsg->flags & F_DELETED)) {
-				debug( pull ? "  -> not pulling - would be expunged anyway\n" : "  -> not pushing - would be expunged anyway\n" );
-				smsg->status |= M_NOT_SYNCED;
-			} else {
-				if ((smsg->flags & F_FLAGGED) || !tconf->max_size || smsg->size <= tconf->max_size) {
-					debug( pull ? "  -> pulling it\n" : "  -> pushing it\n" );
-					msgdata.flags = smsg->flags;
-					switch (sdriver->fetch_msg( sctx, smsg, &msgdata )) {
-					case DRV_STORE_BAD: return pull ? SYNC_MASTER_BAD : SYNC_SLAVE_BAD;
-					case DRV_BOX_BAD: return SYNC_FAIL;
-					default: /* ok */ smsg->status |= M_NOT_SYNCED; break;
-					case DRV_OK:
-						smsg->flags = msgdata.flags;
-						switch (tdriver->store_msg( tctx, &msgdata, &uid )) {
-						case DRV_MSG_BAD:
-							warn( pull ?
-							      "Warning: Slave refuses to store message %d from master.\n" :
-							      "Warning: Master refuses to store message %d from slave.\n",
-							      smsg->uid );
-							smsg->status |= M_NOT_SYNCED;
-							break;
-						case DRV_STORE_BAD: return pull ? SYNC_SLAVE_BAD : SYNC_MASTER_BAD;
-						default: return SYNC_FAIL;
-						case DRV_OK:
-							if (pull) {
-								srec->suid = uid;
-								Fprintf( jfp, "> %d -1 %d\n", srec->muid, srec->suid );
-							} else {
-								srec->muid = uid;
-								Fprintf( jfp, "< -1 %d %d\n", srec->suid, srec->muid );
-							}
-							*nflags = smsg->flags;
-						}
-					}
-				} else {
-					debug( pull ? "  -> not pulling - still too big\n" : "  -> not pushing - still too big\n" );
-					smsg->status |= M_NOT_SYNCED;
-				}
-			}
-		} else
-			smsg->status |= M_NOT_SYNCED;
-	} else if (!delt) {
-		/* a) & b.3) / c.3) */
-		debug( pull ? "  may pull\n" : "  may push\n" );
-		if (tops & OP_FLAGS) {
-			debug( pull ? "  -> pulling flags\n" : "  -> pushing flags\n" );
-			sflags = smsg->flags;
-			aflags = sflags & ~*nflags;
-			dflags = ~sflags & *nflags;
-			unex = 0;
-			if (srec->status & S_EXPIRED) {
-				if (!pull) {
-					if ((aflags & ~F_DELETED) || dflags)
-						info( "Info: Flags of expired message changed in (%d,%d)\n", srec->muid, srec->suid );
-					return SYNC_OK;
-				} else {
-					if ((sflags & F_FLAGGED) && !(sflags & F_DELETED)) {
-						unex = 1;
-						dflags |= F_DELETED;
-					} else
-						return SYNC_OK;
+
+typedef struct {
+	int t[2];
+	void (*cb)( int sts, void *aux ), *aux;
+	char *dname, *jname, *nname, *lname;
+	FILE *jfp, *nfp;
+	sync_rec_t *srecs, **srecadd, **osrecadd;
+	channel_conf_t *chan;
+	store_t *ctx[2];
+	driver_t *drv[2];
+	int state[2], ret;
+	int new_total[2], new_done[2];
+	int flags_total[2], flags_done[2];
+	int trash_total[2], trash_done[2];
+	int maxuid[2], uidval[2], uidnext[2], smaxxuid, lfd;
+} sync_vars_t;
+
+#define AUX &svars->t[t]
+#define SVARS(aux) \
+	int t = *(int *)aux; \
+	sync_vars_t *svars = (sync_vars_t *)(((char *)(&((int *)aux)[-t])) - offsetof(sync_vars_t, t));
+
+/* operation dependencies:
+   select(S): -
+   select(M): select(S) | -
+   new(M), new(S), flags(M): select(M) & select(S)
+   flags(S): count(new(S))
+   find_new(x): new(x)
+   trash(x): flags(x)
+   close(x): trash(x) & find_new(x) // with expunge
+   cleanup: close(M) & close(S)
+*/
+
+#define ST_LOADED          (1<<0)
+#define ST_SENT_NEW        (1<<1)
+#define ST_FOUND_NEW       (1<<2)
+#define ST_SENT_FLAGS      (1<<3)
+#define ST_SENT_TRASH      (1<<4)
+#define ST_CLOSED          (1<<5)
+#define ST_SENT_CANCEL     (1<<6)
+#define ST_CANCELED        (1<<7)
+#define ST_SELECTED        (1<<8)
+
+#define ST_DID_EXPUNGE     (1<<16)
+
+
+static void
+match_tuids( sync_vars_t *svars, int t )
+{
+	sync_rec_t *srec;
+	message_t *tmsg, *ntmsg = 0;
+	const char *diag;
+
+	for (srec = svars->srecs; srec; srec = srec->next) {
+		if (srec->status & S_DEAD)
+			continue;
+		if (srec->uid[t] == -2 && srec->tuid[0]) {
+			debug( "  pair(%d,%d): lookup %s, TUID %." stringify(TUIDL) "s\n", srec->uid[M], srec->uid[S], str_ms[t], srec->tuid );
+			for (tmsg = ntmsg; tmsg; tmsg = tmsg->next) {
+				if (tmsg->status & M_DEAD)
+					continue;
+				if (tmsg->tuid[0] && !memcmp( tmsg->tuid, srec->tuid, TUIDL )) {
+					diag = (tmsg == ntmsg) ? "adjacently" : "after gap";
+					goto mfound;
 				}
 			}
-			if ((tops & OP_EXPUNGE) && (sflags & F_DELETED) &&
-			    (!tctx->conf->trash || tctx->conf->trash_only_new))
-			{
-				aflags &= F_DELETED;
-				dflags = 0;
-			}
-			switch ((aflags | dflags) ? tdriver->set_flags( tctx, tmsg, tuid, aflags, dflags ) : DRV_OK) {
-			case DRV_STORE_BAD: return pull ? SYNC_SLAVE_BAD : SYNC_MASTER_BAD;
-			case DRV_BOX_BAD: return SYNC_FAIL;
-			default: /* ok */ break;
-			case DRV_OK:
-				*nflags = (*nflags | aflags) & ~dflags;
-				if (unex) {
-					debug( "unexpiring pair(%d,%d)\n", srec->muid, srec->suid );
-					/* log last, so deletion can't be misinterpreted! */
-					Fprintf( jfp, "~ %d %d 0\n", srec->muid, srec->suid );
-					srec->status &= ~S_EXPIRED;
+			for (tmsg = svars->ctx[t]->msgs; tmsg != ntmsg; tmsg = tmsg->next) {
+				if (tmsg->status & M_DEAD)
+					continue;
+				if (tmsg->tuid[0] && !memcmp( tmsg->tuid, srec->tuid, TUIDL )) {
+					diag = "after reset";
+					goto mfound;
 				}
 			}
+			debug( "  -> TUID lost\n" );
+			Fprintf( svars->jfp, "& %d %d\n", srec->uid[M], srec->uid[S] );
+			srec->flags = 0;
+			srec->tuid[0] = 0;
+			continue;
+		  mfound:
+			debug( "  -> new UID %d %s\n", tmsg->uid, diag );
+			Fprintf( svars->jfp, "%c %d %d %d\n", "<>"[t], srec->uid[M], srec->uid[S], tmsg->uid );
+			tmsg->srec = srec;
+			ntmsg = tmsg->next;
+			srec->uid[t] = tmsg->uid;
+			srec->tuid[0] = 0;
 		}
-	} /* else b.4) / c.4) */
-	return SYNC_OK;
+	}
 }
 
+
+typedef struct copy_vars {
+	int (*cb)( int sts, int uid, struct copy_vars *vars );
+	void *aux;
+	sync_rec_t *srec; /* also ->tuid */
+	message_t *msg;
+	msg_data_t data;
+} copy_vars_t;
+
+static int msg_fetched( int sts, void *aux );
+
 static int
-sync_new( int tops, store_t *sctx, store_t *tctx, store_conf_t *tconf, FILE *jfp, sync_rec_t ***srecadd, int pull, int *smaxuid )
+copy_msg( copy_vars_t *vars )
 {
-	driver_t *tdriver = tctx->conf->driver, *sdriver = sctx->conf->driver;
-	sync_rec_t *srec;
-	message_t *msg;
-	int nmsgs, uid;
-	msg_data_t msgdata;
-
-	for (nmsgs = 0, msg = sctx->msgs; msg; msg = msg->next)
-		if (!(msg->status & M_PROCESSED)) {
-			if (tops & OP_NEW) {
-				debug( pull ? "new message %d on master\n" : "new message %d on slave\n", msg->uid );
-				if ((tops & OP_EXPUNGE) && (msg->flags & F_DELETED)) {
-					debug( pull ? "  not pulling - would be expunged anyway\n" : "  not pushing - would be expunged anyway\n" );
-					msg->status |= M_NOT_SYNCED;
-				} else {
-					if ((msg->flags & F_FLAGGED) || !tconf->max_size || msg->size <= tconf->max_size) {
-						debug( pull ? "  pulling it\n" : "  pushing it\n" );
-						if (!nmsgs)
-							info( pull ? "Pulling new messages..." : "Pushing new messages..." );
-						else
-							infoc( '.' );
-						nmsgs++;
-						msgdata.flags = msg->flags;
-						switch (sdriver->fetch_msg( sctx, msg, &msgdata )) {
-						case DRV_STORE_BAD: return pull ? SYNC_MASTER_BAD : SYNC_SLAVE_BAD;
-						case DRV_BOX_BAD: return SYNC_FAIL;
-						case DRV_MSG_BAD: /* ok */ msg->status |= M_NOT_SYNCED; continue;
+	SVARS(vars->aux)
+
+	vars->data.flags = vars->msg->flags;
+	return svars->drv[1-t]->fetch_msg( svars->ctx[1-t], vars->msg, &vars->data, msg_fetched, vars );
+}
+
+static int msg_stored( int sts, int uid, void *aux );
+
+static int
+msg_fetched( int sts, void *aux )
+{
+	copy_vars_t *vars = (copy_vars_t *)aux;
+	SVARS(vars->aux)
+	char *fmap, *buf;
+	int i, len, extra, scr, tcr, lcrs, hcrs, bcrs, lines;
+	int start, sbreak = 0, ebreak = 0;
+	char c;
+
+	switch (sts) {
+	case DRV_OK:
+		if (svars->state[t] & (ST_CANCELED | ST_SENT_CANCEL)) {
+			free( vars->data.data );
+			return vars->cb( SYNC_CANCELED, 0, vars );
+		}
+
+		vars->msg->flags = vars->data.flags;
+
+		scr = (svars->drv[1-t]->flags / DRV_CRLF) & 1;
+		tcr = (svars->drv[t]->flags / DRV_CRLF) & 1;
+		if (vars->srec || scr != tcr) {
+			fmap = vars->data.data;
+			len = vars->data.len;
+			extra = lines = hcrs = bcrs = i = 0;
+			if (vars->srec) {
+			  nloop:
+				start = i;
+				lcrs = 0;
+				while (i < len) {
+					c = fmap[i++];
+					if (c == '\r')
+						lcrs++;
+					else if (c == '\n') {
+						if (!memcmp( fmap + start, "X-TUID: ", 8 )) {
+							extra = (sbreak = start) - (ebreak = i);
+							goto oke;
 						}
-						msg->flags = msgdata.flags;
-						switch (tdriver->store_msg( tctx, &msgdata, &uid )) {
-						case DRV_MSG_BAD:
-							warn( pull ?
-							      "Warning: Slave refuses to store message %d from master.\n" :
-							      "Warning: Master refuses to store message %d from slave.\n",
-							      msg->uid );
-							msg->status |= M_NOT_SYNCED;
-							continue;
-						case DRV_STORE_BAD: return pull ? SYNC_SLAVE_BAD : SYNC_MASTER_BAD;
-						default: return SYNC_FAIL;
-						case DRV_OK: break;
+						lines++;
+						hcrs += lcrs;
+						if (i - lcrs - 1 == start) {
+							sbreak = ebreak = start;
+							goto oke;
 						}
-					} else {
-						debug( pull ? "  not pulling - too big\n" : "  not pushing - too big\n" );
-						msg->status |= M_NOT_SYNCED;
-						uid = -1;
+						goto nloop;
 					}
-					srec = nfmalloc( sizeof(*srec) );
-					if (pull) {
-						srec->muid = msg->uid;
-						srec->suid = uid;
+				}
+				/* invalid message */
+				warn( "Warning: message %d from %s has incomplete header.\n",
+				      vars->msg->uid, str_ms[1-t] );
+				free( fmap );
+				return vars->cb( SYNC_NOGOOD, 0, vars );
+			  oke:
+				extra += 8 + TUIDL + 1 + (tcr && (!scr || hcrs));
+			}
+			if (tcr != scr) {
+				for (; i < len; i++) {
+					c = fmap[i];
+					if (c == '\r')
+						bcrs++;
+					else if (c == '\n')
+						lines++;
+				}
+				extra -= hcrs + bcrs;
+				if (tcr)
+					extra += lines;
+			}
+
+			vars->data.len = len + extra;
+			buf = vars->data.data = nfmalloc( vars->data.len );
+			i = 0;
+			if (vars->srec) {
+				if (tcr != scr) {
+					if (tcr) {
+						for (; i < sbreak; i++)
+							if ((c = fmap[i]) != '\r') {
+								if (c == '\n')
+									*buf++ = '\r';
+								*buf++ = c;
+							}
 					} else {
-						srec->muid = uid;
-						srec->suid = msg->uid;
-					}
-					srec->flags = msg->flags;
-					srec->status = 0;
-					srec->next = 0;
-					**srecadd = srec;
-					*srecadd = &srec->next;
-					Fprintf( jfp, "+ %d %d %u\n", srec->muid, srec->suid, srec->flags );
-					if (*smaxuid < msg->uid) {
-						*smaxuid = msg->uid;
-						Fprintf( jfp, pull ? "( %d\n" : ") %d\n", msg->uid );
+						for (; i < sbreak; i++)
+							if ((c = fmap[i]) != '\r')
+								*buf++ = c;
 					}
+				} else {
+					memcpy( buf, fmap, sbreak );
+					buf += sbreak;
+				}
+
+				memcpy( buf, "X-TUID: ", 8 );
+				buf += 8;
+				memcpy( buf, vars->srec->tuid, TUIDL );
+				buf += TUIDL;
+				if (tcr && (!scr || hcrs))
+					*buf++ = '\r';
+				*buf++ = '\n';
+				i = ebreak;
+			}
+			if (tcr != scr) {
+				if (tcr) {
+					for (; i < len; i++)
+						if ((c = fmap[i]) != '\r') {
+							if (c == '\n')
+								*buf++ = '\r';
+							*buf++ = c;
+						}
+				} else {
+					for (; i < len; i++)
+						if ((c = fmap[i]) != '\r')
+							*buf++ = c;
 				}
 			} else
-				msg->status |= M_NOT_SYNCED;
+				memcpy( buf, fmap + i, len - i );
+
+			free( fmap );
+		}
+
+		return svars->drv[t]->store_msg( svars->ctx[t], &vars->data, !vars->srec, msg_stored, vars );
+	case DRV_CANCELED:
+		return vars->cb( SYNC_CANCELED, 0, vars );
+	case DRV_MSG_BAD:
+		return vars->cb( SYNC_NOGOOD, 0, vars );
+	default:
+		return vars->cb( SYNC_FAIL, 0, vars );
+	}
+}
+
+static int
+msg_stored( int sts, int uid, void *aux )
+{
+	copy_vars_t *vars = (copy_vars_t *)aux;
+	SVARS(vars->aux)
+
+	(void)svars;
+	switch (sts) {
+	case DRV_OK:
+		return vars->cb( SYNC_OK, uid, vars );
+	case DRV_CANCELED:
+		return vars->cb( SYNC_CANCELED, 0, vars );
+	case DRV_MSG_BAD:
+		warn( "Warning: %s refuses to store message %d from %s.\n",
+		      str_ms[t], vars->msg->uid, str_ms[1-t] );
+		return vars->cb( SYNC_NOGOOD, 0, vars );
+	default:
+		return vars->cb( SYNC_FAIL, 0, vars );
+	}
+}
+
+
+static void
+stats( sync_vars_t *svars )
+{
+	char buf[2][64];
+	char *cs;
+	int t, l;
+	static int cols = -1;
+
+	if (cols < 0 && (!(cs = getenv( "COLUMNS" )) || !(cols = atoi( cs ) / 2)))
+		cols = 36;
+	if (!(DFlags & QUIET)) {
+		for (t = 0; t < 2; t++) {
+			l = sprintf( buf[t], "+%d/%d *%d/%d #%d/%d",
+			             svars->new_done[t], svars->new_total[t],
+			             svars->flags_done[t], svars->flags_total[t],
+			             svars->trash_done[t], svars->trash_total[t] );
+			if (l > cols)
+				buf[t][cols - 1] = '~';
 		}
-	if (nmsgs)
-		info( " %d messages\n", nmsgs );
-	return SYNC_OK;
+		infon( "\rM: %.*s  S: %.*s", cols, buf[0], cols, buf[1] );
+	}
+}
+
+
+static void sync_bail( sync_vars_t *svars );
+static void sync_bail1( sync_vars_t *svars );
+static void sync_bail2( sync_vars_t *svars );
+static void cancel_done( void *aux );
+
+static void
+cancel_sync( sync_vars_t *svars )
+{
+	int t;
+
+	/* the 1st round is guaranteed not to trash svars (see ST_CANCELED) */
+	for (t = 0; t < 2; t++)
+		if (svars->ret & SYNC_BAD(t)) {
+			cancel_done( AUX );
+		} else if (!(svars->state[t] & ST_SENT_CANCEL)) {
+			/* ignore subsequent failures from in-flight commands */
+			svars->state[t] |= ST_SENT_CANCEL;
+			svars->drv[t]->cancel( svars->ctx[t], cancel_done, AUX );
+		}
+}
+
+static void
+cancel_done( void *aux )
+{
+	SVARS(aux)
+
+	svars->state[t] |= ST_CANCELED;
+	if (svars->state[1-t] & ST_CANCELED) {
+		Fclose( svars->nfp );
+		Fclose( svars->jfp );
+		sync_bail( svars );
+	}
+}
+
+static void
+store_bad( void *aux )
+{
+	SVARS(aux)
+
+	svars->ret |= SYNC_BAD(t);
+	svars->drv[t]->cancel_store( svars->ctx[t] );
+	cancel_sync( svars );
+}
+
+static int
+check_ret( int sts, sync_vars_t *svars )
+{
+	if (sts == DRV_BOX_BAD) {
+		svars->ret |= SYNC_FAIL;
+		cancel_sync( svars );
+		return -1;
+	}
+	if ((svars->state[M] | svars->state[S]) & (ST_CANCELED | ST_SENT_CANCEL))
+		return -1;
+	return 0;
+}
+
+static int
+check_ret_aux( int sts, sync_vars_t *svars, void *aux )
+{
+	if (!check_ret( sts, svars ))
+		return 0;
+	free( aux );
+	return -1;
 }
 
+
 static char *
 clean_strdup( const char *s )
 {
@@ -462,70 +501,107 @@ clean_strdup( const char *s )
 	return cs;
 }
 
-int
-sync_boxes( store_t *mctx, const char *mname,
-            store_t *sctx, const char *sname,
-            channel_conf_t *chan )
-{
-	driver_t *mdriver = mctx->conf->driver, *sdriver = sctx->conf->driver;
-	message_t *mmsg, *smsg, *nmmsg, *nsmsg;
-	sync_rec_t *recs, *srec, **srecadd, *nsrec;
-	char *dname, *jname, *nname, *lname, *s, *cmname, *csname;
-	FILE *dfp, *jfp, *nfp;
-	int mopts, sopts;
-	int nom, nos, delm, dels, mex, sex;
-	int muidval, suidval, smaxxuid, mmaxuid, smaxuid, minwuid, maxwuid;
-	int t1, t2, t3;
-	int lfd, ret, line, todel, delt, i, *mexcs, nmexcs, rmexcs;
-	unsigned char nflags;
+
+#define JOURNAL_VERSION "2"
+
+static int box_selected( int sts, void *aux );
+
+void
+sync_boxes( store_t *ctx[], const char *names[], channel_conf_t *chan,
+            void (*cb)( int sts, void *aux ), void *aux )
+{
+	sync_vars_t *svars;
+	int t;
+
+	svars = nfcalloc( sizeof(*svars) );
+	svars->t[1] = 1;
+	svars->cb = cb;
+	svars->aux = aux;
+	svars->ctx[0] = ctx[0];
+	svars->ctx[1] = ctx[1];
+	svars->chan = chan;
+	svars->uidval[0] = svars->uidval[1] = -1;
+	svars->srecadd = &svars->srecs;
+
+	for (t = 0; t < 2; t++) {
+		ctx[t]->name =
+			(!names[t] || (ctx[t]->conf->map_inbox && !strcmp( ctx[t]->conf->map_inbox, names[t] ))) ?
+				"INBOX" : names[t];
+		ctx[t]->uidvalidity = -1;
+		set_bad_callback( ctx[t], store_bad, AUX );
+		svars->drv[t] = ctx[t]->conf->driver;
+		info( "Selecting %s %s...\n", str_ms[t], ctx[t]->name );
+		if (svars->drv[t]->select( ctx[t], (chan->ops[t] & OP_CREATE) != 0, box_selected, AUX ))
+			return;
+	}
+}
+
+static int load_box( sync_vars_t *svars, int t, int minwuid, int *mexcs, int nmexcs );
+
+static int
+box_selected( int sts, void *aux )
+{
+	SVARS(aux)
+	sync_rec_t *srec, *nsrec;
+	char *s, *cmname, *csname;
+	store_t *ctx[2];
+	channel_conf_t *chan;
+	FILE *jfp;
+	int opts[2], line, t1, t2, t3;
 	struct stat st;
 	struct flock lck;
 	char fbuf[16]; /* enlarge when support for keywords is added */
-	char buf[64];
-
-	ret = SYNC_OK;
-	recs = 0, srecadd = &recs;
-
-	nmmsg = nsmsg = 0;
-
-	mctx->uidvalidity = sctx->uidvalidity = -1;
-	mopts = sopts = 0;
-	makeopts( chan->sops, chan->slave, &sopts, chan->master, &mopts );
-	makeopts( chan->mops, chan->master, &mopts, chan->slave, &sopts );
-	if ((chan->sops & (OP_NEW|OP_RENEW)) && chan->max_messages)
-		sopts |= OPEN_OLD|OPEN_NEW|OPEN_FLAGS;
-	if (!mname || (mctx->conf->map_inbox && !strcmp( mctx->conf->map_inbox, mname )))
-		mname = "INBOX";
-	mctx->name = mname;
-	mdriver->prepare( mctx, mopts );
-	if (!sname || (sctx->conf->map_inbox && !strcmp( sctx->conf->map_inbox, sname )))
-		sname = "INBOX";
-	sctx->name = sname;
-	sdriver->prepare( sctx, sopts );
+	char buf[128], buf1[64], buf2[64];
+
+	if (check_ret( sts, svars ))
+		return -1;
+	ctx[0] = svars->ctx[0];
+	ctx[1] = svars->ctx[1];
+	info( "%s: %d messages, %d recent\n", str_ms[t], ctx[t]->count, ctx[t]->recent );
+	svars->state[t] |= ST_SELECTED;
+	if (!(svars->state[1-t] & ST_SELECTED))
+		return 0;
 
+	chan = svars->chan;
 	if (!strcmp( chan->sync_state ? chan->sync_state : global_sync_state, "*" )) {
-		if (!sctx->path) {
-			fprintf( stderr, "Error: store '%s' does not support in-box sync state\n", chan->slave->name );
-			return SYNC_SLAVE_BAD;
+		if (!ctx[S]->path) {
+			error( "Error: store '%s' does not support in-box sync state\n", chan->stores[S]->name );
+			free( svars );
+			svars->cb( SYNC_BAD(S), svars->aux );
+			return -1;
 		}
-		nfasprintf( &dname, "%s/." EXE "state", sctx->path );
+		nfasprintf( &svars->dname, "%s/." EXE "state", ctx[S]->path );
 	} else {
-		csname = clean_strdup( sname );
+		csname = clean_strdup( ctx[S]->name );
 		if (chan->sync_state)
-			nfasprintf( &dname, "%s%s", chan->sync_state, csname );
+			nfasprintf( &svars->dname, "%s%s", chan->sync_state, csname );
 		else {
-			cmname = clean_strdup( mname );
-			nfasprintf( &dname, "%s:%s:%s_:%s:%s", global_sync_state,
-			            chan->master->name, cmname, chan->slave->name, csname );
+			cmname = clean_strdup( ctx[M]->name );
+			nfasprintf( &svars->dname, "%s:%s:%s_:%s:%s", global_sync_state,
+			            chan->stores[M]->name, cmname, chan->stores[S]->name, csname );
 			free( cmname );
 		}
 		free( csname );
+		if (!(s = strrchr( svars->dname, '/' ))) {
+			error( "Error: invalid SyncState location '%s'\n", svars->dname );
+			free( svars->dname );
+			free( svars );
+			svars->cb( SYNC_BAD(S), svars->aux );
+			return -1;
+		}
+		*s = 0;
+		if (mkdir( svars->dname, 0700 ) && errno != EEXIST) {
+			sys_error( "Error: cannot create SyncState directory '%s'", svars->dname );
+			free( svars->dname );
+			free( svars );
+			svars->cb( SYNC_BAD(S), svars->aux );
+			return -1;
+		}
+		*s = '/';
 	}
-	nfasprintf( &jname, "%s.journal", dname );
-	nfasprintf( &nname, "%s.new", dname );
-	nfasprintf( &lname, "%s.lock", dname );
-	muidval = suidval = -1;
-	smaxxuid = mmaxuid = smaxuid = 0;
+	nfasprintf( &svars->jname, "%s.journal", svars->dname );
+	nfasprintf( &svars->nname, "%s.new", svars->dname );
+	nfasprintf( &svars->lname, "%s.lock", svars->dname );
 	memset( &lck, 0, sizeof(lck) );
 #if SEEK_SET != 0
 	lck.l_whence = SEEK_SET;
@@ -533,161 +609,194 @@ sync_boxes( store_t *mctx, const char *mname,
 #if F_WRLCK != 0
 	lck.l_type = F_WRLCK;
 #endif
-	if ((lfd = open( lname, O_WRONLY|O_CREAT, 0666 )) < 0) {
-		if (errno != ENOENT) {
-		  lferr:
-			fprintf( stderr, "Error: cannot create lock file %s: %s\n", lname, strerror(errno) );
-			ret = SYNC_FAIL;
-			goto bail2;
-		}
-		goto skiprd;
-	}
-	if (fcntl( lfd, F_SETLK, &lck )) {
-	  lckerr:
-		fprintf( stderr, "Error: channel :%s:%s-:%s:%s is locked\n",
-		         chan->master->name, mname, chan->slave->name, sname );
-		ret = SYNC_FAIL;
-		goto bail1;
-	}
-	if ((dfp = fopen( dname, "r" ))) {
-		debug( "reading sync state %s ...\n", dname );
-		if (!fgets( buf, sizeof(buf), dfp ) || !(i = strlen( buf )) || buf[i - 1] != '\n') {
-			fprintf( stderr, "Error: incomplete sync state header in %s\n", dname );
-			fclose( dfp );
-			ret = SYNC_FAIL;
-			goto bail;
+	if ((svars->lfd = open( svars->lname, O_WRONLY|O_CREAT, 0666 )) < 0) {
+		sys_error( "Error: cannot create lock file %s", svars->lname );
+		svars->ret = SYNC_FAIL;
+		sync_bail2( svars );
+		return -1;
+	}
+	if (fcntl( svars->lfd, F_SETLK, &lck )) {
+		error( "Error: channel :%s:%s-:%s:%s is locked\n",
+		         chan->stores[M]->name, ctx[M]->name, chan->stores[S]->name, ctx[S]->name );
+		svars->ret = SYNC_FAIL;
+		sync_bail1( svars );
+		return -1;
+	}
+	if ((jfp = fopen( svars->dname, "r" ))) {
+		debug( "reading sync state %s ...\n", svars->dname );
+		if (!fgets( buf, sizeof(buf), jfp ) || !(t = strlen( buf )) || buf[t - 1] != '\n') {
+			error( "Error: incomplete sync state header in %s\n", svars->dname );
+		  jbail:
+			fclose( jfp );
+		  bail:
+			svars->ret = SYNC_FAIL;
+			sync_bail( svars );
+			return -1;
 		}
-		if (sscanf( buf, "%d:%d %d:%d:%d", &muidval, &mmaxuid, &suidval, &smaxxuid, &smaxuid) != 5) {
-			fprintf( stderr, "Error: invalid sync state header in %s\n", dname );
-			fclose( dfp );
-			ret = SYNC_FAIL;
-			goto bail;
+		if (sscanf( buf, "%63s %63s", buf1, buf2 ) != 2 ||
+		    sscanf( buf1, "%d:%d:%d", &svars->uidval[M], &svars->maxuid[M], &svars->uidnext[M] ) < 2 ||
+		    sscanf( buf2, "%d:%d:%d:%d", &svars->uidval[S], &svars->smaxxuid, &svars->maxuid[S], &svars->uidnext[S] ) < 3) {
+			error( "Error: invalid sync state header in %s\n", svars->dname );
+			goto jbail;
 		}
 		line = 1;
-		while (fgets( buf, sizeof(buf), dfp )) {
+		while (fgets( buf, sizeof(buf), jfp )) {
 			line++;
-			if (!(i = strlen( buf )) || buf[i - 1] != '\n') {
-				fprintf( stderr, "Error: incomplete sync state entry at %s:%d\n", dname, line );
-				fclose( dfp );
-				ret = SYNC_FAIL;
-				goto bail;
+			if (!(t = strlen( buf )) || buf[t - 1] != '\n') {
+				error( "Error: incomplete sync state entry at %s:%d\n", svars->dname, line );
+				goto jbail;
 			}
 			fbuf[0] = 0;
 			if (sscanf( buf, "%d %d %15s", &t1, &t2, fbuf ) < 2) {
-				fprintf( stderr, "Error: invalid sync state entry at %s:%d\n", dname, line );
-				fclose( dfp );
-				ret = SYNC_FAIL;
-				goto bail;
+				error( "Error: invalid sync state entry at %s:%d\n", svars->dname, line );
+				goto jbail;
 			}
 			srec = nfmalloc( sizeof(*srec) );
-			srec->muid = t1;
-			srec->suid = t2;
+			srec->uid[M] = t1;
+			srec->uid[S] = t2;
 			s = fbuf;
 			if (*s == 'X') {
 				s++;
-				srec->status = S_EXPIRED;
+				srec->status = S_EXPIRE | S_EXPIRED;
 			} else
 				srec->status = 0;
 			srec->flags = parse_flags( s );
-			debug( "  entry (%d,%d,%u,%s)\n", srec->muid, srec->suid, srec->flags, srec->status & S_EXPIRED ? "X" : "" );
+			debug( "  entry (%d,%d,%u,%s)\n", srec->uid[M], srec->uid[S], srec->flags, srec->status & S_EXPIRED ? "X" : "" );
+			srec->msg[M] = srec->msg[S] = 0;
+			srec->tuid[0] = 0;
 			srec->next = 0;
-			*srecadd = srec;
-			srecadd = &srec->next;
+			*svars->srecadd = srec;
+			svars->srecadd = &srec->next;
 		}
-		fclose( dfp );
+		fclose( jfp );
 	} else {
 		if (errno != ENOENT) {
-			fprintf( stderr, "Error: cannot read sync state %s\n", dname );
-			ret = SYNC_FAIL;
+			error( "Error: cannot read sync state %s\n", svars->dname );
 			goto bail;
 		}
 	}
-	if ((jfp = fopen( jname, "r" ))) {
-		if (!stat( nname, &st )) {
+	line = 0;
+	if ((jfp = fopen( svars->jname, "r" ))) {
+		if (!stat( svars->nname, &st ) && fgets( buf, sizeof(buf), jfp )) {
 			debug( "recovering journal ...\n" );
-			line = 0;
-			srec = recs;
+			if (!(t = strlen( buf )) || buf[t - 1] != '\n') {
+				error( "Error: incomplete journal header in %s\n", svars->jname );
+				goto jbail;
+			}
+			if (memcmp( buf, JOURNAL_VERSION "\n", strlen(JOURNAL_VERSION) + 1 )) {
+				error( "Error: incompatible journal version "
+				                 "(got %.*s, expected " JOURNAL_VERSION ")\n", t - 1, buf );
+				goto jbail;
+			}
+			srec = 0;
+			line = 1;
 			while (fgets( buf, sizeof(buf), jfp )) {
 				line++;
-				if (!(i = strlen( buf )) || buf[i - 1] != '\n') {
-					fprintf( stderr, "Error: incomplete journal entry at %s:%d\n", jname, line );
-					fclose( jfp );
-					ret = SYNC_FAIL;
-					goto bail;
+				if (!(t = strlen( buf )) || buf[t - 1] != '\n') {
+					error( "Error: incomplete journal entry at %s:%d\n", svars->jname, line );
+					goto jbail;
 				}
-				if (buf[0] == '^')
-					srec = recs;
-				else {
-					if (buf[0] == '(' || buf[0] == ')' ?
-					        (sscanf( buf + 2, "%d", &t1 ) != 1) :
-					    buf[0] == '-' || buf[0] == '|' ?
-						(sscanf( buf + 2, "%d %d", &t1, &t2 ) != 2) :
-						(sscanf( buf + 2, "%d %d %d", &t1, &t2, &t3 ) != 3))
-					{
-						fprintf( stderr, "Error: malformed journal entry at %s:%d\n", jname, line );
-						fclose( jfp );
-						ret = SYNC_FAIL;
-						goto bail;
-					}
-					if (buf[0] == '(')
-						mmaxuid = t1;
-					else if (buf[0] == ')')
-						smaxuid = t1;
-					else if (buf[0] == '|') {
-						muidval = t1;
-						suidval = t2;
-					} else if (buf[0] == '+') {
-						srec = nfmalloc( sizeof(*srec) );
-						srec->muid = t1;
-						srec->suid = t2;
+				if (buf[0] == '#' ?
+				      (t3 = 0, (sscanf( buf + 2, "%d %d %n", &t1, &t2, &t3 ) < 2) || !t3 || (t - t3 != TUIDL + 3)) :
+				      buf[0] == '(' || buf[0] == ')' || buf[0] == '{' || buf[0] == '}' ?
+				        (sscanf( buf + 2, "%d", &t1 ) != 1) :
+				        buf[0] == '+' || buf[0] == '&' || buf[0] == '-' || buf[0] == '|' || buf[0] == '/' || buf[0] == '\\' ?
+				          (sscanf( buf + 2, "%d %d", &t1, &t2 ) != 2) :
+				          (sscanf( buf + 2, "%d %d %d", &t1, &t2, &t3 ) != 3))
+				{
+					error( "Error: malformed journal entry at %s:%d\n", svars->jname, line );
+					goto jbail;
+				}
+				if (buf[0] == '(')
+					svars->maxuid[M] = t1;
+				else if (buf[0] == ')')
+					svars->maxuid[S] = t1;
+				else if (buf[0] == '{')
+					svars->uidnext[M] = t1;
+				else if (buf[0] == '}')
+					svars->uidnext[S] = t1;
+				else if (buf[0] == '|') {
+					svars->uidval[M] = t1;
+					svars->uidval[S] = t2;
+				} else if (buf[0] == '+') {
+					srec = nfmalloc( sizeof(*srec) );
+					srec->uid[M] = t1;
+					srec->uid[S] = t2;
+					debug( "  new entry(%d,%d)\n", t1, t2 );
+					srec->msg[M] = srec->msg[S] = 0;
+					srec->status = 0;
+					srec->flags = 0;
+					srec->tuid[0] = 0;
+					srec->next = 0;
+					*svars->srecadd = srec;
+					svars->srecadd = &srec->next;
+				} else {
+					for (nsrec = srec; srec; srec = srec->next)
+						if (srec->uid[M] == t1 && srec->uid[S] == t2)
+							goto syncfnd;
+					for (srec = svars->srecs; srec != nsrec; srec = srec->next)
+						if (srec->uid[M] == t1 && srec->uid[S] == t2)
+							goto syncfnd;
+					error( "Error: journal entry at %s:%d refers to non-existing sync state entry\n", svars->jname, line );
+					goto jbail;
+				  syncfnd:
+					debugn( "  entry(%d,%d,%u) ", srec->uid[M], srec->uid[S], srec->flags );
+					switch (buf[0]) {
+					case '-':
+						debug( "killed\n" );
+						srec->status = S_DEAD;
+						break;
+					case '#':
+						debug( "TUID now %." stringify(TUIDL) "s\n", buf + t3 + 2 );
+						memcpy( srec->tuid, buf + t3 + 2, TUIDL );
+						break;
+					case '&':
+						debug( "TUID %." stringify(TUIDL) "s lost\n", srec->tuid );
+						srec->flags = 0;
+						srec->tuid[0] = 0;
+						break;
+					case '<':
+						debug( "master now %d\n", t3 );
+						srec->uid[M] = t3;
+						srec->tuid[0] = 0;
+						break;
+					case '>':
+						debug( "slave now %d\n", t3 );
+						srec->uid[S] = t3;
+						srec->tuid[0] = 0;
+						break;
+					case '*':
+						debug( "flags now %d\n", t3 );
 						srec->flags = t3;
-						debug( "  new entry(%d,%d,%u)\n", t1, t2, t3 );
-						srec->status = 0;
-						srec->next = 0;
-						*srecadd = srec;
-						srecadd = &srec->next;
-					} else {
-						for (; srec; srec = srec->next)
-							if (srec->muid == t1 && srec->suid == t2)
-								goto syncfnd;
-						fprintf( stderr, "Error: journal entry at %s:%d refers to non-existing sync state entry\n", jname, line );
-						fclose( jfp );
-						ret = SYNC_FAIL;
-						goto bail;
-					  syncfnd:
-						debug( "  entry(%d,%d,%u) ", srec->muid, srec->suid, srec->flags );
-						switch (buf[0]) {
-						case '-':
-							debug( "killed\n" );
-							srec->status = S_DEAD;
-							break;
-						case '<':
-							debug( "master now %d\n", t3 );
-							srec->muid = t3;
-							break;
-						case '>':
-							debug( "slave now %d\n", t3 );
-							srec->suid = t3;
-							break;
-						case '*':
-							debug( "flags now %d\n", t3 );
-							srec->flags = t3;
-							break;
-						case '~':
-							debug( "expired now %d\n", t3 );
-							if (t3) {
-								if (smaxxuid < t2)
-									smaxxuid = t2;
-								srec->status |= S_EXPIRED;
-							} else
-								srec->status &= ~S_EXPIRED;
-							break;
-						default:
-							fprintf( stderr, "Error: unrecognized journal entry at %s:%d\n", jname, line );
-							fclose( jfp );
-							ret = SYNC_FAIL;
-							goto bail;
-						}
+						break;
+					case '~':
+						debug( "expire now %d\n", t3 );
+						if (t3)
+							srec->status |= S_EXPIRE;
+						else
+							srec->status &= ~S_EXPIRE;
+						break;
+					case '\\':
+						t3 = (srec->status & S_EXPIRED);
+						debug( "expire back to %d\n", t3 / S_EXPIRED );
+						if (t3)
+							srec->status |= S_EXPIRE;
+						else
+							srec->status &= ~S_EXPIRE;
+						break;
+					case '/':
+						t3 = (srec->status & S_EXPIRE);
+						debug( "expired now %d\n", t3 / S_EXPIRE );
+						if (t3) {
+							if (svars->smaxxuid < srec->uid[S])
+								svars->smaxxuid = srec->uid[S];
+							srec->status |= S_EXPIRED;
+						} else
+							srec->status &= ~S_EXPIRED;
+						break;
+					default:
+						error( "Error: unrecognized journal entry at %s:%d\n", svars->jname, line );
+						goto jbail;
 					}
 				}
 			}
@@ -695,326 +804,863 @@ sync_boxes( store_t *mctx, const char *mname,
 		fclose( jfp );
 	} else {
 		if (errno != ENOENT) {
-			fprintf( stderr, "Error: cannot read journal %s\n", jname );
-			ret = SYNC_FAIL;
+			error( "Error: cannot read journal %s\n", svars->jname );
 			goto bail;
 		}
 	}
-  skiprd:
 
-	if (sctx->opts & OPEN_NEW)
+	for (t = 0; t < 2; t++)
+		if (svars->uidval[t] >= 0 && svars->uidval[t] != ctx[t]->uidvalidity) {
+			error( "Error: UIDVALIDITY of %s changed (got %d, expected %d)\n",
+			       str_ms[t], ctx[t]->uidvalidity, svars->uidval[t] );
+			goto bail;
+		}
+
+	if (!(svars->nfp = fopen( svars->nname, "w" ))) {
+		error( "Error: cannot write new sync state %s\n", svars->nname );
+		goto bail;
+	}
+	if (!(svars->jfp = fopen( svars->jname, "a" ))) {
+		error( "Error: cannot write journal %s\n", svars->jname );
+		fclose( svars->nfp );
+		goto bail;
+	}
+	setlinebuf( svars->jfp );
+	if (!line)
+		Fprintf( svars->jfp, JOURNAL_VERSION "\n" );
+
+	opts[M] = opts[S] = 0;
+	for (t = 0; t < 2; t++) {
+		if (chan->ops[t] & (OP_DELETE|OP_FLAGS)) {
+			opts[t] |= OPEN_SETFLAGS;
+			opts[1-t] |= OPEN_OLD;
+			if (chan->ops[t] & OP_FLAGS)
+				opts[1-t] |= OPEN_FLAGS;
+		}
+		if (chan->ops[t] & (OP_NEW|OP_RENEW)) {
+			opts[t] |= OPEN_APPEND;
+			if (chan->ops[t] & OP_RENEW)
+				opts[1-t] |= OPEN_OLD;
+			if (chan->ops[t] & OP_NEW)
+				opts[1-t] |= OPEN_NEW;
+			if (chan->ops[t] & OP_EXPUNGE)
+				opts[1-t] |= OPEN_FLAGS;
+			if (chan->stores[t]->max_size)
+				opts[1-t] |= OPEN_SIZE;
+		}
+		if (chan->ops[t] & OP_EXPUNGE) {
+			opts[t] |= OPEN_EXPUNGE;
+			if (chan->stores[t]->trash) {
+				if (!chan->stores[t]->trash_only_new)
+					opts[t] |= OPEN_OLD;
+				opts[t] |= OPEN_NEW|OPEN_FLAGS;
+			} else if (chan->stores[1-t]->trash && chan->stores[1-t]->trash_remote_new)
+				opts[t] |= OPEN_NEW|OPEN_FLAGS;
+		}
+	}
+	if ((chan->ops[S] & (OP_NEW|OP_RENEW)) && chan->max_messages)
+		opts[S] |= OPEN_OLD|OPEN_NEW|OPEN_FLAGS;
+	if (line)
+		for (srec = svars->srecs; srec; srec = srec->next) {
+			if (srec->status & S_DEAD)
+				continue;
+			if ((mvBit(srec->status, S_EXPIRE, S_EXPIRED) ^ srec->status) & S_EXPIRED)
+				opts[S] |= OPEN_OLD|OPEN_FLAGS;
+			if (srec->tuid[0]) {
+				if (srec->uid[M] == -2)
+					opts[M] |= OPEN_NEW|OPEN_FIND, svars->state[M] |= S_FIND;
+				else if (srec->uid[S] == -2)
+					opts[S] |= OPEN_NEW|OPEN_FIND, svars->state[S] |= S_FIND;
+			}
+		}
+	svars->drv[M]->prepare_opts( ctx[M], opts[M] );
+	svars->drv[S]->prepare_opts( ctx[S], opts[S] );
+
+	if (!svars->smaxxuid && load_box( svars, M, (ctx[M]->opts & OPEN_OLD) ? 1 : INT_MAX, 0, 0 ))
+		return -1;
+	return load_box( svars, S, (ctx[S]->opts & OPEN_OLD) ? 1 : INT_MAX, 0, 0 );
+}
+
+static int box_loaded( int sts, void *aux );
+
+static int
+load_box( sync_vars_t *svars, int t, int minwuid, int *mexcs, int nmexcs )
+{
+	sync_rec_t *srec;
+	int maxwuid;
+
+	if (svars->ctx[t]->opts & OPEN_NEW) {
+		if (minwuid > svars->maxuid[t] + 1)
+			minwuid = svars->maxuid[t] + 1;
 		maxwuid = INT_MAX;
-	else if (sctx->opts & OPEN_OLD) {
+	} else if (svars->ctx[t]->opts & OPEN_OLD) {
 		maxwuid = 0;
-		for (srec = recs; srec; srec = srec->next)
-			if (!(srec->status & S_DEAD) && srec->suid > maxwuid)
-				maxwuid = srec->suid;
+		for (srec = svars->srecs; srec; srec = srec->next)
+			if (!(srec->status & S_DEAD) && srec->uid[t] > maxwuid)
+				maxwuid = srec->uid[t];
 	} else
 		maxwuid = 0;
-	info( "Selecting slave %s... ", sname );
-	debug( maxwuid == INT_MAX ? "selecting slave [1,inf]\n" : "selecting slave [1,%d]\n", maxwuid );
-	switch (sdriver->select( sctx, (sctx->opts & OPEN_OLD) ? 1 : smaxuid + 1, maxwuid, 0, 0 )) {
-	case DRV_STORE_BAD: ret = SYNC_SLAVE_BAD; goto bail;
-	case DRV_BOX_BAD: ret = SYNC_FAIL; goto bail;
-	}
-	info( "%d messages, %d recent\n", sctx->count, sctx->recent );
-	dump_box( sctx );
-
-	if (suidval >= 0 && suidval != sctx->uidvalidity) {
-		fprintf( stderr, "Error: UIDVALIDITY of slave changed\n" );
-		ret = SYNC_FAIL;
-		goto bail;
-	}
+	info( "Loading %s...\n", str_ms[t] );
+	debug( maxwuid == INT_MAX ? "loading %s [%d,inf]\n" : "loading %s [%d,%d]\n", str_ms[t], minwuid, maxwuid );
+	return svars->drv[t]->load( svars->ctx[t], minwuid, maxwuid, svars->uidnext[t], mexcs, nmexcs, box_loaded, AUX );
+}
 
-	if ((s = strrchr( dname, '/' ))) {
-		*s = 0;
-		mkdir( dname, 0700 );
-		*s = '/';
-	}
-	if (lfd < 0) {
-		if ((lfd = open( lname, O_WRONLY|O_CREAT, 0666 )) < 0)
-			goto lferr;
-		if (fcntl( lfd, F_SETLK, &lck ))
-			goto lckerr;
-	}
-	if (!(nfp = fopen( nname, "w" ))) {
-		fprintf( stderr, "Error: cannot write new sync state %s\n", nname );
-		ret = SYNC_FAIL;
-		goto bail;
+typedef struct {
+	void *aux;
+	sync_rec_t *srec;
+	int aflags, dflags;
+} flag_vars_t;
+
+static int flags_set_del( int sts, void *aux );
+static int flags_set_sync( int sts, void *aux );
+static void flags_set_sync_p2( sync_vars_t *svars, sync_rec_t *srec, int t );
+static int msgs_flags_set( sync_vars_t *svars, int t );
+static int msg_copied( int sts, int uid, copy_vars_t *vars );
+static void msg_copied_p2( sync_vars_t *svars, sync_rec_t *srec, int t, message_t *tmsg, int uid );
+static int msgs_copied( sync_vars_t *svars, int t );
+
+static int
+box_loaded( int sts, void *aux )
+{
+	SVARS(aux)
+	sync_rec_t *srec, *nsrec = 0;
+	message_t *tmsg;
+	copy_vars_t *cv;
+	flag_vars_t *fv;
+	const char *diag;
+	int uid, minwuid, *mexcs, nmexcs, rmexcs, no[2], del[2], todel, t1, t2;
+	int sflags, nflags, aflags, dflags, nex;
+	char fbuf[16]; /* enlarge when support for keywords is added */
+
+	if (check_ret( sts, svars ))
+		return -1;
+	svars->state[t] |= ST_LOADED;
+
+	if (svars->state[t] & S_FIND) {
+		svars->state[t] &= ~S_FIND;
+		debug( "matching previously copied messages on %s\n", str_ms[t] );
+		match_tuids( svars, t );
 	}
-	if (!(jfp = fopen( jname, "a" ))) {
-		fprintf( stderr, "Error: cannot write journal %s\n", jname );
-		fclose( nfp );
-		ret = SYNC_FAIL;
-		goto bail;
+	Fprintf( svars->jfp, "%c %d\n", "{}"[t], svars->ctx[t]->uidnext );
+
+	/*
+	 * Mapping tmsg -> srec (this variant) is dog slow for new messages.
+	 * Mapping srec -> tmsg is dog slow for deleted messages.
+	 * One solution would be using binary search on an index array.
+	 * msgs are already sorted by UID, srecs would have to be sorted by uid[t].
+	 */
+	debug( "matching messages on %s against sync records\n", str_ms[t] );
+	for (tmsg = svars->ctx[t]->msgs; tmsg; tmsg = tmsg->next) {
+		if (tmsg->srec) /* found by TUID */
+			continue;
+		uid = tmsg->uid;
+		if (DFlags & DEBUG) {
+			make_flags( tmsg->flags, fbuf );
+			printf( svars->ctx[t]->opts & OPEN_SIZE ? "  message %5d, %-4s, %6d: " : "  message %5d, %-4s: ", uid, fbuf, tmsg->size );
+		}
+		for (srec = nsrec; srec; srec = srec->next) {
+			if (srec->status & S_DEAD)
+				continue;
+			if (srec->uid[t] == uid) {
+				diag = srec == nsrec ? "adjacently" : "after gap";
+				goto found;
+			}
+		}
+		for (srec = svars->srecs; srec != nsrec; srec = srec->next) {
+			if (srec->status & S_DEAD)
+				continue;
+			if (srec->uid[t] == uid) {
+				diag = "after reset";
+				goto found;
+			}
+		}
+		tmsg->srec = 0;
+		debug( "new\n" );
+		continue;
+	  found:
+		tmsg->srec = srec;
+		srec->msg[t] = tmsg;
+		nsrec = srec->next;
+		debug( "pairs %5d %s\n", srec->uid[1-t], diag );
 	}
-	setlinebuf( jfp );
 
-	mexcs = 0;
-	nmexcs = rmexcs = 0;
-	minwuid = INT_MAX;
-	if (smaxxuid) {
-		debug( "preparing master selection - max expired slave uid is %d\n", smaxxuid );
-		for (srec = recs; srec; srec = srec->next) {
+	if ((t == S) && svars->smaxxuid) {
+		debug( "preparing master selection - max expired slave uid is %d\n", svars->smaxxuid );
+		mexcs = 0;
+		nmexcs = rmexcs = 0;
+		minwuid = INT_MAX;
+		for (srec = svars->srecs; srec; srec = srec->next) {
 			if (srec->status & S_DEAD)
 				continue;
 			if (srec->status & S_EXPIRED) {
-				if (!srec->suid || ((sctx->opts & OPEN_OLD) && !findmsg( sctx, srec->suid, &nsmsg, "slave" )))
-					srec->status |= S_EXP_SLAVE;
-				else if (minwuid > srec->muid)
-					minwuid = srec->muid;
-			} else if (smaxxuid < srec->suid && minwuid > srec->muid)
-				minwuid = srec->muid;
+				if (!srec->uid[S] || ((svars->ctx[S]->opts & OPEN_OLD) && !srec->msg[S])) {
+					srec->status |= S_EXP_S;
+					continue;
+				}
+			} else {
+				if (svars->smaxxuid >= srec->uid[S])
+					continue;
+			}
+			if (minwuid > srec->uid[M])
+				minwuid = srec->uid[M];
 		}
 		debug( "  min non-orphaned master uid is %d\n", minwuid );
-		Fprintf( jfp, "^\n" ); /* if any S_EXP_SLAVE */
-		for (srec = recs; srec; srec = srec->next) {
+		for (srec = svars->srecs; srec; srec = srec->next) {
 			if (srec->status & S_DEAD)
 				continue;
-			if (srec->status & S_EXP_SLAVE) {
-				if (minwuid > srec->muid && mmaxuid >= srec->muid) {
-					debug( "  -> killing (%d,%d)\n", srec->muid, srec->suid );
+			if (srec->status & S_EXP_S) {
+				if (minwuid > srec->uid[M] && svars->maxuid[M] >= srec->uid[M]) {
+					debug( "  -> killing (%d,%d)\n", srec->uid[M], srec->uid[S] );
 					srec->status = S_DEAD;
-					Fprintf( jfp, "- %d %d\n", srec->muid, srec->suid );
-				} else if (srec->suid) {
-					debug( "  -> orphaning (%d,[%d])\n", srec->muid, srec->suid );
-					Fprintf( jfp, "> %d %d 0\n", srec->muid, srec->suid );
-					srec->suid = 0;
+					Fprintf( svars->jfp, "- %d %d\n", srec->uid[M], srec->uid[S] );
+				} else if (srec->uid[S]) {
+					debug( "  -> orphaning (%d,[%d])\n", srec->uid[M], srec->uid[S] );
+					Fprintf( svars->jfp, "> %d %d 0\n", srec->uid[M], srec->uid[S] );
+					srec->uid[S] = 0;
 				}
-			} else if (minwuid > srec->muid) {
-				if (srec->suid < 0) {
-					if (mmaxuid >= srec->muid) {
-						debug( "  -> killing (%d,%d)\n", srec->muid, srec->suid );
+			} else if (minwuid > srec->uid[M]) {
+				if (srec->uid[S] < 0) {
+					if (svars->maxuid[M] >= srec->uid[M]) {
+						debug( "  -> killing (%d,%d)\n", srec->uid[M], srec->uid[S] );
 						srec->status = S_DEAD;
-						Fprintf( jfp, "- %d %d\n", srec->muid, srec->suid );
+						Fprintf( svars->jfp, "- %d %d\n", srec->uid[M], srec->uid[S] );
 					}
-				} else if (srec->muid > 0 && srec->suid && (mctx->opts & OPEN_OLD) &&
-				           (!(mctx->opts & OPEN_NEW) || mmaxuid >= srec->muid)) {
+				} else if (srec->uid[M] > 0 && srec->uid[S] && (svars->ctx[M]->opts & OPEN_OLD) &&
+				           (!(svars->ctx[M]->opts & OPEN_NEW) || svars->maxuid[M] >= srec->uid[M])) {
 					if (nmexcs == rmexcs) {
 						rmexcs = rmexcs * 2 + 100;
 						mexcs = nfrealloc( mexcs, rmexcs * sizeof(int) );
 					}
-					mexcs[nmexcs++] = srec->muid;
+					mexcs[nmexcs++] = srec->uid[M];
 				}
 			}
 		}
-		debug( "  exception list is:" );
-		for (i = 0; i < nmexcs; i++)
-			debug( " %d", mexcs[i] );
+		debugn( "  exception list is:" );
+		for (t = 0; t < nmexcs; t++)
+			debugn( " %d", mexcs[t] );
 		debug( "\n" );
-	} else if (mctx->opts & OPEN_OLD)
-		minwuid = 1;
-	if (mctx->opts & OPEN_NEW) {
-		if (minwuid > mmaxuid + 1)
-			minwuid = mmaxuid + 1;
-		maxwuid = INT_MAX;
-	} else if (mctx->opts & OPEN_OLD) {
-		maxwuid = 0;
-		for (srec = recs; srec; srec = srec->next)
-			if (!(srec->status & S_DEAD) && srec->muid > maxwuid)
-				maxwuid = srec->muid;
-	} else
-		maxwuid = 0;
-	info( "Selecting master %s... ", mname );
-	debug( maxwuid == INT_MAX ? "selecting master [%d,inf]\n" : "selecting master [%d,%d]\n", minwuid, maxwuid );
-	switch (mdriver->select( mctx, minwuid, maxwuid, mexcs, nmexcs )) {
-	case DRV_STORE_BAD: ret = SYNC_MASTER_BAD; goto finish;
-	case DRV_BOX_BAD: ret = SYNC_FAIL; goto finish;
+		return load_box( svars, M, minwuid, mexcs, nmexcs );
 	}
-	info( "%d messages, %d recent\n", mctx->count, mctx->recent );
-	dump_box( mctx );
 
-	if (muidval >= 0 && muidval != mctx->uidvalidity) {
-		fprintf( stderr, "Error: UIDVALIDITY of master changed\n" );
-		ret = SYNC_FAIL;
-		goto finish;
+	if (!(svars->state[1-t] & ST_LOADED))
+		return 0;
+
+	if (svars->uidval[M] < 0 || svars->uidval[S] < 0) {
+		svars->uidval[M] = svars->ctx[M]->uidvalidity;
+		svars->uidval[S] = svars->ctx[S]->uidvalidity;
+		Fprintf( svars->jfp, "| %d %d\n", svars->uidval[M], svars->uidval[S] );
 	}
 
-	if (muidval < 0 || suidval < 0) {
-		muidval = mctx->uidvalidity;
-		suidval = sctx->uidvalidity;
-		Fprintf( jfp, "| %d %d\n", muidval, suidval );
+	info( "Synchronizing...\n" );
+
+	debug( "synchronizing new entries\n" );
+	svars->osrecadd = svars->srecadd;
+	for (t = 0; t < 2; t++) {
+		for (tmsg = svars->ctx[1-t]->msgs; tmsg; tmsg = tmsg->next)
+			if (tmsg->srec ? tmsg->srec->uid[t] < 0 && (tmsg->srec->uid[t] == -1 ? (svars->chan->ops[t] & OP_RENEW) : (svars->chan->ops[t] & OP_NEW)) : (svars->chan->ops[t] & OP_NEW)) {
+				debug( "new message %d on %s\n", tmsg->uid, str_ms[1-t] );
+				if ((svars->chan->ops[t] & OP_EXPUNGE) && (tmsg->flags & F_DELETED))
+					debug( "  -> not %sing - would be expunged anyway\n", str_hl[t] );
+				else {
+					if (tmsg->srec) {
+						srec = tmsg->srec;
+						srec->status |= S_DONE;
+						debug( "  -> pair(%d,%d) exists\n", srec->uid[M], srec->uid[S] );
+					} else {
+						srec = nfmalloc( sizeof(*srec) );
+						srec->next = 0;
+						*svars->srecadd = srec;
+						svars->srecadd = &srec->next;
+						srec->status = S_DONE;
+						srec->flags = 0;
+						srec->tuid[0] = 0;
+						srec->uid[1-t] = tmsg->uid;
+						srec->uid[t] = -2;
+						Fprintf( svars->jfp, "+ %d %d\n", srec->uid[M], srec->uid[S] );
+						debug( "  -> pair(%d,%d) created\n", srec->uid[M], srec->uid[S] );
+					}
+					if ((tmsg->flags & F_FLAGGED) || !svars->chan->stores[t]->max_size || tmsg->size <= svars->chan->stores[t]->max_size) {
+						if (tmsg->flags) {
+							srec->flags = tmsg->flags;
+							Fprintf( svars->jfp, "* %d %d %u\n", srec->uid[M], srec->uid[S], srec->flags );
+							debug( "  -> updated flags to %u\n", tmsg->flags );
+						}
+						for (t1 = 0; t1 < TUIDL; t1++) {
+							t2 = arc4_getbyte() & 0x3f;
+							srec->tuid[t1] = t2 < 26 ? t2 + 'A' : t2 < 52 ? t2 + 'a' - 26 : t2 < 62 ? t2 + '0' - 52 : t2 == 62 ? '+' : '/';
+						}
+						svars->new_total[t]++;
+						stats( svars );
+						cv = nfmalloc( sizeof(*cv) );
+						cv->cb = msg_copied;
+						cv->aux = AUX;
+						cv->srec = srec;
+						cv->msg = tmsg;
+						Fprintf( svars->jfp, "# %d %d %." stringify(TUIDL) "s\n", srec->uid[M], srec->uid[S], srec->tuid );
+						debug( "  -> %sing message, TUID %." stringify(TUIDL) "s\n", str_hl[t], srec->tuid );
+						if (copy_msg( cv ))
+							return -1;
+					} else {
+						if (tmsg->srec) {
+							debug( "  -> not %sing - still too big\n", str_hl[t] );
+							continue;
+						}
+						debug( "  -> not %sing - too big\n", str_hl[t] );
+						msg_copied_p2( svars, srec, t, tmsg, -1 );
+					}
+				}
+			}
+		svars->state[t] |= ST_SENT_NEW;
+		if (msgs_copied( svars, t ))
+			return -1;
 	}
 
-	info( "Synchronizing\n" );
 	debug( "synchronizing old entries\n" );
-	Fprintf( jfp, "^\n" );
-	for (srec = recs; srec; srec = srec->next) {
-		if (srec->status & S_DEAD)
+	for (srec = svars->srecs; srec != *svars->osrecadd; srec = srec->next) {
+		if (srec->status & (S_DEAD|S_DONE))
 			continue;
-		debug( "pair (%d,%d)\n", srec->muid, srec->suid );
-		mmsg = findmsg( mctx, srec->muid, &nmmsg, "master" );
-		smsg = (srec->status & S_EXP_SLAVE) ? 0 : findmsg( sctx, srec->suid, &nsmsg, "slave" );
-		nom = !mmsg && (mctx->opts & OPEN_OLD);
-		nos = !smsg && (sctx->opts & OPEN_OLD);
-		if (nom && nos) {
+		debug( "pair (%d,%d)\n", srec->uid[M], srec->uid[S] );
+		no[M] = !srec->msg[M] && (svars->ctx[M]->opts & OPEN_OLD);
+		no[S] = !srec->msg[S] && (svars->ctx[S]->opts & OPEN_OLD);
+		if (no[M] && no[S]) {
 			debug( "  vanished\n" );
 			/* d.1) d.5) d.6) d.10) d.11) */
 			srec->status = S_DEAD;
-			Fprintf( jfp, "- %d %d\n", srec->muid, srec->suid );
+			Fprintf( svars->jfp, "- %d %d\n", srec->uid[M], srec->uid[S] );
 		} else {
-			delm = nom && (srec->muid > 0);
-			dels = nos && (srec->suid > 0);
-			nflags = srec->flags;
-
-			if ((ret = sync_old( chan->mops, sctx, mctx, chan->master, jfp, 0, &nflags, srec, smsg, mmsg, dels, delm )) != SYNC_OK ||
-			    (ret = sync_old( chan->sops, mctx, sctx, chan->slave, jfp, 1, &nflags, srec, mmsg, smsg, delm, dels )) != SYNC_OK)
-				goto finish;
-
-			if (srec->flags != nflags) {
-				debug( "  updating flags (%u -> %u)\n", srec->flags, nflags );
-				srec->flags = nflags;
-				Fprintf( jfp, "* %d %d %u\n", srec->muid, srec->suid, nflags );
+			del[M] = no[M] && (srec->uid[M] > 0);
+			del[S] = no[S] && (srec->uid[S] > 0);
+
+			for (t = 0; t < 2; t++) {
+				srec->aflags[t] = srec->dflags[t] = 0;
+				if (srec->msg[t] && (srec->msg[t]->flags & F_DELETED))
+					srec->status |= S_DEL(t);
+				/* excludes (push) c.3) d.2) d.3) d.4) / (pull) b.3) d.7) d.8) d.9) */
+				if (!srec->uid[t]) {
+					/* b.1) / c.1) */
+					debug( "  no more %s\n", str_ms[t] );
+				} else if (del[1-t]) {
+					/* c.4) d.9) / b.4) d.4) */
+					if (srec->msg[t] && (srec->msg[t]->status & M_FLAGS) && srec->msg[t]->flags != srec->flags)
+						info( "Info: conflicting changes in (%d,%d)\n", srec->uid[M], srec->uid[S] );
+					if (svars->chan->ops[t] & OP_DELETE) {
+						debug( "  %sing delete\n", str_hl[t] );
+						svars->flags_total[t]++;
+						stats( svars );
+						fv = nfmalloc( sizeof(*fv) );
+						fv->aux = AUX;
+						fv->srec = srec;
+						if (svars->drv[t]->set_flags( svars->ctx[t], srec->msg[t], srec->uid[t], F_DELETED, 0, flags_set_del, fv ))
+							return -1;
+					} else
+						debug( "  not %sing delete\n", str_hl[t] );
+				} else if (!srec->msg[1-t])
+					/* c.1) c.2) d.7) d.8) / b.1) b.2) d.2) d.3) */
+					;
+				else if (srec->uid[t] < 0)
+					/* b.2) / c.2) */
+					; /* handled as new messages (sort of) */
+				else if (!del[t]) {
+					/* a) & b.3) / c.3) */
+					if (svars->chan->ops[t] & OP_FLAGS) {
+						sflags = srec->msg[1-t]->flags;
+						if ((srec->status & (S_EXPIRE|S_EXPIRED)) && !t)
+							sflags &= ~F_DELETED;
+						srec->aflags[t] = sflags & ~srec->flags;
+						srec->dflags[t] = ~sflags & srec->flags;
+						if (DFlags & DEBUG) {
+							char afbuf[16], dfbuf[16]; /* enlarge when support for keywords is added */
+							make_flags( srec->aflags[t], afbuf );
+							make_flags( srec->dflags[t], dfbuf );
+							debug( "  %sing flags: +%s -%s\n", str_hl[t], afbuf, dfbuf );
+						}
+					} else
+						debug( "  not %sing flags\n", str_hl[t] );
+				} /* else b.4) / c.4) */
 			}
-			if (mmsg && (mmsg->flags & F_DELETED))
-				srec->status |= S_DEL_MASTER;
-			if (smsg && (smsg->flags & F_DELETED))
-				srec->status |= S_DEL_SLAVE;
 		}
 	}
 
-	debug( "synchronizing new entries\n" );
-	if ((ret = sync_new( chan->mops, sctx, mctx, chan->master, jfp, &srecadd, 0, &smaxuid )) != SYNC_OK ||
-	    (ret = sync_new( chan->sops, mctx, sctx, chan->slave, jfp, &srecadd, 1, &mmaxuid )) != SYNC_OK)
-		goto finish;
-
-	if ((chan->sops & (OP_NEW|OP_RENEW)) && chan->max_messages) {
-		debug( "expiring excessive entries\n" );
-		todel = sctx->count - chan->max_messages;
-		for (smsg = sctx->msgs; smsg && todel > 0; smsg = smsg->next)
-			if (!(smsg->status & M_DEAD) && (smsg->flags & F_DELETED))
+	if ((svars->chan->ops[S] & (OP_NEW|OP_RENEW|OP_FLAGS)) && svars->chan->max_messages) {
+		/* Flagged and not yet synced messages older than the first not
+		 * expired message are not counted. */
+		todel = svars->ctx[S]->count + svars->new_total[S] - svars->chan->max_messages;
+		debug( "scheduling %d excess messages for expiration\n", todel );
+		for (tmsg = svars->ctx[S]->msgs; tmsg && todel > 0; tmsg = tmsg->next)
+			if (!(tmsg->status & M_DEAD) && (srec = tmsg->srec) &&
+			    ((tmsg->flags | srec->aflags[S]) & ~srec->dflags[S] & F_DELETED) &&
+			    !(srec->status & (S_EXPIRE|S_EXPIRED)))
 				todel--;
-		delt = 0;
-		for (smsg = sctx->msgs; smsg && todel > 0; smsg = smsg->next) {
-			if ((smsg->status & M_DEAD) || (smsg->flags & F_DELETED))
+		debug( "%d non-deleted excess messages\n", todel );
+		for (tmsg = svars->ctx[S]->msgs; tmsg; tmsg = tmsg->next) {
+			if (tmsg->status & M_DEAD)
 				continue;
-			if ((smsg->flags & F_FLAGGED) || (smsg->status & M_NOT_SYNCED)) /* add M_DESYNCED? */
-				todel--;
-			else if (!(smsg->status & M_RECENT)) {
-				smsg->status |= M_EXPIRED;
-				delt++;
+			if (!(srec = tmsg->srec) || srec->uid[M] <= 0)
 				todel--;
-			}
-		}
-		if (delt) {
-			Fprintf( jfp, "^\n" );
-			for (srec = recs; srec; srec = srec->next) {
-				if (srec->status & (S_DEAD|S_EXPIRED))
-					continue;
-				smsg = findmsg( sctx, srec->suid, &nsmsg, "slave" );
-				if (smsg && (smsg->status & M_EXPIRED)) {
-					debug( "  expiring pair(%d,%d)\n", srec->muid, srec->suid );
-					/* log first, so deletion can't be misinterpreted! */
-					Fprintf( jfp, "~ %d %d 1\n", srec->muid, srec->suid );
-					if (smaxxuid < srec->suid)
-						smaxxuid = srec->suid;
-					srec->status |= S_EXPIRED;
-					switch (sdriver->set_flags( sctx, smsg, 0, F_DELETED, 0 )) {
-					case DRV_STORE_BAD: ret = SYNC_SLAVE_BAD; goto finish;
-					case DRV_BOX_BAD: ret = SYNC_FAIL; goto finish;
-					default: /* ok */ break;
-					case DRV_OK: srec->status |= S_DEL_SLAVE;
+			else {
+				nflags = (tmsg->flags | srec->aflags[S]) & ~srec->dflags[S];
+				if (!(nflags & F_DELETED) || (srec->status & (S_EXPIRE|S_EXPIRED))) {
+					if (nflags & F_FLAGGED)
+						todel--;
+					else if ((!(tmsg->status & M_RECENT) || (tmsg->flags & F_SEEN)) &&
+					         (todel > 0 ||
+					          ((srec->status & (S_EXPIRE|S_EXPIRED)) == (S_EXPIRE|S_EXPIRED)) ||
+					          ((srec->status & (S_EXPIRE|S_EXPIRED)) && (tmsg->flags & F_DELETED)))) {
+						srec->status |= S_NEXPIRE;
+						debug( "  pair(%d,%d)\n", srec->uid[M], srec->uid[S] );
+						todel--;
 					}
 				}
 			}
 		}
+		debug( "%d excess messages remain\n", todel );
+		for (srec = svars->srecs; srec; srec = srec->next) {
+			if ((srec->status & (S_DEAD|S_DONE)) || !srec->msg[S])
+				continue;
+			nex = (srec->status / S_NEXPIRE) & 1;
+			if (nex != ((srec->status / S_EXPIRED) & 1)) {
+				if (nex != ((srec->status / S_EXPIRE) & 1)) {
+					Fprintf( svars->jfp, "~ %d %d %d\n", srec->uid[M], srec->uid[S], nex );
+					debug( "  pair(%d,%d): %d (pre)\n", srec->uid[M], srec->uid[S], nex );
+					srec->status = (srec->status & ~S_EXPIRE) | (nex * S_EXPIRE);
+				} else
+					debug( "  pair(%d,%d): %d (pending)\n", srec->uid[M], srec->uid[S], nex );
+			}
+		}
+	}
+
+	debug( "synchronizing flags\n" );
+	for (srec = svars->srecs; srec != *svars->osrecadd; srec = srec->next) {
+		if (srec->status & (S_DEAD|S_DONE))
+			continue;
+		for (t = 0; t < 2; t++) {
+			aflags = srec->aflags[t];
+			dflags = srec->dflags[t];
+			if ((t == S) && ((mvBit(srec->status, S_EXPIRE, S_EXPIRED) ^ srec->status) & S_EXPIRED)) {
+				if (srec->status & S_NEXPIRE)
+					aflags |= F_DELETED;
+				else
+					dflags |= F_DELETED;
+			}
+			if ((svars->chan->ops[t] & OP_EXPUNGE) && (((srec->msg[t] ? srec->msg[t]->flags : 0) | aflags) & ~dflags & F_DELETED) &&
+			    (!svars->ctx[t]->conf->trash || svars->ctx[t]->conf->trash_only_new))
+			{
+				srec->aflags[t] &= F_DELETED;
+				aflags &= F_DELETED;
+				srec->dflags[t] = dflags = 0;
+			}
+			if (srec->msg[t] && (srec->msg[t]->status & M_FLAGS)) {
+				aflags &= ~srec->msg[t]->flags;
+				dflags &= srec->msg[t]->flags;
+			}
+			if (aflags | dflags) {
+				svars->flags_total[t]++;
+				stats( svars );
+				fv = nfmalloc( sizeof(*fv) );
+				fv->aux = AUX;
+				fv->srec = srec;
+				fv->aflags = aflags;
+				fv->dflags = dflags;
+				if (svars->drv[t]->set_flags( svars->ctx[t], srec->msg[t], srec->uid[t], aflags, dflags, flags_set_sync, fv ))
+					return -1;
+			} else
+				flags_set_sync_p2( svars, srec, t );
+		}
+	}
+	for (t = 0; t < 2; t++) {
+		svars->drv[t]->commit( svars->ctx[t] );
+		svars->state[t] |= ST_SENT_FLAGS;
+		if (msgs_flags_set( svars, t ))
+			return -1;
+	}
+	return 0;
+}
+
+static int
+msg_copied( int sts, int uid, copy_vars_t *vars )
+{
+	SVARS(vars->aux)
+
+	switch (sts) {
+	case SYNC_OK:
+		if (uid < 0)
+			svars->state[t] |= S_FIND;
+		msg_copied_p2( svars, vars->srec, t, vars->msg, uid );
+		break;
+	case SYNC_NOGOOD:
+		debug( "  -> killing (%d,%d)\n", vars->srec->uid[M], vars->srec->uid[S] );
+		vars->srec->status = S_DEAD;
+		Fprintf( svars->jfp, "- %d %d\n", vars->srec->uid[M], vars->srec->uid[S] );
+		break;
+	default:
+		cancel_sync( svars );
+		/* fallthrough */
+	case SYNC_CANCELED:
+		free( vars );
+		return -1;
 	}
+	free( vars );
+	svars->new_done[t]++;
+	stats( svars );
+	return msgs_copied( svars, t );
+}
 
-	/* Doing CLOSE here instead of EXPUNGE above saves network traffic.
-	   But it costs more server power for single-file formats. And it
-	   makes disk-full/quota-exceeded more probable. */
-	mex = sex = 0;
-	if (chan->mops & OP_EXPUNGE) {
-		info( "Expunging master\n" );
-		debug( "expunging master\n" );
-		switch (expunge( mctx, sctx )) {
-		case EX_STORE_BAD: ret = SYNC_MASTER_BAD; goto finish;
-		case EX_RSTORE_BAD: ret = SYNC_SLAVE_BAD; goto finish;
-		default: ret = SYNC_FAIL; break;
-		case EX_OK: mex = 1;
+static void
+msg_copied_p2( sync_vars_t *svars, sync_rec_t *srec, int t, message_t *tmsg, int uid )
+{
+	if (srec->uid[t] != uid) {
+		debug( "  -> new UID %d\n", uid );
+		Fprintf( svars->jfp, "%c %d %d %d\n", "<>"[t], srec->uid[M], srec->uid[S], uid );
+		srec->uid[t] = uid;
+		srec->tuid[0] = 0;
+	}
+	if (!tmsg->srec) {
+		tmsg->srec = srec;
+		if (svars->maxuid[1-t] < tmsg->uid) {
+			svars->maxuid[1-t] = tmsg->uid;
+			Fprintf( svars->jfp, "%c %d\n", ")("[t], tmsg->uid );
 		}
 	}
-	if (chan->sops & OP_EXPUNGE) {
-		info( "Expunging slave\n" );
-		debug( "expunging slave\n" );
-		switch (expunge( sctx, mctx )) {
-		case EX_STORE_BAD: ret = SYNC_SLAVE_BAD; goto finish;
-		case EX_RSTORE_BAD: ret = SYNC_MASTER_BAD; goto finish;
-		default: ret = SYNC_FAIL; break;
-		case EX_OK: sex = 1;
+}
+
+static int msgs_found_new( int sts, void *aux );
+static int msgs_new_done( sync_vars_t *svars, int t );
+static int sync_close( sync_vars_t *svars, int t );
+
+static int
+msgs_copied( sync_vars_t *svars, int t )
+{
+	if (!(svars->state[t] & ST_SENT_NEW) || svars->new_done[t] < svars->new_total[t])
+		return 0;
+
+	if (svars->state[t] & S_FIND) {
+		debug( "finding just copied messages on %s\n", str_ms[t] );
+		return svars->drv[t]->find_new_msgs( svars->ctx[t], msgs_found_new, AUX );
+	} else {
+		return msgs_new_done( svars, t );
+	}
+}
+
+static int
+msgs_found_new( int sts, void *aux )
+{
+	SVARS(aux)
+
+	if (check_ret( sts, svars ))
+		return -1;
+	switch (sts) {
+	case DRV_OK:
+		debug( "matching just copied messages on %s\n", str_ms[t] );
+		break;
+	default:
+		warn( "Warning: cannot find newly stored messages on %s.\n", str_ms[t] );
+		break;
+	}
+	match_tuids( svars, t );
+	return msgs_new_done( svars, t );
+}
+
+static int
+msgs_new_done( sync_vars_t *svars, int t )
+{
+	Fprintf( svars->jfp, "%c %d\n", "{}"[t], svars->ctx[t]->uidnext );
+	svars->state[t] |= ST_FOUND_NEW;
+	return sync_close( svars, t );
+}
+
+static int
+flags_set_del( int sts, void *aux )
+{
+	flag_vars_t *vars = (flag_vars_t *)aux;
+	SVARS(vars->aux)
+
+	if (check_ret_aux( sts, svars, vars ))
+		return -1;
+	switch (sts) {
+	case DRV_OK:
+		vars->srec->status |= S_DEL(t);
+		Fprintf( svars->jfp, "%c %d %d 0\n", "><"[t], vars->srec->uid[M], vars->srec->uid[S] );
+		vars->srec->uid[1-t] = 0;
+		break;
+	}
+	free( vars );
+	svars->flags_done[t]++;
+	stats( svars );
+	return msgs_flags_set( svars, t );
+}
+
+static int
+flags_set_sync( int sts, void *aux )
+{
+	flag_vars_t *vars = (flag_vars_t *)aux;
+	SVARS(vars->aux)
+
+	if (check_ret_aux( sts, svars, vars ))
+		return -1;
+	switch (sts) {
+	case DRV_OK:
+		if (vars->aflags & F_DELETED)
+			vars->srec->status |= S_DEL(t);
+		else if (vars->dflags & F_DELETED)
+			vars->srec->status &= ~S_DEL(t);
+		flags_set_sync_p2( svars, vars->srec, t );
+		break;
+	}
+	free( vars );
+	svars->flags_done[t]++;
+	stats( svars );
+	return msgs_flags_set( svars, t );
+}
+
+static void
+flags_set_sync_p2( sync_vars_t *svars, sync_rec_t *srec, int t )
+{
+	int nflags, nex;
+
+	nflags = (srec->flags | srec->aflags[t]) & ~srec->dflags[t];
+	if (srec->flags != nflags) {
+		debug( "  pair(%d,%d): updating flags (%u -> %u)\n", srec->uid[M], srec->uid[S], srec->flags, nflags );
+		srec->flags = nflags;
+		Fprintf( svars->jfp, "* %d %d %u\n", srec->uid[M], srec->uid[S], nflags );
+	}
+	if (t == S) {
+		nex = (srec->status / S_NEXPIRE) & 1;
+		if (nex != ((srec->status / S_EXPIRED) & 1)) {
+			if (nex && (svars->smaxxuid < srec->uid[S]))
+				svars->smaxxuid = srec->uid[S];
+			Fprintf( svars->jfp, "/ %d %d\n", srec->uid[M], srec->uid[S] );
+			debug( "  pair(%d,%d): expired %d (commit)\n", srec->uid[M], srec->uid[S], nex );
+			srec->status = (srec->status & ~S_EXPIRED) | (nex * S_EXPIRED);
+		} else if (nex != ((srec->status / S_EXPIRE) & 1)) {
+			Fprintf( svars->jfp, "\\ %d %d\n", srec->uid[M], srec->uid[S] );
+			debug( "  pair(%d,%d): expire %d (cancel)\n", srec->uid[M], srec->uid[S], nex );
+			srec->status = (srec->status & ~S_EXPIRE) | (nex * S_EXPIRE);
 		}
 	}
-	if (mex || sex) {
+}
+
+static int msg_trashed( int sts, void *aux );
+static int msg_rtrashed( int sts, int uid, copy_vars_t *vars );
+
+static int
+msgs_flags_set( sync_vars_t *svars, int t )
+{
+	message_t *tmsg;
+	copy_vars_t *cv;
+
+	if (!(svars->state[t] & ST_SENT_FLAGS) || svars->flags_done[t] < svars->flags_total[t])
+		return 0;
+
+	if ((svars->chan->ops[t] & OP_EXPUNGE) &&
+	    (svars->ctx[t]->conf->trash || (svars->ctx[1-t]->conf->trash && svars->ctx[1-t]->conf->trash_remote_new))) {
+		debug( "trashing in %s\n", str_ms[t] );
+		for (tmsg = svars->ctx[t]->msgs; tmsg; tmsg = tmsg->next)
+			if (tmsg->flags & F_DELETED) {
+				if (svars->ctx[t]->conf->trash) {
+					if (!svars->ctx[t]->conf->trash_only_new || !tmsg->srec || tmsg->srec->uid[1-t] < 0) {
+						debug( "%s: trashing message %d\n", str_ms[t], tmsg->uid );
+						svars->trash_total[t]++;
+						stats( svars );
+						if (svars->drv[t]->trash_msg( svars->ctx[t], tmsg, msg_trashed, AUX ))
+							return -1;
+					} else
+						debug( "%s: not trashing message %d - not new\n", str_ms[t], tmsg->uid );
+				} else {
+					if (!tmsg->srec || tmsg->srec->uid[1-t] < 0) {
+						if (!svars->ctx[1-t]->conf->max_size || tmsg->size <= svars->ctx[1-t]->conf->max_size) {
+							debug( "%s: remote trashing message %d\n", str_ms[t], tmsg->uid );
+							svars->trash_total[t]++;
+							stats( svars );
+							cv = nfmalloc( sizeof(*cv) );
+							cv->cb = msg_rtrashed;
+							cv->aux = AUX;
+							cv->srec = 0;
+							cv->msg = tmsg;
+							if (copy_msg( cv ))
+								return -1;
+						} else
+							debug( "%s: not remote trashing message %d - too big\n", str_ms[t], tmsg->uid );
+					} else
+						debug( "%s: not remote trashing message %d - not new\n", str_ms[t], tmsg->uid );
+				}
+			}
+	}
+	svars->state[t] |= ST_SENT_TRASH;
+	return sync_close( svars, t );
+}
+
+static int
+msg_trashed( int sts, void *aux )
+{
+	SVARS(aux)
+
+	if (sts == DRV_MSG_BAD)
+		sts = DRV_BOX_BAD;
+	if (check_ret( sts, svars ))
+		return -1;
+	svars->trash_done[t]++;
+	stats( svars );
+	return sync_close( svars, t );
+}
+
+static int
+msg_rtrashed( int sts, int uid, copy_vars_t *vars )
+{
+	SVARS(vars->aux)
+
+	(void)uid;
+	switch (sts) {
+	case SYNC_OK:
+	case SYNC_NOGOOD: /* the message is gone or heavily busted */
+		break;
+	default:
+		cancel_sync( svars );
+		/* fallthrough */
+	case SYNC_CANCELED:
+		free( vars );
+		return -1;
+	}
+	free( vars );
+	svars->trash_done[t]++;
+	stats( svars );
+	return sync_close( svars, t );
+}
+
+static int box_closed( int sts, void *aux );
+static int box_closed_p2( sync_vars_t *svars, int t );
+
+static int
+sync_close( sync_vars_t *svars, int t )
+{
+	if ((~svars->state[t] & (ST_FOUND_NEW|ST_SENT_TRASH)) ||
+	    svars->trash_done[t] < svars->trash_total[t])
+		return 0;
+
+	if ((svars->chan->ops[t] & OP_EXPUNGE) /*&& !(svars->state[t] & ST_TRASH_BAD)*/) {
+		debug( "expunging %s\n", str_ms[t] );
+		return svars->drv[t]->close( svars->ctx[t], box_closed, AUX );
+	}
+	return box_closed_p2( svars, t );
+}
+
+static int
+box_closed( int sts, void *aux )
+{
+	SVARS(aux)
+
+	if (check_ret( sts, svars ))
+		return -1;
+	svars->state[t] |= ST_DID_EXPUNGE;
+	return box_closed_p2( svars, t );
+}
+
+static int
+box_closed_p2( sync_vars_t *svars, int t )
+{
+	sync_rec_t *srec;
+	int minwuid;
+	char fbuf[16]; /* enlarge when support for keywords is added */
+
+	svars->state[t] |= ST_CLOSED;
+	if (!(svars->state[1-t] & ST_CLOSED))
+		return 0;
+
+	if ((svars->state[M] | svars->state[S]) & ST_DID_EXPUNGE) {
 		/* This cleanup is not strictly necessary, as the next full sync
 		   would throw out the dead entries anyway. But ... */
 
 		minwuid = INT_MAX;
-		if (smaxxuid) {
-			debug( "preparing entry purge - max expired slave uid is %d\n", smaxxuid );
-			for (srec = recs; srec; srec = srec->next) {
+		if (svars->smaxxuid) {
+			debug( "preparing entry purge - max expired slave uid is %d\n", svars->smaxxuid );
+			for (srec = svars->srecs; srec; srec = srec->next) {
 				if (srec->status & S_DEAD)
 					continue;
-				if (!((srec->suid <= 0 || ((srec->status & S_DEL_SLAVE) && sex)) &&
-				      (srec->muid <= 0 || ((srec->status & S_DEL_MASTER) && mex) || (srec->status & S_EXPIRED))) &&
-				    smaxxuid < srec->suid && minwuid > srec->muid)
-					minwuid = srec->muid;
+				if (!((srec->uid[S] <= 0 || ((srec->status & S_DEL(S)) && (svars->state[S] & ST_DID_EXPUNGE))) &&
+				      (srec->uid[M] <= 0 || ((srec->status & S_DEL(M)) && (svars->state[M] & ST_DID_EXPUNGE)) || (srec->status & S_EXPIRED))) &&
+				    svars->smaxxuid < srec->uid[S] && minwuid > srec->uid[M])
+					minwuid = srec->uid[M];
 			}
 			debug( "  min non-orphaned master uid is %d\n", minwuid );
 		}
 
-		Fprintf( jfp, "^\n" );
-		for (srec = recs; srec; srec = srec->next) {
+		for (srec = svars->srecs; srec; srec = srec->next) {
 			if (srec->status & S_DEAD)
 				continue;
-			if (srec->suid <= 0 || ((srec->status & S_DEL_SLAVE) && sex)) {
-				if (srec->muid <= 0 || ((srec->status & S_DEL_MASTER) && mex)) {
-					debug( "  -> killing (%d,%d)\n", srec->muid, srec->suid );
+			if (srec->uid[S] <= 0 || ((srec->status & S_DEL(S)) && (svars->state[S] & ST_DID_EXPUNGE))) {
+				if (srec->uid[M] <= 0 || ((srec->status & S_DEL(M)) && (svars->state[M] & ST_DID_EXPUNGE)) ||
+				    ((srec->status & S_EXPIRED) && svars->maxuid[M] >= srec->uid[M] && minwuid > srec->uid[M])) {
+					debug( "  -> killing (%d,%d)\n", srec->uid[M], srec->uid[S] );
 					srec->status = S_DEAD;
-					Fprintf( jfp, "- %d %d\n", srec->muid, srec->suid );
-				} else if (srec->status & S_EXPIRED) {
-					if (mmaxuid >= srec->muid && minwuid > srec->muid) {
-						debug( "  -> killing (%d,%d)\n", srec->muid, srec->suid );
-						srec->status = S_DEAD;
-						Fprintf( jfp, "- %d %d\n", srec->muid, srec->suid );
-					} else if (srec->suid) {
-						debug( "  -> orphaning (%d,[%d])\n", srec->muid, srec->suid );
-						Fprintf( jfp, "> %d %d 0\n", srec->muid, srec->suid );
-						srec->suid = 0;
-					}
+					Fprintf( svars->jfp, "- %d %d\n", srec->uid[M], srec->uid[S] );
+				} else if (srec->uid[S] > 0) {
+					debug( "  -> orphaning (%d,[%d])\n", srec->uid[M], srec->uid[S] );
+					Fprintf( svars->jfp, "> %d %d 0\n", srec->uid[M], srec->uid[S] );
+					srec->uid[S] = 0;
 				}
+			} else if (srec->uid[M] > 0 && ((srec->status & S_DEL(M)) && (svars->state[M] & ST_DID_EXPUNGE))) {
+				debug( "  -> orphaning ([%d],%d)\n", srec->uid[M], srec->uid[S] );
+				Fprintf( svars->jfp, "< %d %d 0\n", srec->uid[M], srec->uid[S] );
+				srec->uid[M] = 0;
 			}
 		}
 	}
 
-  finish:
-	Fprintf( nfp, "%d:%d %d:%d:%d\n", muidval, mmaxuid, suidval, smaxxuid, smaxuid );
-	for (srec = recs; srec; srec = srec->next) {
+	Fprintf( svars->nfp, "%d:%d:%d %d:%d:%d:%d\n",
+	         svars->uidval[M], svars->maxuid[M], svars->ctx[M]->uidnext,
+	         svars->uidval[S], svars->smaxxuid, svars->maxuid[S], svars->ctx[S]->uidnext );
+	for (srec = svars->srecs; srec; srec = srec->next) {
 		if (srec->status & S_DEAD)
 			continue;
 		make_flags( srec->flags, fbuf );
-		Fprintf( nfp, "%d %d %s%s\n", srec->muid, srec->suid,
+		Fprintf( svars->nfp, "%d %d %s%s\n", srec->uid[M], srec->uid[S],
 		         srec->status & S_EXPIRED ? "X" : "", fbuf );
 	}
 
-	fclose( nfp );
-	fclose( jfp );
-	/* order is important! */
-	rename( nname, dname );
-	unlink( jname );
+	Fclose( svars->nfp );
+	Fclose( svars->jfp );
+	if (!(DFlags & KEEPJOURNAL)) {
+		/* order is important! */
+		rename( svars->nname, svars->dname );
+		unlink( svars->jname );
+	}
+
+	sync_bail( svars );
+	return -1;
+}
+
+static void
+sync_bail( sync_vars_t *svars )
+{
+	sync_rec_t *srec, *nsrec;
 
-  bail:
-	for (srec = recs; srec; srec = nsrec) {
+	for (srec = svars->srecs; srec; srec = nsrec) {
 		nsrec = srec->next;
 		free( srec );
 	}
-	unlink( lname );
-  bail1:
-	close( lfd );
-  bail2:
-	free( lname );
-	free( nname );
-	free( jname );
-	free( dname );
-	return ret;
+	unlink( svars->lname );
+	sync_bail1( svars );
+}
+
+static void
+sync_bail1( sync_vars_t *svars )
+{
+	close( svars->lfd );
+	sync_bail2( svars );
+}
+
+static void
+sync_bail2( sync_vars_t *svars )
+{
+	void (*cb)( int sts, void *aux ) = svars->cb;
+	void *aux = svars->aux;
+	int ret = svars->ret;
+
+	free( svars->lname );
+	free( svars->nname );
+	free( svars->jname );
+	free( svars->dname );
+	free( svars );
+	flushn();
+	cb( ret, aux );
 }
 
diff --git src/util.c src/util.c
index 6fb43c2..07e1e88 100644
--- src/util.c
+++ src/util.c
@@ -1,7 +1,7 @@
 /*
  * mbsync - mailbox synchronizer
  * Copyright (C) 2000-2002 Michael R. Elkins <me@mutt.org>
- * Copyright (C) 2002-2004 Oswald Buddenhagen <ossi@users.sf.net>
+ * Copyright (C) 2002-2006,2011 Oswald Buddenhagen <ossi@users.sf.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -14,8 +14,7 @@
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, mbsync may be linked with the OpenSSL library,
  * despite that library's more restrictive license.
@@ -23,6 +22,7 @@
 
 #include "isync.h"
 
+#include <assert.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
@@ -30,18 +30,43 @@
 #include <pwd.h>
 #include <ctype.h>
 
-int Verbose, Quiet, Debug;
+int DFlags;
+static int need_nl;
+
+void
+flushn( void )
+{
+	if (need_nl) {
+		putchar( '\n' );
+		need_nl = 0;
+	}
+}
 
 void
 debug( const char *msg, ... )
 {
 	va_list va;
 
-	if (Debug) {
+	if (DFlags & DEBUG) {
+		va_start( va, msg );
+		vprintf( msg, va );
+		va_end( va );
+		fflush( stdout );
+		need_nl = 0;
+	}
+}
+
+void
+debugn( const char *msg, ... )
+{
+	va_list va;
+
+	if (DFlags & DEBUG) {
 		va_start( va, msg );
 		vprintf( msg, va );
 		va_end( va );
 		fflush( stdout );
+		need_nl = 1;
 	}
 }
 
@@ -50,20 +75,26 @@ info( const char *msg, ... )
 {
 	va_list va;
 
-	if (!Quiet) {
+	if (!(DFlags & QUIET)) {
 		va_start( va, msg );
 		vprintf( msg, va );
 		va_end( va );
 		fflush( stdout );
+		need_nl = 0;
 	}
 }
 
 void
-infoc( char c )
+infon( const char *msg, ... )
 {
-	if (!Quiet) {
-		putchar( c );
+	va_list va;
+
+	if (!(DFlags & QUIET)) {
+		va_start( va, msg );
+		vprintf( msg, va );
+		va_end( va );
 		fflush( stdout );
+		need_nl = 1;
 	}
 }
 
@@ -72,13 +103,39 @@ warn( const char *msg, ... )
 {
 	va_list va;
 
-	if (Quiet < 2) {
+	if (!(DFlags & VERYQUIET)) {
+		flushn();
 		va_start( va, msg );
 		vfprintf( stderr, msg, va );
 		va_end( va );
 	}
 }
 
+void
+error( const char *msg, ... )
+{
+	va_list va;
+
+	flushn();
+	va_start( va, msg );
+	vfprintf( stderr, msg, va );
+	va_end( va );
+}
+
+void
+sys_error( const char *msg, ... )
+{
+	va_list va;
+	char buf[1024];
+
+	flushn();
+	va_start( va, msg );
+	if ((unsigned)vsnprintf( buf, sizeof(buf), msg, va ) >= sizeof(buf))
+		oob();
+	va_end( va );
+	perror( buf );
+}
+
 char *
 next_arg( char **s )
 {
@@ -145,20 +202,6 @@ free_generic_messages( message_t *msgs )
 	}
 }
 
-void
-strip_cr( msg_data_t *msgdata )
-{
-	int i, o;
-
-	if (msgdata->crlf) {
-		for (i = o = 0; i < msgdata->len; i++)
-			if (msgdata->data[i] != '\r')
-				msgdata->data[o++] = msgdata->data[i];
-		msgdata->len = o;
-		msgdata->crlf = 0;
-	}
-}
-
 #ifndef HAVE_VASPRINTF
 static int
 vasprintf( char **strp, const char *fmt, va_list ap )
@@ -349,11 +392,11 @@ arc4_init( void )
 	unsigned char j, si, dat[128];
 
 	if ((fd = open( "/dev/urandom", O_RDONLY )) < 0 && (fd = open( "/dev/random", O_RDONLY )) < 0) {
-		fprintf( stderr, "Fatal: no random number source available.\n" );
+		error( "Fatal: no random number source available.\n" );
 		exit( 3 );
 	}
 	if (read( fd, dat, 128 ) != 128) {
-		fprintf( stderr, "Fatal: cannot read random number source.\n" );
+		error( "Fatal: cannot read random number source.\n" );
 		exit( 3 );
 	}
 	close( fd );
@@ -385,3 +428,172 @@ arc4_getbyte( void )
 	rs.s[rs.j] = si;
 	return rs.s[(si + sj) & 0xff];
 }
+
+
+#ifdef HAVE_SYS_POLL_H
+static struct pollfd *pollfds;
+#else
+# ifdef HAVE_SYS_SELECT_H
+#  include <sys/select.h>
+# endif
+# define pollfds fdparms
+#endif
+static struct {
+	void (*cb)( int what, void *aux );
+	void *aux;
+#ifndef HAVE_SYS_POLL_H
+	int fd, events;
+#endif
+	int faked;
+} *fdparms;
+static int npolls, rpolls, changed, faking;
+
+static int
+find_fd( int fd )
+{
+	int n;
+
+	for (n = 0; n < npolls; n++)
+		if (pollfds[n].fd == fd)
+			return n;
+	return -1;
+}
+
+void
+add_fd( int fd, void (*cb)( int events, void *aux ), void *aux )
+{
+	int n;
+
+	assert( find_fd( fd ) < 0 );
+	n = npolls++;
+	if (rpolls < npolls) {
+		rpolls = npolls;
+#ifdef HAVE_SYS_POLL_H
+		pollfds = nfrealloc(pollfds, npolls * sizeof(*pollfds));
+#endif
+		fdparms = nfrealloc(fdparms, npolls * sizeof(*fdparms));
+	}
+	pollfds[n].fd = fd;
+	pollfds[n].events = 0; /* POLLERR & POLLHUP implicit */
+	fdparms[n].faked = 0;
+	fdparms[n].cb = cb;
+	fdparms[n].aux = aux;
+	changed = 1;
+}
+
+void
+conf_fd( int fd, int and_events, int or_events )
+{
+	int n = find_fd( fd );
+	assert( n >= 0 );
+	pollfds[n].events = (pollfds[n].events & and_events) | or_events;
+}
+
+void
+fake_fd( int fd, int events )
+{
+	int n = find_fd( fd );
+	assert( n >= 0 );
+	fdparms[n].faked |= events;
+	faking = 1;
+}
+
+void
+del_fd( int fd )
+{
+	int n = find_fd( fd );
+	assert( n >= 0 );
+	npolls--;
+#ifdef HAVE_SYS_POLL_H
+	memcpy(pollfds + n, pollfds + n + 1, (npolls - n) * sizeof(*pollfds));
+#endif
+	memcpy(fdparms + n, fdparms + n + 1, (npolls - n) * sizeof(*fdparms));
+	changed = 1;
+}
+
+#define shifted_bit(in, from, to) \
+	(((unsigned)(in) & from) \
+		/ (from > to ? from / to : 1) \
+		* (to > from ? to / from : 1))
+
+static void
+event_wait( void )
+{
+#ifndef HAVE_SYS_POLL_H
+	fd_set rfds, wfds, efds;
+	int fd;
+#endif
+	int m, n;
+
+	if (faking) {
+		faking = 0;
+		for (n = 0; n < npolls; n++)
+			if ((m = fdparms[n].faked)) {
+				fdparms[n].faked = 0;
+				fdparms[n].cb( m, fdparms[n].aux );
+				if (changed) {
+					changed = 0;
+					break;
+				}
+			}
+		return;
+	}
+#ifdef HAVE_SYS_POLL_H
+	if (poll( pollfds, npolls, -1 ) < 0) {
+		perror( "poll() failed in event loop" );
+		abort();
+	}
+	for (n = 0; n < npolls; n++)
+		if ((m = pollfds[n].revents)) {
+			assert( !(m & POLLNVAL) );
+			fdparms[n].cb( m | shifted_bit( m, POLLHUP, POLLIN ), fdparms[n].aux );
+			if (changed) {
+				changed = 0;
+				break;
+			}
+		}
+#else
+	FD_ZERO( &rfds );
+	FD_ZERO( &wfds );
+	FD_ZERO( &efds );
+	m = -1;
+	for (n = 0; n < npolls; n++) {
+		fd = fdparms[n].fd;
+		if (fdparms[n].events & POLLIN)
+			FD_SET( fd, &rfds );
+		if (fdparms[n].events & POLLOUT)
+			FD_SET( fd, &wfds );
+		FD_SET( fd, &efds );
+		if (fd > m)
+			m = fd;
+	}
+	if (select( m + 1, &rfds, &wfds, &efds, 0 ) < 0) {
+		perror( "select() failed in event loop" );
+		abort();
+	}
+	for (n = 0; n < npolls; n++) {
+		fd = fdparms[n].fd;
+		m = 0;
+		if (FD_ISSET( fd, &rfds ))
+			m = POLLIN;
+		if (FD_ISSET( fd, &wfds ))
+			m |= POLLOUT;
+		if (FD_ISSET( fd, &efds ))
+			m |= POLLERR;
+		if (m) {
+			fdparms[n].cb( m, fdparms[n].aux );
+			if (changed) {
+				changed = 0;
+				break;
+			}
+		}
+	}
+#endif
+}
+
+void
+main_loop( void )
+{
+	while (npolls)
+		event_wait();
+}
